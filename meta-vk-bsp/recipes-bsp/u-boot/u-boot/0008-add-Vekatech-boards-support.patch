From 0e7dda0183581bb8fba334f0b0328d3696e2156c Mon Sep 17 00:00:00 2001
From: dtodoroff <d.todorov@vekatech.com>
Date: Sat, 26 Jul 2025 16:37:37 +0300
Subject: [PATCH 8/8] add Vekatech boards support


diff --git a/arch/arm/dts/Makefile b/arch/arm/dts/Makefile
index e79531c283..b901660647 100644
--- a/arch/arm/dts/Makefile
+++ b/arch/arm/dts/Makefile
@@ -935,6 +935,16 @@ dtb-$(CONFIG_RCAR_GEN3) += \
 	rzg3s-dev.dtb \
 	smarc-rzg3s.dtb
 
+dtb-$(CONFIG_TARGET_VKRZG2LC) += vkrzg2lc.dtb
+dtb-$(CONFIG_TARGET_VK_D184280E) += vk-d184280e.dtb
+dtb-$(CONFIG_TARGET_VK_D184280E_1) += vk-d184280e-1.dtb
+dtb-$(CONFIG_TARGET_VKCMG2LC) += vkcmg2lc.dtb
+dtb-$(CONFIG_TARGET_VKCMG2LC_1) += vkcmg2lc_1.dtb
+dtb-$(CONFIG_TARGET_VKRZG2L) += vkrzg2l.dtb
+dtb-$(CONFIG_TARGET_VKRZG2UL) += vkrzg2ul.dtb
+dtb-$(CONFIG_TARGET_VKRZV2L) += vkrzv2l.dtb
+dtb-$(CONFIG_TARGET_VKCMV2L) += vkcmv2l.dtb
+
 ifdef CONFIG_RCAR_GEN3
 DTC_FLAGS += -R 4 -p 0x1000
 endif
diff --git a/arch/arm/dts/vk-d184280e-1.dts b/arch/arm/dts/vk-d184280e-1.dts
new file mode 100644
index 0000000000..c02b770303
--- /dev/null
+++ b/arch/arm/dts/vk-d184280e-1.dts
@@ -0,0 +1,120 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Device Tree Source for the VK-CMRZ/G2LC board
+ *
+ */
+
+/dts-v1/;
+#include <dt-bindings/gpio/gpio.h>
+#include "r9a07g044c.dtsi"
+#include "r9a07g044c-u-boot.dtsi"
+#include <dt-bindings/pinctrl/rzg2l-pinctrl.h>
+
+/ {
+        model = "Vekatech vk-d184280e 1GB";
+        compatible = "renesas,r9a07g044c", "renesas,rzg2lc";
+
+        aliases {
+                serial0 = &scif0;
+        };
+
+        chosen {
+                stdout-path = "serial0:115200n8";
+        };
+
+        memory@48000000 {
+                device_type = "memory";
+                /* first 128MB is reserved for secure area. */
+                reg = <0 0x48000000 0 0x38000000>; 
+        };
+
+};
+
+&pinctrl {
+        eth0_pins: eth0 {
+                pinmux = <RZG2L_PINMUX(28, 1, 1)>, /* ET0_LINKSTA */
+                         <RZG2L_PINMUX(27, 1, 1)>, /* ET0_MDC */
+                         <RZG2L_PINMUX(28, 0, 1)>, /* ET0_MDIO */
+                         <RZG2L_PINMUX(20, 0, 1)>, /* ET0_TXC */
+                         <RZG2L_PINMUX(20, 1, 1)>, /* ET0_TX_CTL */
+                         <RZG2L_PINMUX(20, 2, 1)>, /* ET0_TXD0 */
+                         <RZG2L_PINMUX(21, 0, 1)>, /* ET0_TXD1 */
+                         <RZG2L_PINMUX(21, 1, 1)>, /* ET0_TXD2 */
+                         <RZG2L_PINMUX(22, 0, 1)>, /* ET0_TXD3 */
+                         <RZG2L_PINMUX(24, 0, 1)>, /* ET0_RXC */
+                         <RZG2L_PINMUX(24, 1, 1)>, /* ET0_RX_CTL */
+                         <RZG2L_PINMUX(25, 0, 1)>, /* ET0_RXD0 */
+                         <RZG2L_PINMUX(25, 1, 1)>, /* ET0_RXD1 */
+                         <RZG2L_PINMUX(26, 0, 1)>, /* ET0_RXD2 */
+                         <RZG2L_PINMUX(26, 1, 1)>; /* ET0_RXD3 */
+        };
+
+	i2c2_pins: i2c2 {
+                pinmux = <RZG2L_PINMUX(42, 3, 1)>,
+                         <RZG2L_PINMUX(42, 4, 1)>;
+        }; 
+
+};
+
+&xinclk {
+        clock-frequency = <24000000>;
+};
+
+&scif0 {
+        status = "okay";
+        clock = <100000000>;
+};
+
+&sdhi0 {
+        bus-width = <8>;
+        status = "okay";
+};
+
+&eth0 {
+        pinctrl-names = "default";
+        pinctrl-0 = <&eth0_pins>;
+        phy-handle = <&phy0>;
+        phy-mode = "rgmii-id";
+        status = "okay";
+
+        phy0: ethernet-phy@1 {
+                reg = <1>;
+        };
+};
+
+&ehci0 {
+        status = "okay";
+}; 
+
+&hsusb {
+	dr_mode = "otg";
+	status = "okay";
+};
+
+&i2c0 {
+        pinctrl-names = "default";
+        status = "okay";
+
+	eeprom0: eeprom@50 {
+		compatible = "atmel,24c02";
+		reg = <0x50>;
+		pagesize = <16>;
+	};
+};
+
+&i2c1 {
+        pinctrl-names = "default";
+        status = "okay";
+};
+
+&i2c2 {
+        pinctrl-0 = <&i2c2_pins>;
+        pinctrl-names = "default";
+        status = "okay";
+};
+
+
+&wdt0 {
+        status = "okay";
+        timeout-sec = <60>;
+};
diff --git a/arch/arm/dts/vk-d184280e.dts b/arch/arm/dts/vk-d184280e.dts
new file mode 100644
index 0000000000..ad2aab4de4
--- /dev/null
+++ b/arch/arm/dts/vk-d184280e.dts
@@ -0,0 +1,120 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Device Tree Source for the VK-CMRZ/G2LC board
+ *
+ */
+
+/dts-v1/;
+#include <dt-bindings/gpio/gpio.h>
+#include "r9a07g044c.dtsi"
+#include "r9a07g044c-u-boot.dtsi"
+#include <dt-bindings/pinctrl/rzg2l-pinctrl.h>
+
+/ {
+        model = "Vekatech vk-d184280e";
+        compatible = "renesas,r9a07g044c", "renesas,rzg2lc";
+
+        aliases {
+                serial0 = &scif0;
+        };
+
+        chosen {
+                stdout-path = "serial0:115200n8";
+        };
+
+        memory@48000000 {
+                device_type = "memory";
+                /* first 128MB is reserved for secure area. */
+                reg = <0 0x48000000 0 0x78000000>; 
+        };
+
+};
+
+&pinctrl {
+        eth0_pins: eth0 {
+                pinmux = <RZG2L_PINMUX(28, 1, 1)>, /* ET0_LINKSTA */
+                         <RZG2L_PINMUX(27, 1, 1)>, /* ET0_MDC */
+                         <RZG2L_PINMUX(28, 0, 1)>, /* ET0_MDIO */
+                         <RZG2L_PINMUX(20, 0, 1)>, /* ET0_TXC */
+                         <RZG2L_PINMUX(20, 1, 1)>, /* ET0_TX_CTL */
+                         <RZG2L_PINMUX(20, 2, 1)>, /* ET0_TXD0 */
+                         <RZG2L_PINMUX(21, 0, 1)>, /* ET0_TXD1 */
+                         <RZG2L_PINMUX(21, 1, 1)>, /* ET0_TXD2 */
+                         <RZG2L_PINMUX(22, 0, 1)>, /* ET0_TXD3 */
+                         <RZG2L_PINMUX(24, 0, 1)>, /* ET0_RXC */
+                         <RZG2L_PINMUX(24, 1, 1)>, /* ET0_RX_CTL */
+                         <RZG2L_PINMUX(25, 0, 1)>, /* ET0_RXD0 */
+                         <RZG2L_PINMUX(25, 1, 1)>, /* ET0_RXD1 */
+                         <RZG2L_PINMUX(26, 0, 1)>, /* ET0_RXD2 */
+                         <RZG2L_PINMUX(26, 1, 1)>; /* ET0_RXD3 */
+        };
+
+	i2c2_pins: i2c2 {
+                pinmux = <RZG2L_PINMUX(42, 3, 1)>,
+                         <RZG2L_PINMUX(42, 4, 1)>;
+        }; 
+
+};
+
+&xinclk {
+        clock-frequency = <24000000>;
+};
+
+&scif0 {
+        status = "okay";
+        clock = <100000000>;
+};
+
+&sdhi0 {
+        bus-width = <8>;
+        status = "okay";
+};
+
+&eth0 {
+        pinctrl-names = "default";
+        pinctrl-0 = <&eth0_pins>;
+        phy-handle = <&phy0>;
+        phy-mode = "rgmii-id";
+        status = "okay";
+
+        phy0: ethernet-phy@1 {
+                reg = <1>;
+        };
+};
+
+&ehci0 {
+        status = "okay";
+}; 
+
+&hsusb {
+	dr_mode = "otg";
+	status = "okay";
+};
+
+&i2c0 {
+        pinctrl-names = "default";
+        status = "okay";
+
+	eeprom0: eeprom@50 {
+		compatible = "atmel,24c02";
+		reg = <0x50>;
+		pagesize = <16>;
+	};
+};
+
+&i2c1 {
+        pinctrl-names = "default";
+        status = "okay";
+};
+
+&i2c2 {
+        pinctrl-0 = <&i2c2_pins>;
+        pinctrl-names = "default";
+        status = "okay";
+};
+
+
+&wdt0 {
+        status = "okay";
+        timeout-sec = <60>;
+};
diff --git a/arch/arm/dts/vkcmg2lc.dts b/arch/arm/dts/vkcmg2lc.dts
new file mode 100644
index 0000000000..3ecd6fd1e3
--- /dev/null
+++ b/arch/arm/dts/vkcmg2lc.dts
@@ -0,0 +1,162 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Device Tree Source for the VK-CMRZ/G2LC board
+ *
+ */
+
+/dts-v1/;
+#include <dt-bindings/gpio/gpio.h>
+#include "r9a07g044c.dtsi"
+#include "r9a07g044c-u-boot.dtsi"
+#include <dt-bindings/pinctrl/rzg2l-pinctrl.h>
+
+/ {
+        model = "Vekatech vkcmg2lc";
+        compatible = "renesas,r9a07g044c", "renesas,rzg2lc";
+
+        aliases {
+                serial0 = &scif0;
+                spi0 = &spibsc;
+        };
+
+        chosen {
+                stdout-path = "serial0:115200n8";
+        };
+
+        memory@48000000 {
+                device_type = "memory";
+                /* first 128MB is reserved for secure area. */
+                reg = <0 0x48000000 0 0x78000000>; 
+        };
+
+};
+
+&pinctrl {
+        eth0_pins: eth0 {
+                pinmux = <RZG2L_PINMUX(28, 1, 1)>, /* ET0_LINKSTA */
+                         <RZG2L_PINMUX(27, 1, 1)>, /* ET0_MDC */
+                         <RZG2L_PINMUX(28, 0, 1)>, /* ET0_MDIO */
+                         <RZG2L_PINMUX(20, 0, 1)>, /* ET0_TXC */
+                         <RZG2L_PINMUX(20, 1, 1)>, /* ET0_TX_CTL */
+                         <RZG2L_PINMUX(20, 2, 1)>, /* ET0_TXD0 */
+                         <RZG2L_PINMUX(21, 0, 1)>, /* ET0_TXD1 */
+                         <RZG2L_PINMUX(21, 1, 1)>, /* ET0_TXD2 */
+                         <RZG2L_PINMUX(22, 0, 1)>, /* ET0_TXD3 */
+                         <RZG2L_PINMUX(24, 0, 1)>, /* ET0_RXC */
+                         <RZG2L_PINMUX(24, 1, 1)>, /* ET0_RX_CTL */
+                         <RZG2L_PINMUX(25, 0, 1)>, /* ET0_RXD0 */
+                         <RZG2L_PINMUX(25, 1, 1)>, /* ET0_RXD1 */
+                         <RZG2L_PINMUX(26, 0, 1)>, /* ET0_RXD2 */
+                         <RZG2L_PINMUX(26, 1, 1)>; /* ET0_RXD3 */
+        };
+};
+
+&xinclk {
+        clock-frequency = <24000000>;
+};
+
+&scif0 {
+        status = "okay";
+        clock = <100000000>;
+};
+
+&sdhi0 {
+        /* pinctrl placeholder
+         * If this channel is used for interfacing with a SD card, a power enable
+         * pin (SD0_PWR_EN) must be defined.
+         * The SD0_PWR_EN pin is associated with P4_1.
+         * A HIGH signal on SD0_PWR_EN will enable supply voltage for SD card.
+        */
+        bus-width = <8>;
+        status = "okay";
+};
+
+&sdhi1 {
+        /* pinctrl placeholder
+         * A power enable pin (SD1_PWR_EN) must be defined to interface with a
+         * SD card.
+         * The SD1_PWR_EN pin is associated with P39_2.
+         * A HIGH signal on SD1_PWR_EN will enable supply voltage for SD card.
+        */
+        bus-width = <4>;
+        status = "okay";
+};
+
+&eth0 {
+        pinctrl-names = "default";
+        pinctrl-0 = <&eth0_pins>;
+        phy-handle = <&phy0>;
+        phy-mode = "rgmii-id";
+        status = "okay";
+
+        phy0: ethernet-phy@1 {
+                reg = <1>;
+        };
+};
+
+&ehci0 {
+        status = "okay";
+}; 
+
+&ehci1 {
+        status = "okay";
+};
+
+&hsusb {
+	dr_mode = "otg";
+	status = "okay";
+};
+
+&i2c0 {
+        pinctrl-names = "default";
+        status = "okay";
+
+	eeprom0: eeprom@50 {
+		compatible = "atmel,24c02";
+		reg = <0x50>;
+		pagesize = <16>;
+	};
+
+	pca9538: pca953x@70 {
+		compatible = "nxp,pca9538";
+		reg = <0x70>;
+		gpio-controller;
+		#gpio-cells = <2>;
+
+		sd-pwr-en-hog {
+			gpio-hog;
+			gpios = <6 GPIO_ACTIVE_HIGH>;
+			output-high;
+			line-name = "sd_pwr_en";
+		};
+	};
+};
+
+&i2c1 {
+        pinctrl-names = "default";
+        status = "okay";
+};
+
+
+&spibsc {
+        num-cs = <1>;
+        status = "okay";
+        spi-max-frequency = <40000000>;
+        #address-cells = <1>;
+        #size-cells = <0>;
+        flash0: spi-flash@0 {
+                #address-cells = <1>;
+                #size-cells = <1>;
+                compatible = "spi-flash", "jedec,spi-nor";
+                spi-max-frequency = <40000000>;
+                spi-tx-bus-width = <1>;
+                spi-rx-bus-width = <1>;
+                reg = <0>;
+                status = "okay";
+        };
+};
+
+&wdt0 {
+        status = "okay";
+        timeout-sec = <60>;
+};
diff --git a/arch/arm/dts/vkcmg2lc_1.dts b/arch/arm/dts/vkcmg2lc_1.dts
new file mode 100644
index 0000000000..df8010d53f
--- /dev/null
+++ b/arch/arm/dts/vkcmg2lc_1.dts
@@ -0,0 +1,162 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Device Tree Source for the VK-CMRZ/G2LC board
+ *
+ */
+
+/dts-v1/;
+#include <dt-bindings/gpio/gpio.h>
+#include "r9a07g044c.dtsi"
+#include "r9a07g044c-u-boot.dtsi"
+#include <dt-bindings/pinctrl/rzg2l-pinctrl.h>
+
+/ {
+        model = "Vekatech vkcmg2lc-1GB";
+        compatible = "renesas,r9a07g044c", "renesas,rzg2lc";
+
+        aliases {
+                serial0 = &scif0;
+                spi0 = &spibsc;
+        };
+
+        chosen {
+                stdout-path = "serial0:115200n8";
+        };
+
+        memory@48000000 {
+                device_type = "memory";
+                /* first 128MB is reserved for secure area. */
+                reg = <0 0x48000000 0 0x38000000>; 
+        };
+
+};
+
+&pinctrl {
+        eth0_pins: eth0 {
+                pinmux = <RZG2L_PINMUX(28, 1, 1)>, /* ET0_LINKSTA */
+                         <RZG2L_PINMUX(27, 1, 1)>, /* ET0_MDC */
+                         <RZG2L_PINMUX(28, 0, 1)>, /* ET0_MDIO */
+                         <RZG2L_PINMUX(20, 0, 1)>, /* ET0_TXC */
+                         <RZG2L_PINMUX(20, 1, 1)>, /* ET0_TX_CTL */
+                         <RZG2L_PINMUX(20, 2, 1)>, /* ET0_TXD0 */
+                         <RZG2L_PINMUX(21, 0, 1)>, /* ET0_TXD1 */
+                         <RZG2L_PINMUX(21, 1, 1)>, /* ET0_TXD2 */
+                         <RZG2L_PINMUX(22, 0, 1)>, /* ET0_TXD3 */
+                         <RZG2L_PINMUX(24, 0, 1)>, /* ET0_RXC */
+                         <RZG2L_PINMUX(24, 1, 1)>, /* ET0_RX_CTL */
+                         <RZG2L_PINMUX(25, 0, 1)>, /* ET0_RXD0 */
+                         <RZG2L_PINMUX(25, 1, 1)>, /* ET0_RXD1 */
+                         <RZG2L_PINMUX(26, 0, 1)>, /* ET0_RXD2 */
+                         <RZG2L_PINMUX(26, 1, 1)>; /* ET0_RXD3 */
+        };
+};
+
+&xinclk {
+        clock-frequency = <24000000>;
+};
+
+&scif0 {
+        status = "okay";
+        clock = <100000000>;
+};
+
+&sdhi0 {
+        /* pinctrl placeholder
+         * If this channel is used for interfacing with a SD card, a power enable
+         * pin (SD0_PWR_EN) must be defined.
+         * The SD0_PWR_EN pin is associated with P4_1.
+         * A HIGH signal on SD0_PWR_EN will enable supply voltage for SD card.
+        */
+        bus-width = <8>;
+        status = "okay";
+};
+
+&sdhi1 {
+        /* pinctrl placeholder
+         * A power enable pin (SD1_PWR_EN) must be defined to interface with a
+         * SD card.
+         * The SD1_PWR_EN pin is associated with P39_2.
+         * A HIGH signal on SD1_PWR_EN will enable supply voltage for SD card.
+        */
+        bus-width = <4>;
+        status = "okay";
+};
+
+&eth0 {
+        pinctrl-names = "default";
+        pinctrl-0 = <&eth0_pins>;
+        phy-handle = <&phy0>;
+        phy-mode = "rgmii-id";
+        status = "okay";
+
+        phy0: ethernet-phy@1 {
+                reg = <1>;
+        };
+};
+
+&ehci0 {
+        status = "okay";
+}; 
+
+&ehci1 {
+        status = "okay";
+};
+
+&hsusb {
+	dr_mode = "otg";
+	status = "okay";
+};
+
+&i2c0 {
+        pinctrl-names = "default";
+        status = "okay";
+
+	eeprom0: eeprom@50 {
+		compatible = "atmel,24c02";
+		reg = <0x50>;
+		pagesize = <16>;
+	};
+
+	pca9538: pca953x@70 {
+		compatible = "nxp,pca9538";
+		reg = <0x70>;
+		gpio-controller;
+		#gpio-cells = <2>;
+
+		sd-pwr-en-hog {
+			gpio-hog;
+			gpios = <6 GPIO_ACTIVE_HIGH>;
+			output-high;
+			line-name = "sd_pwr_en";
+		};
+	};
+};
+
+&i2c1 {
+        pinctrl-names = "default";
+        status = "okay";
+};
+
+
+&spibsc {
+        num-cs = <1>;
+        status = "okay";
+        spi-max-frequency = <40000000>;
+        #address-cells = <1>;
+        #size-cells = <0>;
+        flash0: spi-flash@0 {
+                #address-cells = <1>;
+                #size-cells = <1>;
+                compatible = "spi-flash", "jedec,spi-nor";
+                spi-max-frequency = <40000000>;
+                spi-tx-bus-width = <1>;
+                spi-rx-bus-width = <1>;
+                reg = <0>;
+                status = "okay";
+        };
+};
+
+&wdt0 {
+        status = "okay";
+        timeout-sec = <60>;
+};
diff --git a/arch/arm/dts/vkcmv2l.dts b/arch/arm/dts/vkcmv2l.dts
new file mode 100644
index 0000000000..521c9587b6
--- /dev/null
+++ b/arch/arm/dts/vkcmv2l.dts
@@ -0,0 +1,194 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Device Tree Source for the VK-CMRZ/V2L board
+ *
+ */
+
+/dts-v1/;
+#include <dt-bindings/gpio/gpio.h>
+#include "r9a07g054l.dtsi"
+#include "r9a07g054l-u-boot.dtsi"
+#include <dt-bindings/pinctrl/rzv2l-pinctrl.h>
+
+/ {
+        model = "Vekatech vkcmv2l";
+        compatible = "renesas,r9a07g054l", "renesas,rzv2l";
+
+        aliases {
+                serial0 = &scif0;
+                spi0 = &spibsc;
+                ethernet0 = &eth0;
+                ethernet1 = &eth1;
+        };
+
+        chosen {
+                stdout-path = "serial0:115200n8";
+        };
+
+        memory@48000000 {
+                device_type = "memory";
+                /* first 128MB is reserved for secure area. */
+                reg = <0 0x48000000 0 0x78000000>;
+        };
+};
+
+&pinctrl {
+        eth0_pins: eth0 {
+                pinmux = <RZV2L_PINMUX(28, 1, 1)>, /* ET0_LINKSTA */
+                         <RZV2L_PINMUX(27, 1, 1)>, /* ET0_MDC */
+                         <RZV2L_PINMUX(28, 0, 1)>, /* ET0_MDIO */
+                         <RZV2L_PINMUX(20, 0, 1)>, /* ET0_TXC */
+                         <RZV2L_PINMUX(20, 1, 1)>, /* ET0_TX_CTL */
+                         <RZV2L_PINMUX(20, 2, 1)>, /* ET0_TXD0 */
+                         <RZV2L_PINMUX(21, 0, 1)>, /* ET0_TXD1 */
+                         <RZV2L_PINMUX(21, 1, 1)>, /* ET0_TXD2 */
+                         <RZV2L_PINMUX(22, 0, 1)>, /* ET0_TXD3 */
+                         <RZV2L_PINMUX(24, 0, 1)>, /* ET0_RXC */
+                         <RZV2L_PINMUX(24, 1, 1)>, /* ET0_RX_CTL */
+                         <RZV2L_PINMUX(25, 0, 1)>, /* ET0_RXD0 */
+                         <RZV2L_PINMUX(25, 1, 1)>, /* ET0_RXD1 */
+                         <RZV2L_PINMUX(26, 0, 1)>, /* ET0_RXD2 */
+                         <RZV2L_PINMUX(26, 1, 1)>; /* ET0_RXD3 */
+
+        };
+
+        eth1_pins: eth1 {
+                pinmux = <RZV2L_PINMUX(37, 2, 1)>, /* ET1_LINKSTA */
+                         <RZV2L_PINMUX(37, 0, 1)>, /* ET1_MDC */
+                         <RZV2L_PINMUX(37, 1, 1)>, /* ET1_MDIO */
+                         <RZV2L_PINMUX(29, 0, 1)>, /* ET1_TXC */
+                         <RZV2L_PINMUX(29, 1, 1)>, /* ET1_TX_CTL */
+                         <RZV2L_PINMUX(30, 0, 1)>, /* ET1_TXD0 */
+                         <RZV2L_PINMUX(30, 1, 1)>, /* ET1_TXD1 */
+                         <RZV2L_PINMUX(31, 0, 1)>, /* ET1_TXD2 */
+                         <RZV2L_PINMUX(31, 1, 1)>, /* ET1_TXD3 */
+                         <RZV2L_PINMUX(33, 1, 1)>, /* ET1_RXC */
+                         <RZV2L_PINMUX(34, 0, 1)>, /* ET1_RX_CTL */
+                         <RZV2L_PINMUX(34, 1, 1)>, /* ET1_RXD0 */
+                         <RZV2L_PINMUX(35, 0, 1)>, /* ET1_RXD1 */
+                         <RZV2L_PINMUX(35, 1, 1)>, /* ET1_RXD2 */
+                         <RZV2L_PINMUX(36, 0, 1)>; /* ET1_RXD3 */
+        };
+
+        i2c3_pins: i2c3 {
+                pinmux = <RZV2L_PINMUX(18, 0, 3)>,
+                         <RZV2L_PINMUX(18, 1, 3)>;
+        }; 
+};
+
+&xinclk {
+        clock-frequency = <24000000>;
+};
+
+&scif0 {
+        status = "okay";
+        clock = <100000000>;
+};
+
+&sdhi0 {
+        /* pinctrl placeholder
+         * If this channel is used for interfacing with a SD card, a power enable
+         * pin (SD0_PWR_EN) must be defined.
+         * The SD0_PWR_EN pin is associated with P19_0.
+         * A HIGH signal on SD0_PWR_EN will enable supply voltage for SD card.
+        */
+        bus-width = <8>;
+        status = "okay";
+};
+
+&sdhi1 {
+        /* pinctrl placeholder
+         * A power enable pin (SD1_PWR_EN) must be defined to interface with a
+         * SD card.
+         * The SD1_PWR_EN pin is associated with P39_2.
+         * A HIGH signal on SD1_PWR_EN will enable supply voltage for SD card.
+        */
+        bus-width = <4>;
+        status = "okay";
+};
+
+&eth0 {
+        pinctrl-names = "default";
+        pinctrl-0 = <&eth0_pins>;
+        phy-handle = <&phy0>;
+        phy-mode = "rgmii-id";
+        status = "okay";
+
+        phy0: ethernet-phy@1 {
+                reg = <1>;
+                reset-gpios = <&P22 1 (GPIO_ACTIVE_LOW|GPIO_OPEN_DRAIN)>;
+        };
+};
+
+&eth1 {
+        pinctrl-names = "default";
+        pinctrl-0 = <&eth1_pins>;
+        phy-handle = <&phy1>;
+        phy-mode = "rgmii-id";
+        status = "okay";
+
+        phy1: ethernet-phy@1 {
+                reg = <1>;
+                reset-gpios = <&P33 0 (GPIO_ACTIVE_LOW|GPIO_OPEN_DRAIN)>;
+        };
+};
+
+&ehci0 {
+        status = "okay";
+}; 
+
+&ehci1 {
+        status = "okay";
+};
+
+&hsusb {
+	dr_mode = "otg";
+	status = "okay";
+};
+
+&i2c0 {
+        pinctrl-names = "default";
+        status = "okay";
+};
+
+&i2c1 {
+        pinctrl-names = "default";
+        status = "okay";
+};
+
+
+&i2c3 {
+        pinctrl-0 = <&i2c3_pins>;
+        pinctrl-names = "default";
+        status = "okay";
+
+
+	eeprom0: eeprom@50 {
+		compatible = "atmel,24c02";
+		reg = <0x50>;
+		pagesize = <16>;
+	};
+};
+
+&spibsc {
+        num-cs = <1>;
+        status = "okay";
+        spi-max-frequency = <40000000>;
+        #address-cells = <1>;
+        #size-cells = <0>;
+        flash0: spi-flash@0 {
+                #address-cells = <1>;
+                #size-cells = <1>;
+                compatible = "spi-flash", "jedec,spi-nor";
+                spi-max-frequency = <40000000>;
+                spi-tx-bus-width = <1>;
+                spi-rx-bus-width = <1>;
+                reg = <0>;
+                status = "okay";
+        };
+};
+
+&wdt0 {
+        status = "okay";
+        timeout-sec = <60>;
+};
diff --git a/arch/arm/dts/vkrzg2l.dts b/arch/arm/dts/vkrzg2l.dts
new file mode 100644
index 0000000000..14bf60472d
--- /dev/null
+++ b/arch/arm/dts/vkrzg2l.dts
@@ -0,0 +1,248 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Device Tree Source for the VK-RZG2L board
+ *
+ * Copyright (C) 2017 Jacopo Mondi <jacopo+renesas@jmondi.org>
+ * Copyright (C) 2016 Renesas Electronics
+ */
+
+/dts-v1/;
+#include <dt-bindings/gpio/gpio.h>
+#include "r9a07g044l.dtsi"
+#include "r9a07g044l-u-boot.dtsi"
+#include <dt-bindings/pinctrl/rzg2l-pinctrl.h>
+
+/ {
+        model = "Vekatech vkrzg2l";
+        compatible = "renesas,r9a07g044l", "renesas,rzg2l";
+
+        aliases {
+                serial0 = &scif0;
+                serial1 = &scif1;
+                serial2 = &scif2;
+                spi0 = &spibsc;
+                ethernet0 = &eth0;
+                ethernet1 = &eth1;
+        };
+
+        chosen {
+                stdout-path = "serial0:115200n8";
+        };
+
+        memory@48000000 {
+                device_type = "memory";
+                /* first 128MB is reserved for secure area. */
+                reg = <0 0x48000000 0 0x78000000>;
+                /*reg = <0 0x48000000 0 0x38000000>;*/
+        };
+
+
+        usb0-select {
+                label = "usb0-sel";
+                gpios = <&P5 2 GPIO_ACTIVE_HIGH>;
+        };
+
+};
+
+&pinctrl {
+        eth0_pins: eth0 {
+                pinmux = <RZG2L_PINMUX(28, 1, 1)>, /* ET0_LINKSTA */
+                         <RZG2L_PINMUX(27, 1, 1)>, /* ET0_MDC */
+                         <RZG2L_PINMUX(28, 0, 1)>, /* ET0_MDIO */
+                         <RZG2L_PINMUX(20, 0, 1)>, /* ET0_TXC */
+                         <RZG2L_PINMUX(20, 1, 1)>, /* ET0_TX_CTL */
+                         <RZG2L_PINMUX(20, 2, 1)>, /* ET0_TXD0 */
+                         <RZG2L_PINMUX(21, 0, 1)>, /* ET0_TXD1 */
+                         <RZG2L_PINMUX(21, 1, 1)>, /* ET0_TXD2 */
+                         <RZG2L_PINMUX(22, 0, 1)>, /* ET0_TXD3 */
+                         <RZG2L_PINMUX(24, 0, 1)>, /* ET0_RXC */
+                         <RZG2L_PINMUX(24, 1, 1)>, /* ET0_RX_CTL */
+                         <RZG2L_PINMUX(25, 0, 1)>, /* ET0_RXD0 */
+                         <RZG2L_PINMUX(25, 1, 1)>, /* ET0_RXD1 */
+                         <RZG2L_PINMUX(26, 0, 1)>, /* ET0_RXD2 */
+                         <RZG2L_PINMUX(26, 1, 1)>; /* ET0_RXD3 */
+
+        };
+
+        eth1_pins: eth1 {
+                pinmux = <RZG2L_PINMUX(37, 2, 1)>, /* ET1_LINKSTA */
+                         <RZG2L_PINMUX(37, 0, 1)>, /* ET1_MDC */
+                         <RZG2L_PINMUX(37, 1, 1)>, /* ET1_MDIO */
+                         <RZG2L_PINMUX(29, 0, 1)>, /* ET1_TXC */
+                         <RZG2L_PINMUX(29, 1, 1)>, /* ET1_TX_CTL */
+                         <RZG2L_PINMUX(30, 0, 1)>, /* ET1_TXD0 */
+                         <RZG2L_PINMUX(30, 1, 1)>, /* ET1_TXD1 */
+                         <RZG2L_PINMUX(31, 0, 1)>, /* ET1_TXD2 */
+                         <RZG2L_PINMUX(31, 1, 1)>, /* ET1_TXD3 */
+                         <RZG2L_PINMUX(33, 1, 1)>, /* ET1_RXC */
+                         <RZG2L_PINMUX(34, 0, 1)>, /* ET1_RX_CTL */
+                         <RZG2L_PINMUX(34, 1, 1)>, /* ET1_RXD0 */
+                         <RZG2L_PINMUX(35, 0, 1)>, /* ET1_RXD1 */
+                         <RZG2L_PINMUX(35, 1, 1)>, /* ET1_RXD2 */
+                         <RZG2L_PINMUX(36, 0, 1)>; /* ET1_RXD3 */
+        };
+
+        i2c2_pins: i2c2 {
+                pinmux = <RZG2L_PINMUX(46, 0, 4)>,
+                         <RZG2L_PINMUX(46, 1, 4)>;
+        }; 
+
+        i2c3_pins: i2c3 {
+                pinmux = <RZG2L_PINMUX(18, 0, 3)>,
+                         <RZG2L_PINMUX(18, 1, 3)>;
+        }; 
+
+        scif1_pins: scif1 {
+                pinmux = <RZG2L_PINMUX(40, 0, 1)>,
+                         <RZG2L_PINMUX(40, 1, 1)>;
+        };
+
+        scif2_pins: scif2 {
+                pinmux = <RZG2L_PINMUX(48, 0, 1)>,
+                         <RZG2L_PINMUX(48, 1, 1)>;
+        };
+};
+
+&xinclk {
+        clock-frequency = <24000000>;
+};
+
+&scif0 {
+        status = "okay";
+        clock = <100000000>;
+};
+
+&scif1 {
+        pinctrl-names = "default";
+        pinctrl-0 = <&scif1_pins>;
+
+        status = "okay";
+};
+
+&scif2 {
+        pinctrl-names = "default";
+        pinctrl-0 = <&scif2_pins>;
+
+        status = "okay";
+};
+
+
+&sdhi0 {
+        /* pinctrl placeholder
+         * If this channel is used for interfacing with a SD card, a power enable
+         * pin (SD0_PWR_EN) must be defined.
+         * The SD0_PWR_EN pin is associated with P19_0.
+         * A HIGH signal on SD0_PWR_EN will enable supply voltage for SD card.
+        */
+        bus-width = <8>;
+        status = "okay";
+        /* This is used for interface that support both eMMC and SD in board */
+        mutual-channel;
+};
+
+&eth0 {
+        pinctrl-names = "default";
+        pinctrl-0 = <&eth0_pins>;
+        phy-handle = <&phy0>;
+        phy-mode = "rgmii-id";
+        status = "okay";
+
+        phy0: ethernet-phy@1 {
+                reg = <1>;
+                reset-gpios = <&P39 2 GPIO_ACTIVE_LOW>;
+        };
+};
+
+&eth1 {
+        pinctrl-names = "default";
+        pinctrl-0 = <&eth1_pins>;
+        phy-handle = <&phy1>;
+        phy-mode = "rgmii-id";
+        status = "okay";
+
+        phy1: ethernet-phy@1 {
+                reg = <1>;
+                reset-gpios = <&P7 0 GPIO_ACTIVE_LOW>;
+        };
+};
+
+&ehci0 {
+        status = "okay";
+}; 
+
+&ehci1 {
+        status = "okay";
+};
+
+&hsusb {
+	dr_mode = "otg";
+	status = "okay";
+};
+
+&i2c0 {
+        pinctrl-names = "default";
+        status = "okay";
+};
+
+&i2c1 {
+        pinctrl-names = "default";
+        status = "okay";
+};
+
+
+&i2c2 {
+        pinctrl-0 = <&i2c2_pins>;
+        pinctrl-names = "default";
+        status = "okay";
+};
+
+&i2c3 {
+        pinctrl-0 = <&i2c3_pins>;
+        pinctrl-names = "default";
+        status = "okay";
+
+        versa3: versa3@68 {
+                compatible = "renesas,5p35023";
+                reg = <0x68>;
+                #clock-cells = <1>;
+                clocks = <&xinclk>;
+                clock-names = "x1";
+                renesas,settings = [
+                 00 00 11 19 00 42 cc 2b 04 32 00 1a 5f 12 90 79
+                 02 4c 00 00 00 00 00 00 10 24 19 bf 3f 30 90 86
+                 80 b2 05 c4 9c 
+                ];
+                assigned-clocks = <&versa3 0>,
+                                  <&versa3 1>,
+                                  <&versa3 2>,
+                                  <&versa3 3>,
+                                  <&versa3 4>,
+                                  <&versa3 5>;
+                assigned-clock-rates = <12288000>, <25000000>,
+                                       <25000000>, <12288000>,
+                                       <11289600>, <24000000>;
+        };
+};
+
+&spibsc {
+        num-cs = <1>;
+        status = "okay";
+        spi-max-frequency = <40000000>;
+        #address-cells = <1>;
+        #size-cells = <0>;
+        flash0: spi-flash@0 {
+                #address-cells = <1>;
+                #size-cells = <1>;
+                compatible = "spi-flash", "jedec,spi-nor";
+                spi-max-frequency = <40000000>;
+                spi-tx-bus-width = <1>;
+                spi-rx-bus-width = <1>;
+                reg = <0>;
+                status = "okay";
+        };
+};
+
+&wdt0 {
+        status = "okay";
+        timeout-sec = <60>;
+};
diff --git a/arch/arm/dts/vkrzg2lc.dts b/arch/arm/dts/vkrzg2lc.dts
new file mode 100644
index 0000000000..51ab97120b
--- /dev/null
+++ b/arch/arm/dts/vkrzg2lc.dts
@@ -0,0 +1,160 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Device Tree Source for the VK-RZG2LC board
+ *
+ */
+
+/dts-v1/;
+#include <dt-bindings/gpio/gpio.h>
+#include "r9a07g044c.dtsi"
+#include "r9a07g044c-u-boot.dtsi"
+#include <dt-bindings/pinctrl/rzg2l-pinctrl.h>
+
+/ {
+        model = "Vekatech vkrzg2lc";
+        compatible = "renesas,r9a07g044c", "renesas,rzg2lc";
+
+        aliases {
+                serial0 = &scif0;
+                spi0 = &spibsc;
+        };
+
+        chosen {
+                stdout-path = "serial0:115200n8";
+        };
+
+        memory@48000000 {
+                device_type = "memory";
+                /* first 128MB is reserved for secure area. */
+                reg = <0 0x48000000 0 0x78000000>; 
+                /*reg = <0 0x48000000 0 0x38000000>; */ 
+        };
+
+};
+
+&pinctrl {
+        eth0_pins: eth0 {
+                pinmux = <RZG2L_PINMUX(28, 1, 1)>, /* ET0_LINKSTA */
+                         <RZG2L_PINMUX(27, 1, 1)>, /* ET0_MDC */
+                         <RZG2L_PINMUX(28, 0, 1)>, /* ET0_MDIO */
+                         <RZG2L_PINMUX(20, 0, 1)>, /* ET0_TXC */
+                         <RZG2L_PINMUX(20, 1, 1)>, /* ET0_TX_CTL */
+                         <RZG2L_PINMUX(20, 2, 1)>, /* ET0_TXD0 */
+                         <RZG2L_PINMUX(21, 0, 1)>, /* ET0_TXD1 */
+                         <RZG2L_PINMUX(21, 1, 1)>, /* ET0_TXD2 */
+                         <RZG2L_PINMUX(22, 0, 1)>, /* ET0_TXD3 */
+                         <RZG2L_PINMUX(24, 0, 1)>, /* ET0_RXC */
+                         <RZG2L_PINMUX(24, 1, 1)>, /* ET0_RX_CTL */
+                         <RZG2L_PINMUX(25, 0, 1)>, /* ET0_RXD0 */
+                         <RZG2L_PINMUX(25, 1, 1)>, /* ET0_RXD1 */
+                         <RZG2L_PINMUX(26, 0, 1)>, /* ET0_RXD2 */
+                         <RZG2L_PINMUX(26, 1, 1)>; /* ET0_RXD3 */
+        };
+
+        i2c3_pins: i2c3 {
+                pinmux = <RZG2L_PINMUX(18, 0, 3)>,
+                         <RZG2L_PINMUX(18, 1, 3)>;
+        }; 
+};
+
+&xinclk {
+        clock-frequency = <24000000>;
+};
+
+&scif0 {
+        status = "okay";
+        clock = <100000000>;
+};
+
+&sdhi0 {
+        /* pinctrl placeholder
+         * If this channel is used for interfacing with a SD card, a power enable
+         * pin (SD0_PWR_EN) must be defined.
+         * The SD0_PWR_EN pin is associated with P4_1.
+         * A HIGH signal on SD0_PWR_EN will enable supply voltage for SD card.
+        */
+        bus-width = <8>;
+        status = "okay";
+};
+
+&sdhi1 {
+        /* pinctrl placeholder
+         * A power enable pin (SD1_PWR_EN) must be defined to interface with a
+         * SD card.
+         * The SD1_PWR_EN pin is associated with P39_2.
+         * A HIGH signal on SD1_PWR_EN will enable supply voltage for SD card.
+        */
+        bus-width = <4>;
+        status = "okay";
+};
+
+&eth0 {
+        pinctrl-names = "default";
+        pinctrl-0 = <&eth0_pins>;
+        phy-handle = <&phy0>;
+        phy-mode = "rgmii-id";
+        status = "okay";
+
+        phy0: ethernet-phy@1 {
+                reg = <1>;
+        };
+};
+
+&ehci0 {
+        status = "okay";
+}; 
+
+&ehci1 {
+        status = "okay";
+};
+
+&hsusb {
+	dr_mode = "otg";
+	status = "okay";
+};
+
+&i2c0 {
+        pinctrl-names = "default";
+        status = "okay";
+
+	eeprom0: eeprom@50 {
+		compatible = "atmel,24c02";
+		reg = <0x50>;
+		pagesize = <16>;
+	};
+};
+
+&i2c1 {
+        pinctrl-names = "default";
+        status = "okay";
+};
+
+
+&i2c3 {
+        pinctrl-0 = <&i2c3_pins>;
+        pinctrl-names = "default";
+        status = "okay";
+};
+
+&spibsc {
+        num-cs = <1>;
+        status = "okay";
+        spi-max-frequency = <40000000>;
+        #address-cells = <1>;
+        #size-cells = <0>;
+        flash0: spi-flash@0 {
+                #address-cells = <1>;
+                #size-cells = <1>;
+                compatible = "spi-flash", "jedec,spi-nor";
+                spi-max-frequency = <40000000>;
+                spi-tx-bus-width = <1>;
+                spi-rx-bus-width = <1>;
+                reg = <0>;
+                status = "okay";
+        };
+};
+
+&wdt0 {
+        status = "okay";
+        timeout-sec = <60>;
+};
diff --git a/arch/arm/dts/vkrzg2ul.dts b/arch/arm/dts/vkrzg2ul.dts
new file mode 100644
index 0000000000..5ee987405b
--- /dev/null
+++ b/arch/arm/dts/vkrzg2ul.dts
@@ -0,0 +1,195 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Device Tree Source for the VK-RZG2UL board
+ *
+ */
+
+/dts-v1/;
+#include <dt-bindings/gpio/gpio.h>
+#include "r9a07g043u11.dtsi"
+#include "r9a07g043u11-u-boot.dtsi"
+#include <dt-bindings/pinctrl/rzg2l-pinctrl.h>
+
+/ {
+        model = "Vekatech vkrzg2ul";
+	compatible = "renesas,r9a07g043u", "renesas,rzg2ul";
+
+        aliases {
+                serial0 = &scif0;
+                spi0 = &spibsc;
+        };
+
+        chosen {
+                stdout-path = "serial0:115200n8";
+        };
+
+        memory@48000000 {
+                device_type = "memory";
+                /* first 128MB is reserved for secure area. */
+                reg = <0 0x48000000 0 0x38000000>;
+        };
+
+};
+
+&pinctrl {
+        eth0_pins: eth0 {
+                pinmux = <RZG2L_PINMUX( 1, 0, 1)>, /* ET0_TXC */
+                         <RZG2L_PINMUX( 1, 1, 1)>, /* ET0_TX_CTL */
+                         <RZG2L_PINMUX( 1, 2, 1)>, /* ET0_TXD0 */
+                         <RZG2L_PINMUX( 1, 3, 1)>, /* ET0_TXD1 */
+                         <RZG2L_PINMUX( 1, 4, 1)>, /* ET0_TXD2 */
+                         <RZG2L_PINMUX( 2, 0, 1)>, /* ET0_TXD3 */
+                         <RZG2L_PINMUX( 3, 0, 1)>, /* ET0_RXC */
+                         <RZG2L_PINMUX( 3, 1, 1)>, /* ET0_RX_CTL */
+                         <RZG2L_PINMUX( 3, 2, 1)>, /* ET0_RXD0 */
+                         <RZG2L_PINMUX( 3, 3, 1)>, /* ET0_RXD1 */
+                         <RZG2L_PINMUX( 4, 0, 1)>, /* ET0_RXD2 */
+                         <RZG2L_PINMUX( 4, 1, 1)>, /* ET0_RXD3 */
+                         <RZG2L_PINMUX( 4, 3, 1)>, /* ET0_MDC */
+                         <RZG2L_PINMUX( 4, 4, 1)>, /* ET0_MDIO */
+			 <RZG2L_PINMUX( 4, 5, 1)>; /* ET0_LINKSTA */
+        };
+
+        eth1_pins: eth1 {
+        	pinmux = <RZG2L_PINMUX(7, 0, 1)>,  /* ET1_TXC */      
+        		 <RZG2L_PINMUX(7, 1, 1)>,  /* ET1_TX_CTL */    
+        		 <RZG2L_PINMUX(7, 2, 1)>,  /* ET1_TXD0 */      
+        		 <RZG2L_PINMUX(7, 3, 1)>,  /* ET1_TXD1 */      
+        		 <RZG2L_PINMUX(7, 4, 1)>,  /* ET1_TXD2 */      
+        		 <RZG2L_PINMUX(8, 0, 1)>,  /* ET1_TXD3 */      
+        		 <RZG2L_PINMUX(8, 4, 1)>,  /* ET1_RXC */       
+        		 <RZG2L_PINMUX(9, 0, 1)>,  /* ET1_RX_CTL */    
+        		 <RZG2L_PINMUX(9, 1, 1)>,  /* ET1_RXD0 */      
+        		 <RZG2L_PINMUX(9, 2, 1)>,  /* ET1_RXD1 */      
+        		 <RZG2L_PINMUX(9, 3, 1)>,  /* ET1_RXD2 */      
+        		 <RZG2L_PINMUX(10, 0, 1)>, /* ET1_RXD3 */      
+        		 <RZG2L_PINMUX(10, 2, 1)>, /* ET1_MDC */      
+        		 <RZG2L_PINMUX(10, 3, 1)>, /* ET1_MDIO */     
+        		 <RZG2L_PINMUX(10, 4, 1)>; /* ET1_LINKSTA */   
+            };
+
+        i2c3_pins: i2c3 {
+                pinmux = <RZG2L_PINMUX(0, 0, 2)>,
+                         <RZG2L_PINMUX(0, 1, 2)>;
+        }; 
+};
+
+&xinclk {
+        clock-frequency = <24000000>;
+};
+
+&scif0 {
+        status = "okay";
+        clock = <100000000>;
+};
+
+&sdhi0 {
+        /* pinctrl placeholder
+         * If this channel is used for interfacing with a SD card, a power enable
+         * pin (SD0_PWR_EN) must be defined.
+         * The SD0_PWR_EN pin is associated with P4_1.
+         * A HIGH signal on SD0_PWR_EN will enable supply voltage for SD card.
+        */
+        bus-width = <8>;
+        status = "okay";
+};
+
+&sdhi1 {
+        /* pinctrl placeholder
+         * A power enable pin (SD1_PWR_EN) must be defined to interface with a
+         * SD card.
+         * The SD1_PWR_EN pin is associated with P39_2.
+         * A HIGH signal on SD1_PWR_EN will enable supply voltage for SD card.
+        */
+        bus-width = <4>;
+        status = "okay";
+};
+
+&eth0 {
+        pinctrl-names = "default";
+        pinctrl-0 = <&eth0_pins>;
+        phy-handle = <&phy0>;
+        phy-mode = "rgmii-id";
+        status = "okay";
+
+        phy0: ethernet-phy@1 {
+                reg = <1>;
+                /*reset-gpios = <&P4 2 GPIO_ACTIVE_LOW>;*/
+		reset-gpios = <&P4 2 (GPIO_ACTIVE_LOW|GPIO_OPEN_DRAIN)>;
+        };
+};
+
+   
+&eth1 {
+        pinctrl-names = "default";
+        pinctrl-0 = <&eth1_pins>;
+        phy-handle = <&phy1>;
+        phy-mode = "rgmii-id";
+        status = "okay";
+
+        phy1: ethernet-phy@1 {
+                reg = <1>;
+                reset-gpios = <&P10 1 (GPIO_ACTIVE_LOW|GPIO_OPEN_DRAIN)>;
+        };
+};
+
+
+&ehci0 {
+        status = "okay";
+}; 
+
+&ehci1 {
+        status = "okay";
+};
+
+&hsusb {
+	dr_mode = "otg";
+	status = "okay";
+};
+
+&i2c0 {
+        pinctrl-names = "default";
+        status = "okay";
+
+};
+
+&i2c1 {
+        pinctrl-names = "default";
+        status = "okay";
+
+	eeprom0: eeprom@50 {
+		compatible = "atmel,24c02";
+		reg = <0x50>;
+		pagesize = <16>;
+	};
+};
+
+
+&i2c3 {
+        pinctrl-0 = <&i2c3_pins>;
+        pinctrl-names = "default";
+        status = "okay";
+};
+
+&spibsc {
+        num-cs = <1>;
+        status = "okay";
+        spi-max-frequency = <40000000>;
+        #address-cells = <1>;
+        #size-cells = <0>;
+        flash0: spi-flash@0 {
+                #address-cells = <1>;
+                #size-cells = <1>;
+                compatible = "spi-flash", "jedec,spi-nor";
+                spi-max-frequency = <40000000>;
+                spi-tx-bus-width = <1>;
+                spi-rx-bus-width = <1>;
+                reg = <0>;
+                status = "okay";
+        };
+};
+
+&wdt0 {
+        status = "okay";
+        timeout-sec = <60>;
+};
diff --git a/arch/arm/dts/vkrzv2l.dts b/arch/arm/dts/vkrzv2l.dts
new file mode 100644
index 0000000000..9a803f26c2
--- /dev/null
+++ b/arch/arm/dts/vkrzv2l.dts
@@ -0,0 +1,246 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Device Tree Source for the VK-RZV2L board
+ *
+ * Copyright (C) 2017 Jacopo Mondi <jacopo+renesas@jmondi.org>
+ * Copyright (C) 2016 Renesas Electronics
+ */
+
+/dts-v1/;
+#include <dt-bindings/gpio/gpio.h>
+#include "r9a07g054l.dtsi"
+#include "r9a07g054l-u-boot.dtsi"
+#include <dt-bindings/pinctrl/rzv2l-pinctrl.h>
+
+/ {
+        model = "Vekatech vkrzv2l";
+        compatible = "renesas,r9a07g054l", "renesas,rzv2l";
+
+        aliases {
+                serial0 = &scif0;
+                serial1 = &scif1;
+                serial2 = &scif2;
+                spi0 = &spibsc;
+                ethernet0 = &eth0;
+                ethernet1 = &eth1;
+        };
+
+        chosen {
+                stdout-path = "serial0:115200n8";
+        };
+
+        memory@48000000 {
+                device_type = "memory";
+                /* first 128MB is reserved for secure area. */
+                reg = <0 0x48000000 0 0x78000000>;
+        };
+
+
+        usb0-select {
+                label = "usb0-sel";
+                gpios = <&P5 2 GPIO_ACTIVE_HIGH>;
+        };
+
+};
+
+&pinctrl {
+        eth0_pins: eth0 {
+                pinmux = <RZV2L_PINMUX(28, 1, 1)>, /* ET0_LINKSTA */
+                         <RZV2L_PINMUX(27, 1, 1)>, /* ET0_MDC */
+                         <RZV2L_PINMUX(28, 0, 1)>, /* ET0_MDIO */
+                         <RZV2L_PINMUX(20, 0, 1)>, /* ET0_TXC */
+                         <RZV2L_PINMUX(20, 1, 1)>, /* ET0_TX_CTL */
+                         <RZV2L_PINMUX(20, 2, 1)>, /* ET0_TXD0 */
+                         <RZV2L_PINMUX(21, 0, 1)>, /* ET0_TXD1 */
+                         <RZV2L_PINMUX(21, 1, 1)>, /* ET0_TXD2 */
+                         <RZV2L_PINMUX(22, 0, 1)>, /* ET0_TXD3 */
+                         <RZV2L_PINMUX(24, 0, 1)>, /* ET0_RXC */
+                         <RZV2L_PINMUX(24, 1, 1)>, /* ET0_RX_CTL */
+                         <RZV2L_PINMUX(25, 0, 1)>, /* ET0_RXD0 */
+                         <RZV2L_PINMUX(25, 1, 1)>, /* ET0_RXD1 */
+                         <RZV2L_PINMUX(26, 0, 1)>, /* ET0_RXD2 */
+                         <RZV2L_PINMUX(26, 1, 1)>; /* ET0_RXD3 */
+
+        };
+
+        eth1_pins: eth1 {
+                pinmux = <RZV2L_PINMUX(37, 2, 1)>, /* ET1_LINKSTA */
+                         <RZV2L_PINMUX(37, 0, 1)>, /* ET1_MDC */
+                         <RZV2L_PINMUX(37, 1, 1)>, /* ET1_MDIO */
+                         <RZV2L_PINMUX(29, 0, 1)>, /* ET1_TXC */
+                         <RZV2L_PINMUX(29, 1, 1)>, /* ET1_TX_CTL */
+                         <RZV2L_PINMUX(30, 0, 1)>, /* ET1_TXD0 */
+                         <RZV2L_PINMUX(30, 1, 1)>, /* ET1_TXD1 */
+                         <RZV2L_PINMUX(31, 0, 1)>, /* ET1_TXD2 */
+                         <RZV2L_PINMUX(31, 1, 1)>, /* ET1_TXD3 */
+                         <RZV2L_PINMUX(33, 1, 1)>, /* ET1_RXC */
+                         <RZV2L_PINMUX(34, 0, 1)>, /* ET1_RX_CTL */
+                         <RZV2L_PINMUX(34, 1, 1)>, /* ET1_RXD0 */
+                         <RZV2L_PINMUX(35, 0, 1)>, /* ET1_RXD1 */
+                         <RZV2L_PINMUX(35, 1, 1)>, /* ET1_RXD2 */
+                         <RZV2L_PINMUX(36, 0, 1)>; /* ET1_RXD3 */
+        };
+
+        i2c2_pins: i2c2 {
+                pinmux = <RZV2L_PINMUX(46, 0, 4)>,
+                         <RZV2L_PINMUX(46, 1, 4)>;
+        }; 
+
+        i2c3_pins: i2c3 {
+                pinmux = <RZV2L_PINMUX(18, 0, 3)>,
+                         <RZV2L_PINMUX(18, 1, 3)>;
+        }; 
+
+        scif1_pins: scif1 {
+                pinmux = <RZV2L_PINMUX(40, 0, 1)>,
+                         <RZV2L_PINMUX(40, 1, 1)>;
+        };
+
+        scif2_pins: scif2 {
+                pinmux = <RZV2L_PINMUX(48, 0, 1)>,
+                         <RZV2L_PINMUX(48, 1, 1)>;
+        };
+};
+
+&xinclk {
+        clock-frequency = <24000000>;
+};
+
+&scif0 {
+        status = "okay";
+        clock = <100000000>;
+};
+
+&scif1 {
+        pinctrl-names = "default";
+        pinctrl-0 = <&scif1_pins>;
+
+        status = "okay";
+};
+
+&scif2 {
+        pinctrl-names = "default";
+        pinctrl-0 = <&scif2_pins>;
+
+        status = "okay";
+};
+
+&sdhi0 {
+        /* pinctrl placeholder
+         * If this channel is used for interfacing with a SD card, a power enable
+         * pin (SD0_PWR_EN) must be defined.
+         * The SD0_PWR_EN pin is associated with P19_0.
+         * A HIGH signal on SD0_PWR_EN will enable supply voltage for SD card.
+        */
+        bus-width = <8>;
+        status = "okay";
+        /* This is used for interface that support both eMMC and SD in board */
+        mutual-channel;
+};
+
+&eth0 {
+        pinctrl-names = "default";
+        pinctrl-0 = <&eth0_pins>;
+        phy-handle = <&phy0>;
+        phy-mode = "rgmii-id";
+        status = "okay";
+
+        phy0: ethernet-phy@1 {
+                reg = <1>;
+                reset-gpios = <&P39 2 GPIO_ACTIVE_LOW>;
+        };
+};
+
+&eth1 {
+        pinctrl-names = "default";
+        pinctrl-0 = <&eth1_pins>;
+        phy-handle = <&phy1>;
+        phy-mode = "rgmii-id";
+        status = "okay";
+
+        phy1: ethernet-phy@1 {
+                reg = <1>;
+                reset-gpios = <&P7 0 GPIO_ACTIVE_LOW>;
+        };
+};
+
+&ehci0 {
+        status = "okay";
+}; 
+
+&ehci1 {
+        status = "okay";
+};
+
+&hsusb {
+	dr_mode = "otg";
+	status = "okay";
+};
+
+&i2c0 {
+        pinctrl-names = "default";
+        status = "okay";
+};
+
+&i2c1 {
+        pinctrl-names = "default";
+        status = "okay";
+};
+
+
+&i2c2 {
+        pinctrl-0 = <&i2c2_pins>;
+        pinctrl-names = "default";
+        status = "okay";
+};
+
+&i2c3 {
+        pinctrl-0 = <&i2c3_pins>;
+        pinctrl-names = "default";
+        status = "okay";
+
+        versa3: versa3@68 {
+                compatible = "renesas,5p35023";
+                reg = <0x68>;
+                #clock-cells = <1>;
+                clocks = <&xinclk>;
+                clock-names = "x1";
+                renesas,settings = [
+                 00 00 11 19 00 42 cc 2b 04 32 00 1a 5f 12 90 79
+                 02 4c 00 00 00 00 00 00 10 24 19 bf 3f 30 90 86
+                 80 b2 05 c4 9c 
+                ];
+                assigned-clocks = <&versa3 0>,
+                                  <&versa3 1>,
+                                  <&versa3 2>,
+                                  <&versa3 3>,
+                                  <&versa3 4>,
+                                  <&versa3 5>;
+                assigned-clock-rates = <12288000>, <25000000>,
+                                       <25000000>, <12288000>,
+                                       <11289600>, <24000000>;
+        };
+};
+
+&spibsc {
+        num-cs = <1>;
+        status = "okay";
+        spi-max-frequency = <40000000>;
+        #address-cells = <1>;
+        #size-cells = <0>;
+        flash0: spi-flash@0 {
+                #address-cells = <1>;
+                #size-cells = <1>;
+                compatible = "spi-flash", "jedec,spi-nor";
+                spi-max-frequency = <40000000>;
+                spi-tx-bus-width = <1>;
+                spi-rx-bus-width = <1>;
+                reg = <0>;
+                status = "okay";
+        };
+};
+
+&wdt0 {
+        status = "okay";
+        timeout-sec = <60>;
+};
diff --git a/arch/arm/mach-rmobile/Kconfig.64 b/arch/arm/mach-rmobile/Kconfig.64
index 28b10473c4..599da4595b 100644
--- a/arch/arm/mach-rmobile/Kconfig.64
+++ b/arch/arm/mach-rmobile/Kconfig.64
@@ -235,6 +235,52 @@ config TARGET_SMARC_RZG3S
 	help
           Support for Renesas RZ/G3S SMARC Platform
 
+config TARGET_VKRZG2L
+        bool "Vekatech VK-RZ/G2L Board "
+        help
+          Support for Vekatech VK-RZ/G2L Board
+
+config TARGET_VKRZG2LC
+        bool "Vekatech VK-RZ/G2LC Board "
+        help
+          Support for Vekatech VK-RZ/G2LC Board
+
+config TARGET_VKCMG2LC
+        bool "Vekatech VK-CMRZ/G2LC Board "
+        help
+          Support for Vekatech VK-CMRZ/G2LC Board
+
+config TARGET_VKCMG2LC_1
+        bool "Vekatech VK-CMRZ/G2LC Board 1GB DDR4"
+        help
+          Support for Vekatech VK-CMRZ/G2LC Board 1GB DDR4
+
+config TARGET_VKRZV2L
+        bool "Vekatech VK-RZ/V2L Board "
+        help
+          Support for Vekatech VK-RZ/V2L Board
+
+config TARGET_VKCMV2L
+        bool "Vekatech VK-CMRZ/V2L Board "
+        help
+          Support for Vekatech VK-CMRZ/V2L Board
+
+config TARGET_VKRZG2UL
+        bool "Vekatech VK-RZ/G2UL Board "
+        help
+          Support for Vekatech VK-RZ/G2UL Board
+
+config TARGET_VK_D184280E
+        bool "Vekatech VK-D184280E Board "
+        help
+          Support for Vekatech VK-D184280E Board
+
+config TARGET_VK_D184280E_1
+        bool "Vekatech VK-D184280E Board 1GB DDR4 "
+        help
+          Support for Vekatech VK-D184280E Board 1GB DDR4
+
+
 endchoice
 
 config SYS_SOC
@@ -255,6 +301,13 @@ source "board/renesas/rzv2l-dev/Kconfig"
 source "board/renesas/rzg2lc-dev/Kconfig"
 source "board/renesas/rzg2ul-dev/Kconfig"
 source "board/renesas/rzg3s-dev/Kconfig"
+source "board/renesas/vkrzg2l/Kconfig"
+source "board/renesas/vkrzg2lc/Kconfig"
+source "board/renesas/vkcmg2lc/Kconfig"
+source "board/renesas/vkrzv2l/Kconfig"
+source "board/renesas/vkrzg2ul/Kconfig"
+source "board/renesas/vk-d184280e/Kconfig"
+source "board/renesas/vkcmv2l/Kconfig"
 
 config MULTI_DTB_FIT_UNCOMPRESS_SZ
 	default 0x80000 if TARGET_HIHOPE_RZG2
diff --git a/board/renesas/vk-d184280e/Kconfig b/board/renesas/vk-d184280e/Kconfig
new file mode 100644
index 0000000000..804e083fb4
--- /dev/null
+++ b/board/renesas/vk-d184280e/Kconfig
@@ -0,0 +1,33 @@
+if TARGET_VK_D184280E || TARGET_VK_D184280E_1
+
+config SYS_SOC
+        default "rmobile"
+
+config SYS_BOARD
+        default "vk-d184280e"
+
+config SYS_VENDOR
+        default "renesas"
+
+config SYS_CONFIG_NAME
+        default "vk-d184280e"
+
+config SYS_MMC_DEV
+	int
+	default 1 if ENV_IS_IN_SPI_FLASH
+	default 0
+
+config SYS_MMC_IMG_LOAD_PART
+	int
+	default 1
+
+config SYS_USB_DEV
+	int
+	default 0
+
+config SYS_USB_IMG_LOAD_PART
+	int
+	default 1
+
+endif
+
diff --git a/board/renesas/vk-d184280e/Makefile b/board/renesas/vk-d184280e/Makefile
new file mode 100644
index 0000000000..82b5cd162c
--- /dev/null
+++ b/board/renesas/vk-d184280e/Makefile
@@ -0,0 +1,13 @@
+#
+# board/renesas/salvator-x/Makefile
+#
+# Copyright (C) 2015 Renesas Electronics Corporation
+#
+# SPDX-License-Identifier: GPL-2.0+
+#
+
+ifdef CONFIG_SPL_BUILD
+obj-y	:= ../rcar-common/gen3-spl.o
+else
+obj-y	:= vk-d184280e.o ../rcar-common/common.o
+endif
diff --git a/board/renesas/vk-d184280e/vk-d184280e.c b/board/renesas/vk-d184280e/vk-d184280e.c
new file mode 100644
index 0000000000..ec74c1873e
--- /dev/null
+++ b/board/renesas/vk-d184280e/vk-d184280e.c
@@ -0,0 +1,360 @@
+#include <common.h>
+#include <cpu_func.h>
+#include <image.h>
+#include <init.h>
+#include <malloc.h>
+#include <netdev.h>
+#include <net.h>
+#include <dm.h>
+#include <dm/device.h>
+#include <dm/uclass.h>
+#include <dm/platform_data/serial_sh.h>
+#include <asm/processor.h>
+#include <asm/mach-types.h>
+#include <asm/io.h>
+#include <linux/bitops.h>
+#include <linux/errno.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/rmobile.h>
+#include <asm/arch/rcar-mstp.h>
+#include <asm/arch/sh_sdhi.h>
+#include <i2c.h>
+#include <i2c_eeprom.h>
+#include <mmc.h>
+#include <wdt.h>
+#include <rzg2l_wdt.h>
+#include <renesas/rzg_pfc.h>
+#include <linux/delay.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define ETH_CH0         (PFC_BASE + 0x300c)
+#define I2C_CH1         (PFC_BASE + 0x1870)
+#define ETH_PVDD_3300   0x00
+#define ETH_PVDD_1800   0x01
+#define ETH_PVDD_2500   0x02
+#define ETH_MII_RGMII   (PFC_BASE + 0x3018)
+
+/* CPG */
+#define CPG_BASE                    0x11010000
+#define CPG_CLKON_BASE              (CPG_BASE + 0x500)
+#define CPG_RESET_BASE              (CPG_BASE + 0x800)
+#define CPG_RESET_ETH               (CPG_RESET_BASE + 0x7C)
+#define CPG_RESET_I2C               (CPG_RESET_BASE + 0x80)
+#define CPG_PL2_SDHI_DSEL           (CPG_BASE + 0x218)
+#define CPG_CLK_STATUS              (CPG_BASE + 0x280)
+#define CPG_RST_USB                 (CPG_BASE + 0x878)
+#define CPG_CLKON_USB               (CPG_BASE + 0x578)
+
+#define USBPHY_BASE     0x11c40000
+#define USB0_BASE       0x11c50000
+#define USB1_BASE       0x11c70000
+#define USBF_BASE       0x11c60000
+#define USBPHY_RESET    (USBPHY_BASE + 0x000u)
+#define COMMCTRL        0x800
+#define HcRhDescriptorA 0x048
+#define LPSTS           0x102
+
+#define RPC_CMNCR       0x10060000
+
+#define RESTART_ON_COLD_RESET
+
+#define PFC_Pn(n)   (PFC_BASE + 0x0010ull + n)      /* Port register R/W */
+#define PFC_PMn(n)  (PFC_BASE + 0x0120ull + n * 2)  /* Port mode register R/W */
+#define PFC_PMCn(n) (PFC_BASE + 0x0210ull + n)      /* Port mode control register */
+#define PFC_PFCn(n) (PFC_BASE + 0x0440ull + n * 4)  /* Port function control register */
+#define PFC_PINn(n) (PFC_BASE + 0x0810ull + n)      /* Port input register */
+
+#define COMMA   ,
+#define P(p, b)     p COMMA b
+
+#define PORT_USB0_VBUSEN    P( 4, 0)
+#define PORT_USB0_OVRCUR    P( 5, 0)
+
+#define DO_RESET_LCD_PANEL 1
+
+#if DO_RESET_LCD_PANEL == 1
+#define PORT_PANEL_RST      P(  44, 0)
+#endif
+
+/* WDT */
+#define WDT_INDEX       0
+
+enum pfc_pin_gpio_mode {GPIO_HiZ=0, GPIO_IN=1, GPIO_OUT=2, GPIO_IO=3};
+enum pfc_pin_func_mode {FUNC0=0, FUNC1, FUNC2, FUNC3, FUNC4, FUNC5 };
+
+
+// assigned-clock-rates = <12288000>, <25000000>,
+//                           <32768>, <12288000>,
+//                        <11289600>, <24000000>;
+static const u8 ren_5p35023b_settings[] = {
+    0x00, 0x00, 0x11, 0x19, 0x00, 0x42, 0xCC, 0x2B, 0x04, 0x32, 0x00, 0x1A, 0x5F, 0x12, 0x90, 0x79,
+    0x02, 0x4C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x24, 0x19, 0xBF, 0x3F, 0x30, 0x90, 0x86,
+    0x80, 0x42, 0x45, 0xC4, 0x9C, 0x6E, 0x68, 0xD8, 0x9A, 0x7F, 0x00
+};
+
+
+/* Arguments:
+   n = port(1-48)
+   b = bit(0-4)
+   d = direction(GPIO_HiZ, GPIO_IN, GPIO_OUT, GPIO_IO)
+*/
+static void pfc_set_gpio(u8 n, u8 b, u8 d)
+{
+   *(volatile u8 *)PFC_PMCn(n) &= ~(1ul << b); /* 0b: Port Mode (GPIO) */
+   *(volatile u16 *)PFC_PMn(n) = (*(volatile u16 *)PFC_PMn(n) & ~(0b11<<(b*2))) | (((u16)d & 0b11) << (b*2)); /* set port mode */
+}
+
+/* Arguments:
+   n = port(1-11)
+   b = bit(0-15)
+   v = value (0 or 1)
+*/
+void gpio_set(u8 n, u8 b, u8 v)
+{
+   /* The pin should have been configured as GPIO_OUT using pfc_set_gpio */
+    if ( v ) 
+        *(volatile u8 *)PFC_Pn(n) |= 1UL << b;       // Set pin 
+    else
+        *(volatile u8 *)PFC_Pn(n) &= ~(1UL << b);    // Clear pin
+}
+
+/* Arguments:
+   n = port(1-40)
+   b = bit(0-4)
+   return = current pin level (0 or 1);
+*/
+static u8 gpio_read(u8 n, u8 b)
+{
+   /* The pin should have been configured as GPIO_IN using pfc_set_gpio */
+   //printf("PINn(%d) %04X\n",n,*(volatile u8 *)PFC_PINn(n));
+   return ( *(volatile u8 *)PFC_PINn(n) >> b ) & 0x01;
+}
+
+
+/* Arguments:
+    n = port number (P1-P40)
+    b = bit number (0-4)
+    func = Alternative function ('FUNC0'-'FUNC5')
+*/
+void pfc_set_pin_function(u16 n, u16 b, u8 func)
+{
+   *(volatile u8 *)PFC_PMCn(n) |= (1ul << b); /* 1b: Peripheral Function Mode (Peripheral Function) */
+
+   *(volatile u32 *)PFC_PFCn(n) = (*(volatile u32 *)PFC_PFCn(n) & ~(0b111<<(b*4))) | (((u16)func & 0b111) << (b*4)); /* set port mode */
+}
+
+
+void s_init(void)
+{
+    /* can go in board_eht_init() once enabled */
+    *(volatile u32 *)(ETH_CH0) = (*(volatile u32 *)(ETH_CH0) & 0xFFFFFFFC) | ETH_PVDD_3300;
+    /* Enable RGMII for ETH0 */
+    *(volatile u32 *)(ETH_MII_RGMII) = (*(volatile u32 *)(ETH_MII_RGMII) & 0xFFFFFFFC);
+    /* ETH CLK */
+    *(volatile u32 *)(CPG_RESET_ETH) = 0x30001;
+    /* I2C CLK */
+    *(volatile u32 *)(CPG_RESET_I2C) = 0xF000F;
+    /* I2C pin non GPIO enable */
+    *(volatile u32 *)(I2C_CH1) = 0x01010101;    
+    /* SD CLK */
+    *(volatile u32 *)(CPG_PL2_SDHI_DSEL) = 0x00110011;
+    while (*(volatile u32 *)(CPG_CLK_STATUS) != 0)
+            ;
+
+    *(volatile u32 *)(RPC_CMNCR) = 0x01FFF300;
+}
+
+#define WARM_RESET_PATTERN "This is an warm reset!"
+#define RST_PATTERN_LEN (size_t)(sizeof(WARM_RESET_PATTERN)-1)
+#define PATTERN_LOC 0x0002e000
+
+#define I2C_PMIC_ADDR               0x12
+#define I2C_PMIC_ADDR_LEN           1
+#define I2C_PMIC_REG_SOFTRST        0x6D
+#define I2C_PMIC_SOFTRST_COLDRST    (1<<0)
+#define I2C_PMIC_SOFTRST_WARMRST    (1<<1)
+
+void restart_on_cold_reset(void)
+{
+    if ( strncmp((const char *)PATTERN_LOC, WARM_RESET_PATTERN, RST_PATTERN_LEN) != 0 ) 
+    { 
+        strncpy((char *)PATTERN_LOC, WARM_RESET_PATTERN, RST_PATTERN_LEN);
+
+        printf("%s: Cold RESET detected!\n", __func__);
+
+        mdelay(100);
+       
+#if 1 
+        struct udevice *wdt_dev;
+        if (uclass_get_device(UCLASS_WDT, WDT_INDEX, &wdt_dev) < 0) {
+            printf("failed to get wdt device. cannot reset\n");
+            return;
+        }
+        if (wdt_expire_now(wdt_dev, 1) < 0) {
+            printf("failed to expire_now wdt\n");
+        }
+#else 
+        struct udevice *iic_dev;
+
+        if (i2c_get_chip_for_busnum(CONFIG_I2C_DEFAULT_BUS_NUMBER, I2C_PMIC_ADDR, I2C_PMIC_ADDR_LEN, &iic_dev) != 0 ) 
+        {
+            log_err("failed to get PMIC device. cannot reset\n");
+            return;
+        }
+
+        if ( dm_i2c_reg_write(iic_dev, I2C_PMIC_REG_SOFTRST, (unsigned char)I2C_PMIC_SOFTRST_WARMRST) < 0)
+        {
+            log_err("failed to force PMIC software reset\n");
+        }
+        else
+        {
+            log_debug("Waiting for RESET!\n");
+            hang();
+        }
+#endif
+    }
+    else
+    {
+        printf("%s: Warm RESET detected!\n", __func__);
+    }
+}
+
+// workaround for EE00700 artifacts
+static void board_panel_init(void)
+{
+#if DO_RESET_LCD_PANEL == 1
+	pfc_set_gpio(PORT_PANEL_RST, GPIO_OUT);
+
+	gpio_set(PORT_PANEL_RST, 0);
+	mdelay(10);
+	gpio_set(PORT_PANEL_RST, 1);
+#endif
+}
+
+
+int board_early_init_f(void)
+{
+
+	board_panel_init();
+
+    return 0;
+}
+
+
+static void board_usb_init(void)
+{
+    /*Enable USB*/
+    (*(volatile u32 *)CPG_RST_USB) = 0x000f000f;
+    (*(volatile u32 *)CPG_CLKON_USB) = 0x000f000f;
+
+    /* Setup  */
+    /* Disable GPIO Write Protect */
+    (*(volatile u32 *)PFC_PWPR) &= ~(0x1u << 7);    /* PWPR.BOWI = 0 */
+    (*(volatile u32 *)PFC_PWPR) |= (0x1u << 6);     /* PWPR.PFCWE = 1 */
+
+    /* set P4_0 as Func.1 for VBUSEN */
+    pfc_set_pin_function(PORT_USB0_VBUSEN, FUNC1);
+
+    /* set P5_0 as Func.1 for OVERCUR */
+    pfc_set_pin_function(PORT_USB0_OVRCUR, FUNC1);
+
+    /* Enable write protect */
+    (*(volatile u32 *)PFC_PWPR) &= ~(0x1u << 6);    /* PWPR.PFCWE = 0 */
+    (*(volatile u32 *)PFC_PWPR) |= (0x1u << 7);     /* PWPR.BOWI = 1 */
+
+    /*Enable USB port*/
+    (*(volatile u32 *)USBPHY_RESET) = 0x00001000u;
+    /*USB0 is HOST*/
+    (*(volatile u32 *)(USB0_BASE + COMMCTRL)) = 0;
+    /* Set USBPHY normal operation (Function only) */
+    (*(volatile u16 *)(USBF_BASE + LPSTS)) |= (0x1u << 14);     /* USBPHY.SUSPM = 1 (func only) */
+    /* Overcurrent is not supported */
+    (*(volatile u32 *)(USB0_BASE + HcRhDescriptorA)) |= (0x1u << 12);       /* NOCP = 1 */
+}
+
+
+int board_init(void)
+{
+    /* adress of boot parameters */
+    gd->bd->bi_boot_params = CONFIG_SYS_TEXT_BASE + 0x50000;
+
+    board_usb_init();
+
+    return 0;
+}
+
+
+int board_late_init(void)
+{
+    int off, retval = 0;
+    struct udevice *iic_dev;
+
+    /* Set clocks */ 
+    retval = i2c_get_chip_for_busnum(CONFIG_I2C_DEFAULT_BUS_NUMBER, I2C_VERSACLOCK_ADDR, I2C_VERSACLOCK_ADDR_LEN, &iic_dev);
+
+    if (retval == 0)
+    {
+        retval = dm_i2c_write(iic_dev, 0u, ren_5p35023b_settings, sizeof(ren_5p35023b_settings));
+    }
+    else
+    {
+        printf("%s: Couldn't setup system clocks!\n", __func__);
+    }
+
+#ifdef CONFIG_RENESAS_RZG2LWDT
+    rzg2l_reinitr_wdt();
+#endif // CONFIG_RENESAS_RZG2LWDT
+
+#ifdef RESTART_ON_COLD_RESET
+    restart_on_cold_reset();
+#endif
+
+    /* Read Mac Address and set*/
+    //retval = uclass_get_device_by_name(UCLASS_I2C_EEPROM, "eeprom@50", &iic_dev);
+    retval = i2c_get_chip_for_busnum(CONFIG_SYS_I2C_EEPROM_BUS, I2C_EEPROM_MAC_ADDR, CONFIG_SYS_I2C_EEPROM_ADDR_LEN, &iic_dev);
+    if (retval == 0)
+    {
+        const int ETH_ADDR_LEN = 6;
+        uint8_t ethaddr[ETH_ADDR_LEN];
+
+        retval = dm_i2c_read(iic_dev, ETHER_EEPROM_ADDR, ethaddr, ETH_ADDR_LEN);
+        if (retval == 0 ) 
+        {
+            if (is_valid_ethaddr(ethaddr))
+            {
+                eth_env_set_enetaddr("ethaddr", ethaddr);
+            }
+            else
+            {
+                printf("Invalid ethaddr format in eeprom!\n");
+            }
+        }
+        else
+        {
+            printf("Error reading configuration EEPROM!\n");
+        }
+    }
+    else
+    {
+        printf("%s: Cannot find EEPROM!\n", __func__);
+    }
+  
+    return 0;
+}
+
+void reset_cpu(void)
+{
+#ifdef CONFIG_RENESAS_RZG2LWDT
+    struct udevice *wdt_dev;
+    if (uclass_get_device(UCLASS_WDT, WDT_INDEX, &wdt_dev) < 0) {
+        printf("failed to get wdt device. cannot reset\n");
+        return;
+    }
+    if (wdt_expire_now(wdt_dev, 0) < 0) {
+        printf("failed to expire_now wdt\n");
+    }
+#endif // CONFIG_RENESAS_RZG2LWDT
+}
diff --git a/board/renesas/vkcmg2lc/Kconfig b/board/renesas/vkcmg2lc/Kconfig
new file mode 100644
index 0000000000..7800825980
--- /dev/null
+++ b/board/renesas/vkcmg2lc/Kconfig
@@ -0,0 +1,33 @@
+if TARGET_VKCMG2LC || TARGET_VKCMG2LC_1
+
+config SYS_SOC
+        default "rmobile"
+
+config SYS_BOARD
+        default "vkcmg2lc"
+
+config SYS_VENDOR
+        default "renesas"
+
+config SYS_CONFIG_NAME
+        default "vkcmg2lc"
+
+config SYS_MMC_DEV
+	int
+	default 1 if ENV_IS_IN_SPI_FLASH
+	default 0
+
+config SYS_MMC_IMG_LOAD_PART
+	int
+	default 1
+
+config SYS_USB_DEV
+	int
+	default 0
+
+config SYS_USB_IMG_LOAD_PART
+	int
+	default 1
+
+endif
+
diff --git a/board/renesas/vkcmg2lc/Makefile b/board/renesas/vkcmg2lc/Makefile
new file mode 100644
index 0000000000..b731d5c4d0
--- /dev/null
+++ b/board/renesas/vkcmg2lc/Makefile
@@ -0,0 +1,13 @@
+#
+# board/renesas/salvator-x/Makefile
+#
+# Copyright (C) 2015 Renesas Electronics Corporation
+#
+# SPDX-License-Identifier: GPL-2.0+
+#
+
+ifdef CONFIG_SPL_BUILD
+obj-y	:= ../rcar-common/gen3-spl.o
+else
+obj-y	:= vkcmg2lc.o ../rcar-common/common.o
+endif
diff --git a/board/renesas/vkcmg2lc/vkcmg2lc.c b/board/renesas/vkcmg2lc/vkcmg2lc.c
new file mode 100644
index 0000000000..8eb5d0bd01
--- /dev/null
+++ b/board/renesas/vkcmg2lc/vkcmg2lc.c
@@ -0,0 +1,330 @@
+#include <common.h>
+#include <cpu_func.h>
+#include <image.h>
+#include <init.h>
+#include <malloc.h>
+#include <netdev.h>
+#include <net.h>
+#include <dm.h>
+#include <dm/device.h>
+#include <dm/uclass.h>
+#include <dm/platform_data/serial_sh.h>
+#include <asm/processor.h>
+#include <asm/mach-types.h>
+#include <asm/io.h>
+#include <linux/bitops.h>
+#include <linux/errno.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/rmobile.h>
+#include <asm/arch/rcar-mstp.h>
+#include <asm/arch/sh_sdhi.h>
+#include <i2c.h>
+#include <i2c_eeprom.h>
+#include <mmc.h>
+#include <wdt.h>
+#include <rzg2l_wdt.h>
+#include <renesas/rzg_pfc.h>
+#include <linux/delay.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define ETH_CH0         (PFC_BASE + 0x300c)
+#define I2C_CH1         (PFC_BASE + 0x1870)
+#define ETH_PVDD_3300   0x00
+#define ETH_PVDD_1800   0x01
+#define ETH_PVDD_2500   0x02
+#define ETH_MII_RGMII   (PFC_BASE + 0x3018)
+
+/* CPG */
+#define CPG_BASE                    0x11010000
+#define CPG_CLKON_BASE              (CPG_BASE + 0x500)
+#define CPG_RESET_BASE              (CPG_BASE + 0x800)
+#define CPG_RESET_ETH               (CPG_RESET_BASE + 0x7C)
+#define CPG_RESET_I2C               (CPG_RESET_BASE + 0x80)
+#define CPG_PL2_SDHI_DSEL           (CPG_BASE + 0x218)
+#define CPG_CLK_STATUS              (CPG_BASE + 0x280)
+#define CPG_RST_USB                 (CPG_BASE + 0x878)
+#define CPG_CLKON_USB               (CPG_BASE + 0x578)
+
+#define USBPHY_BASE     0x11c40000
+#define USB0_BASE       0x11c50000
+#define USB1_BASE       0x11c70000
+#define USBF_BASE       0x11c60000
+#define USBPHY_RESET    (USBPHY_BASE + 0x000u)
+#define COMMCTRL        0x800
+#define HcRhDescriptorA 0x048
+#define LPSTS           0x102
+
+#define RPC_CMNCR       0x10060000
+
+#define PFC_Pn(n)   (PFC_BASE + 0x0010ull + n)      /* Port register R/W */
+#define PFC_PMn(n)  (PFC_BASE + 0x0120ull + n * 2)  /* Port mode register R/W */
+#define PFC_PMCn(n) (PFC_BASE + 0x0210ull + n)      /* Port mode control register */
+#define PFC_PFCn(n) (PFC_BASE + 0x0440ull + n * 4)  /* Port function control register */
+#define PFC_PINn(n) (PFC_BASE + 0x0810ull + n)      /* Port input register */
+
+#define COMMA   ,
+#define P(p, b)     p COMMA b
+
+#define PORT_LED_R          P( 39, 1)
+
+#define PORT_USB0_VBUSEN    P( 4, 0)
+#define PORT_USB0_OVRCUR    P( 5, 0)
+#define PORT_USB1_VBUSEN    P( 42, 0)
+#define PORT_USB1_OVRCUR    P( 42, 1)
+
+#define DO_RESET_LCD_PANEL 1
+
+#if DO_RESET_LCD_PANEL == 1
+#define PORT_PANEL_RST      P(  5, 2)
+#endif
+
+/* WDT */
+#define WDT_INDEX       0
+
+enum pfc_pin_gpio_mode {GPIO_HiZ=0, GPIO_IN=1, GPIO_OUT=2, GPIO_IO=3};
+enum pfc_pin_func_mode {FUNC0=0, FUNC1, FUNC2, FUNC3, FUNC4, FUNC5 };
+
+
+// assigned-clock-rates = <12288000>, <25000000>,
+//                           <32768>, <12288000>,
+//                        <11289600>, <24000000>;
+static const u8 ren_5p35023b_settings[] = {
+    0x00, 0x00, 0x11, 0x19, 0x00, 0x42, 0xCC, 0x2B, 0x04, 0x32, 0x00, 0x1A, 0x5F, 0x12, 0x90, 0x79,
+    0x02, 0x4C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x24, 0x19, 0xBF, 0x3F, 0x30, 0x90, 0x86,
+    0x80, 0x42, 0x45, 0xC4, 0x9C, 0x6E, 0x68, 0xD8, 0x9A, 0x7F, 0x00
+};
+
+
+
+/* Arguments:
+   n = port(1-48)
+   b = bit(0-4)
+   d = direction(GPIO_HiZ, GPIO_IN, GPIO_OUT, GPIO_IO)
+*/
+static void pfc_set_gpio(u8 n, u8 b, u8 d)
+{
+   *(volatile u8 *)PFC_PMCn(n) &= ~(1ul << b); /* 0b: Port Mode (GPIO) */
+   *(volatile u16 *)PFC_PMn(n) = (*(volatile u16 *)PFC_PMn(n) & ~(0b11<<(b*2))) | (((u16)d & 0b11) << (b*2)); /* set port mode */
+}
+
+/* Arguments:
+   n = port(1-11)
+   b = bit(0-15)
+   v = value (0 or 1)
+*/
+void gpio_set(u8 n, u8 b, u8 v)
+{
+   /* The pin should have been configured as GPIO_OUT using pfc_set_gpio */
+    if ( v ) 
+        *(volatile u8 *)PFC_Pn(n) |= 1UL << b;       // Set pin 
+    else
+        *(volatile u8 *)PFC_Pn(n) &= ~(1UL << b);    // Clear pin
+}
+
+/* Arguments:
+   n = port(1-40)
+   b = bit(0-4)
+   return = current pin level (0 or 1);
+*/
+static u8 gpio_read(u8 n, u8 b)
+{
+   /* The pin should have been configured as GPIO_IN using pfc_set_gpio */
+   //printf("PINn(%d) %04X\n",n,*(volatile u8 *)PFC_PINn(n));
+   return ( *(volatile u8 *)PFC_PINn(n) >> b ) & 0x01;
+}
+
+
+/* Arguments:
+    n = port number (P1-P40)
+    b = bit number (0-4)
+    func = Alternative function ('FUNC0'-'FUNC5')
+*/
+void pfc_set_pin_function(u16 n, u16 b, u8 func)
+{
+   *(volatile u8 *)PFC_PMCn(n) |= (1ul << b); /* 1b: Peripheral Function Mode (Peripheral Function) */
+
+   *(volatile u32 *)PFC_PFCn(n) = (*(volatile u32 *)PFC_PFCn(n) & ~(0b111<<(b*4))) | (((u16)func & 0b111) << (b*4)); /* set port mode */
+}
+
+
+void s_init(void)
+{
+    /* can go in board_eht_init() once enabled */
+    *(volatile u32 *)(ETH_CH0) = (*(volatile u32 *)(ETH_CH0) & 0xFFFFFFFC) | ETH_PVDD_3300;
+    /* Enable RGMII for ETH0 */
+    *(volatile u32 *)(ETH_MII_RGMII) = (*(volatile u32 *)(ETH_MII_RGMII) & 0xFFFFFFFC);
+    /* ETH CLK */
+    *(volatile u32 *)(CPG_RESET_ETH) = 0x30001;
+    /* I2C CLK */
+    *(volatile u32 *)(CPG_RESET_I2C) = 0xF000F;
+    /* I2C pin non GPIO enable */
+    *(volatile u32 *)(I2C_CH1) = 0x01010101;    
+    /* SD CLK */
+    *(volatile u32 *)(CPG_PL2_SDHI_DSEL) = 0x00110011;
+    while (*(volatile u32 *)(CPG_CLK_STATUS) != 0)
+            ;
+
+    *(volatile u32 *)(RPC_CMNCR) = 0x01FFF300;
+}
+
+
+static int board_led_init(void)
+{
+    /* RED LED: P39_1 = 1; */
+    pfc_set_gpio(PORT_LED_R, GPIO_OUT); gpio_set(PORT_LED_R, 0);
+
+    return 0;
+}
+
+
+// workaround for EE00700 artifacts
+static void board_panel_init(void)
+{
+#if DO_RESET_LCD_PANEL == 1
+	pfc_set_gpio(PORT_PANEL_RST, GPIO_OUT);
+
+	gpio_set(PORT_PANEL_RST, 0);
+	mdelay(10);
+	gpio_set(PORT_PANEL_RST, 1);
+#endif
+}
+
+
+int board_early_init_f(void)
+{
+    /* LED's */
+    board_led_init();
+
+    //gpio_set(PORT_LED_R, 1);
+
+	board_panel_init();
+
+    return 0;
+}
+
+
+static void board_usb_init(void)
+{
+    /*Enable USB*/
+    (*(volatile u32 *)CPG_RST_USB) = 0x000f000f;
+    (*(volatile u32 *)CPG_CLKON_USB) = 0x000f000f;
+
+    /* Setup  */
+    /* Disable GPIO Write Protect */
+    (*(volatile u32 *)PFC_PWPR) &= ~(0x1u << 7);    /* PWPR.BOWI = 0 */
+    (*(volatile u32 *)PFC_PWPR) |= (0x1u << 6);     /* PWPR.PFCWE = 1 */
+
+    /* set P4_0 as Func.1 for VBUSEN */
+    pfc_set_pin_function(PORT_USB0_VBUSEN, FUNC1);
+
+    /* set P5_0 as Func.1 for OVERCUR */
+    pfc_set_pin_function(PORT_USB0_OVRCUR, FUNC1);
+
+    /* set P42_0 as Func.1 for VBUSEN */
+    pfc_set_pin_function(PORT_USB1_VBUSEN, FUNC1);
+
+    /* set P42_1 as Func.1 for OVERCUR */
+    pfc_set_pin_function(PORT_USB1_OVRCUR, FUNC1);
+
+    /* Enable write protect */
+    (*(volatile u32 *)PFC_PWPR) &= ~(0x1u << 6);    /* PWPR.PFCWE = 0 */
+    (*(volatile u32 *)PFC_PWPR) |= (0x1u << 7);     /* PWPR.BOWI = 1 */
+
+    /*Enable 2 USB ports*/
+    (*(volatile u32 *)USBPHY_RESET) = 0x00001000u;
+    /*USB0 is HOST*/
+    (*(volatile u32 *)(USB0_BASE + COMMCTRL)) = 0;
+    /*USB1 is HOST*/
+    (*(volatile u32 *)(USB1_BASE + COMMCTRL)) = 0;
+    /* Set USBPHY normal operation (Function only) */
+    (*(volatile u16 *)(USBF_BASE + LPSTS)) |= (0x1u << 14);     /* USBPHY.SUSPM = 1 (func only) */
+    /* Overcurrent is not supported */
+    (*(volatile u32 *)(USB0_BASE + HcRhDescriptorA)) |= (0x1u << 12);       /* NOCP = 1 */
+    (*(volatile u32 *)(USB1_BASE + HcRhDescriptorA)) |= (0x1u << 12);       /* NOCP = 1 */
+}
+
+
+int board_init(void)
+{
+    /* adress of boot parameters */
+    gd->bd->bi_boot_params = CONFIG_SYS_TEXT_BASE + 0x50000;
+
+    board_usb_init();
+
+    return 0;
+}
+
+
+int board_late_init(void)
+{
+    int off, retval = 0;
+    struct udevice *iic_dev;
+
+    /* Set clocks */ 
+    retval = i2c_get_chip_for_busnum(CONFIG_I2C_DEFAULT_BUS_NUMBER, I2C_VERSACLOCK_ADDR, I2C_VERSACLOCK_ADDR_LEN, &iic_dev);
+
+    if (retval == 0)
+    {
+        retval = dm_i2c_write(iic_dev, 0u, ren_5p35023b_settings, sizeof(ren_5p35023b_settings));
+    }
+    else
+    {
+        printf("%s: Couldn't setup system clocks!\n", __func__);
+    }
+
+#ifdef CONFIG_RENESAS_RZG2LWDT
+    rzg2l_reinitr_wdt();
+#endif // CONFIG_RENESAS_RZG2LWDT
+
+    /* Read Mac Address and set*/
+    //retval = uclass_get_device_by_name(UCLASS_I2C_EEPROM, "eeprom@50", &iic_dev);
+    retval = i2c_get_chip_for_busnum(CONFIG_SYS_I2C_EEPROM_BUS, CONFIG_SYS_I2C_EEPROM_ADDR, CONFIG_SYS_I2C_EEPROM_ADDR_LEN, &iic_dev);
+    if (retval == 0)
+    {
+        const int ETH_ADDR_LEN = 6;
+        uint8_t ethaddr[ETH_ADDR_LEN];
+
+        retval = dm_i2c_read(iic_dev, ETHER_EEPROM_ADDR, ethaddr, ETH_ADDR_LEN);
+        if (retval == 0 ) 
+        {
+            if (is_valid_ethaddr(ethaddr))
+            {
+                eth_env_set_enetaddr("ethaddr", ethaddr);
+            }
+            else
+            {
+                printf("Invalid ethaddr format in eeprom!\n");
+            }
+        }
+        else
+        {
+            printf("Error reading configuration EEPROM!\n");
+        }
+    }
+    else
+    {
+        printf("%s: Cannot find EEPROM!\n", __func__);
+    }
+  
+    if (retval == 0) {
+        gpio_set(PORT_LED_R, 1);
+    }
+    return 0;
+}
+
+void reset_cpu(void)
+{
+#ifdef CONFIG_RENESAS_RZG2LWDT
+    struct udevice *wdt_dev;
+    if (uclass_get_device(UCLASS_WDT, WDT_INDEX, &wdt_dev) < 0) {
+        printf("failed to get wdt device. cannot reset\n");
+        return;
+    }
+    if (wdt_expire_now(wdt_dev, 0) < 0) {
+        printf("failed to expire_now wdt\n");
+    }
+#endif // CONFIG_RENESAS_RZG2LWDT
+}
diff --git a/board/renesas/vkcmv2l/Kconfig b/board/renesas/vkcmv2l/Kconfig
new file mode 100644
index 0000000000..13ac81eb25
--- /dev/null
+++ b/board/renesas/vkcmv2l/Kconfig
@@ -0,0 +1,36 @@
+if TARGET_VKCMV2L
+
+config SYS_SOC
+        default "rmobile"
+
+config SYS_BOARD
+        default "vkcmv2l"
+
+config SYS_VENDOR
+        default "renesas"
+
+config SYS_CONFIG_NAME
+        default "vkcmv2l"
+
+config SYS_MMC_DEV
+	int
+	default 0
+
+config SYS_MMC_IMG_LOAD_PART
+	int
+	default 1
+
+config OPENCVA
+	int
+	default 1
+
+config SYS_USB_DEV
+	int
+	default 0
+
+config SYS_USB_IMG_LOAD_PART
+	int
+	default 1
+
+endif
+
diff --git a/board/renesas/vkcmv2l/Makefile b/board/renesas/vkcmv2l/Makefile
new file mode 100644
index 0000000000..baf0c50990
--- /dev/null
+++ b/board/renesas/vkcmv2l/Makefile
@@ -0,0 +1,13 @@
+#
+# board/renesas/salvator-x/Makefile
+#
+# Copyright (C) 2015 Renesas Electronics Corporation
+#
+# SPDX-License-Identifier: GPL-2.0+
+#
+
+ifdef CONFIG_SPL_BUILD
+obj-y	:= ../rcar-common/gen3-spl.o
+else
+obj-y	:= vkcmv2l.o ../rcar-common/common.o
+endif
diff --git a/board/renesas/vkcmv2l/vkcmv2l.c b/board/renesas/vkcmv2l/vkcmv2l.c
new file mode 100644
index 0000000000..0aa0eba722
--- /dev/null
+++ b/board/renesas/vkcmv2l/vkcmv2l.c
@@ -0,0 +1,404 @@
+#include <common.h>
+#include <cpu_func.h>
+#include <image.h>
+#include <init.h>
+#include <hang.h>
+#include <malloc.h>
+#include <netdev.h>
+#include <net.h>
+#include <dm.h>
+#include <dm/device.h>
+#include <dm/uclass.h>
+#include <dm/platform_data/serial_sh.h>
+#include <asm/processor.h>
+#include <asm/mach-types.h>
+#include <asm/io.h>
+#include <linux/bitops.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/rmobile.h>
+#include <asm/arch/rcar-mstp.h>
+#include <asm/arch/sh_sdhi.h>
+#include <i2c.h>
+#include <i2c_eeprom.h>
+#include <mmc.h>
+#include <wdt.h>
+#include <rzg2l_wdt.h>
+#include <stdio.h>
+#include <renesas/rzg_pfc.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define ETH_CH0     (PFC_BASE + 0x300c)
+#define ETH_CH1     (PFC_BASE + 0x3010)
+#define I2C_CH1     (PFC_BASE + 0x1870)
+#define ETH_PVDD_3300   0x00
+#define ETH_PVDD_1800   0x01
+#define ETH_PVDD_2500   0x02
+#define ETH_MII_RGMII   (PFC_BASE + 0x3018)
+
+/* CPG */
+#define CPG_BASE                    0x11010000
+#define CPG_CLKON_BASE              (CPG_BASE + 0x500)
+#define CPG_RESET_BASE              (CPG_BASE + 0x800)
+#define CPG_RESET_ETH               (CPG_RESET_BASE + 0x7C)
+#define CPG_RESET_I2C               (CPG_RESET_BASE + 0x80)
+#define CPG_PL2_SDHI_DSEL           (CPG_BASE + 0x218)
+#define CPG_CLK_STATUS              (CPG_BASE + 0x280)
+#define CPG_RST_USB                 (CPG_BASE + 0x878)
+#define CPG_CLKON_USB               (CPG_BASE + 0x578)
+
+#define USBPHY_BASE     0x11c40000
+#define USB0_BASE       0x11c50000
+#define USB1_BASE       0x11c70000
+#define USBF_BASE       0x11c60000
+#define USBPHY_RESET    (USBPHY_BASE + 0x000u)
+#define COMMCTRL        0x800
+#define HcRhDescriptorA 0x048
+#define LPSTS           0x102
+
+#define RPC_CMNCR       0x10060000
+
+#define RESTART_ON_COLD_RESET
+
+#define PFC_Pn(n)   (PFC_BASE + 0x0010ull + (n))      /* Port register R/W */
+#define PFC_PMn(n)  (PFC_BASE + 0x0120ull + (n) * 2)  /* Port mode register R/W */
+#define PFC_PMCn(n) (PFC_BASE + 0x0210ull + (n))      /* Port mode control register */
+#define PFC_PFCn(n) (PFC_BASE + 0x0440ull + (n) * 4)  /* Port function control register */
+#define PFC_PINn(n) (PFC_BASE + 0x0810ull + (n))      /* Port input register */
+
+#define COMMA   ,
+#define P(p, b)     p COMMA b
+
+#define PORT_LED_R          P( 6, 1)
+#define PORT_LED_G          P(17, 0)
+#define PORT_LED_B          P(15, 1)
+#define PORT_LED_Y          P(16, 0)
+
+#define PORT_ET0_RESETn     P(22, 1)     
+#define PORT_ET1_RESETn     P(33, 0)
+
+#define PORT_USB0_VBUSEN    P( 4, 0)
+#define PORT_USB0_OVRCUR    P( 5, 0)
+#define PORT_USB1_VBUSEN    P( 8, 0)
+#define PORT_USB1_OVRCUR    P( 8, 1)
+
+#define PORT_SD_PWREN       P(39, 2)
+
+
+/* WDT */
+#define WDT_INDEX		0
+
+enum pfc_pin_gpio_mode {GPIO_HiZ=0, GPIO_IN=1, GPIO_OUT=2, GPIO_IO=3};
+enum pfc_pin_func_mode {FUNC0=0, FUNC1, FUNC2, FUNC3, FUNC4, FUNC5 };
+
+
+// assigned-clock-rates = <12288000>, <25000000>,
+//                           <32768>, <12288000>,
+//                        <11289600>, <24000000>;
+static const u8 ren_5p35023b_settings[] = {
+    0x00, 0x00, 0x11, 0x19, 0x00, 0x42, 0xCC, 0x2B, 0x04, 0x32, 0x00, 0x1A, 0x5F, 0x12, 0x90, 0x79,
+    0x02, 0x4C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x24, 0x19, 0xBF, 0x3F, 0x30, 0x90, 0x86,
+    0x80, 0x42, 0x45, 0xC4, 0x9C, 0x6E, 0x68, 0xD8, 0x9A, 0x7F, 0x00
+};
+
+
+/* Arguments:
+   n = port(1-48)
+   b = bit(0-4)
+   d = direction(GPIO_HiZ, GPIO_IN, GPIO_OUT, GPIO_IO)
+*/
+static void pfc_set_gpio(u8 n, u8 b, u8 d)
+{
+   *(volatile u8 *)PFC_PMCn(n) &= ~(1ul << b); /* 0b: Port Mode (GPIO) */
+   *(volatile u16 *)PFC_PMn(n) = (*(volatile u16 *)PFC_PMn(n) & ~(0b11<<(b*2))) | (((u16)d & 0b11) << (b*2)); /* set port mode */
+}
+
+/* Arguments:
+   n = port(1-11)
+   b = bit(0-15)
+   v = value (0 or 1)
+*/
+void gpio_set(u8 n, u8 b, u8 v)
+{
+   /* The pin should have been configured as GPIO_OUT using pfc_set_gpio */
+    if ( v ) 
+        *(volatile u8 *)PFC_Pn(n) |= 1UL << b;       // Set pin 
+    else
+        *(volatile u8 *)PFC_Pn(n) &= ~(1UL << b);    // Clear pin
+}
+
+/* Arguments:
+   n = port(1-40)
+   b = bit(0-4)
+   return = current pin level (0 or 1);
+*/
+u8 gpio_read(u8 n, u8 b) __attribute__((weak));
+
+u8 gpio_read(u8 n, u8 b) 
+{
+   /* The pin should have been configured as GPIO_IN using pfc_set_gpio */
+   //printf("PINn(%d) %04X\n",n,*(volatile u8 *)PFC_PINn(n));
+   return ( *(volatile u8 *)PFC_PINn(n) >> b ) & 0x01;
+}
+
+
+/* Arguments:
+    n = port number (P1-P40)
+    b = bit number (0-4)
+    func = Alternative function ('FUNC0'-'FUNC5')
+*/
+void pfc_set_pin_function(u16 n, u16 b, u8 func)
+{
+   *(volatile u8 *)PFC_PMCn(n) |= (1ul << b); /* 1b: Peripheral Function Mode (Peripheral Function) */
+
+   *(volatile u32 *)PFC_PFCn(n) = (*(volatile u32 *)PFC_PFCn(n) & ~(0b111<<(b*4))) | (((u16)func & 0b111) << (b*4)); /* set port mode */
+}
+
+
+void s_init(void)
+{
+    /* SD power control: = 1; */
+    //pfc_set_gpio(PORT_SD_PWREN, GPIO_OUT); gpio_set(PORT_SD_PWREN, 1);
+
+    /* can go in board_eht_init() once enabled */
+    *(volatile u32 *)(ETH_CH0) = (*(volatile u32 *)(ETH_CH0) & 0xFFFFFFFC) | ETH_PVDD_1800;
+    *(volatile u32 *)(ETH_CH1) = (*(volatile u32 *)(ETH_CH1) & 0xFFFFFFFC) | ETH_PVDD_1800;
+    /* Enable RGMII for both ETH{0,1} */
+    *(volatile u32 *)(ETH_MII_RGMII) = (*(volatile u32 *)(ETH_MII_RGMII) & 0xFFFFFFFC);
+    /* ETH CLK */
+    *(volatile u32 *)(CPG_RESET_ETH) = 0x30003;
+    /* I2C CLK */
+    *(volatile u32 *)(CPG_RESET_I2C) = 0xF000F;
+    /* I2C pin non GPIO enable */
+    *(volatile u32 *)(I2C_CH1) = 0x01010101;
+    /* SD CLK */
+    *(volatile u32 *)(CPG_PL2_SDHI_DSEL) = 0x00110011;
+    while (*(volatile u32 *)(CPG_CLK_STATUS) != 0)
+        ;
+}
+
+#define WARM_RESET_PATTERN "This is an warm reset!"
+#define RST_PATTERN_LEN (size_t)(sizeof(WARM_RESET_PATTERN)-1)
+#define PATTERN_LOC 0x0002e000
+
+#define I2C_PMIC_ADDR               0x12
+#define I2C_PMIC_ADDR_LEN           1
+#define I2C_PMIC_REG_SOFTRST        0x6D
+#define I2C_PMIC_SOFTRST_COLDRST    (1<<0)
+#define I2C_PMIC_SOFTRST_WARMRST    (1<<1)
+
+void restart_on_cold_reset(void)
+{
+    if ( strncmp((const char *)PATTERN_LOC, WARM_RESET_PATTERN, RST_PATTERN_LEN) != 0 ) 
+    { 
+        strncpy((char *)PATTERN_LOC, WARM_RESET_PATTERN, RST_PATTERN_LEN);
+
+        gpio_set(PORT_LED_Y, 1);
+
+        printf("%s: Cold RESET detected!\n", __func__);
+
+        mdelay(100);
+       
+#if 1 
+        struct udevice *wdt_dev;
+        if (uclass_get_device(UCLASS_WDT, WDT_INDEX, &wdt_dev) < 0) {
+            printf("failed to get wdt device. cannot reset\n");
+            return;
+        }
+        if (wdt_expire_now(wdt_dev, 1) < 0) {
+            printf("failed to expire_now wdt\n");
+        }
+#else 
+        struct udevice *iic_dev;
+
+        if (i2c_get_chip_for_busnum(CONFIG_I2C_DEFAULT_BUS_NUMBER, I2C_PMIC_ADDR, I2C_PMIC_ADDR_LEN, &iic_dev) != 0 ) 
+        {
+            log_err("failed to get PMIC device. cannot reset\n");
+            return;
+        }
+
+        if ( dm_i2c_reg_write(iic_dev, I2C_PMIC_REG_SOFTRST, (unsigned char)I2C_PMIC_SOFTRST_WARMRST) < 0)
+        {
+            log_err("failed to force PMIC software reset\n");
+        }
+        else
+        {
+            log_debug("Waiting for RESET!\n");
+            hang();
+        }
+#endif
+    }
+    else
+    {
+        printf("%s: Warm RESET detected!\n", __func__);
+    }
+}
+
+int board_led_init(void)
+{
+    /* RED LED: = 0; */
+    pfc_set_gpio(PORT_LED_R, GPIO_OUT); gpio_set(PORT_LED_R, 0);
+
+    /* GREEN LED: = 0; */
+    pfc_set_gpio(PORT_LED_G, GPIO_OUT); gpio_set(PORT_LED_G, 0);
+
+    /* BLUE LED: = 0; */
+    pfc_set_gpio(PORT_LED_B, GPIO_OUT); gpio_set(PORT_LED_B, 0);
+
+    /* YELLOW LED: = 0; */
+    pfc_set_gpio(PORT_LED_Y, GPIO_OUT); gpio_set(PORT_LED_Y, 0);
+
+    return 0;
+}
+
+int board_early_init_f(void)
+{
+    /* LED's */
+    board_led_init();
+
+    gpio_set(PORT_LED_R, 1);
+
+    /* Ethernet 0 PHY Reset:  = 1; */
+    pfc_set_gpio(PORT_ET0_RESETn, GPIO_OUT);
+    gpio_set(PORT_ET0_RESETn, 1);
+
+    /* Ethernet 1 PHY Reset: = 1; */
+    pfc_set_gpio(PORT_ET1_RESETn, GPIO_OUT);
+    gpio_set(PORT_ET1_RESETn, 1);
+
+    return 0;
+}
+
+
+static void board_usb_init(void)
+{
+    /*Enable USB*/
+    (*(volatile u32 *)CPG_RST_USB) = 0x000f000f;
+    (*(volatile u32 *)CPG_CLKON_USB) = 0x000f000f;
+
+    /* Setup  */
+    /* Disable GPIO Write Protect */
+    (*(volatile u32 *)PFC_PWPR) &= ~(0x1u << 7);    /* PWPR.BOWI = 0 */
+    (*(volatile u32 *)PFC_PWPR) |= (0x1u << 6);     /* PWPR.PFCWE = 1 */
+
+    /* set P4_0 as Func.1 for VBUSEN */
+    pfc_set_pin_function(PORT_USB0_VBUSEN, FUNC1);
+
+    /* set P5_0 as Func.1 for OVERCUR */
+    pfc_set_pin_function(PORT_USB0_OVRCUR, FUNC1);
+
+    /* set P8_0 as Func.2 for VBUSEN */
+    pfc_set_pin_function(PORT_USB1_VBUSEN, FUNC2);
+
+    /* set P8_1 as Func.2 for OVERCUR */
+    pfc_set_pin_function(PORT_USB1_OVRCUR, FUNC2);
+
+    /* Enable write protect */
+    (*(volatile u32 *)PFC_PWPR) &= ~(0x1u << 6);    /* PWPR.PFCWE = 0 */
+    (*(volatile u32 *)PFC_PWPR) |= (0x1u << 7);     /* PWPR.BOWI = 1 */
+
+    /*Enable 2 USB ports*/
+    (*(volatile u32 *)USBPHY_RESET) = 0x00001000u;
+    /*USB0 is HOST*/
+    (*(volatile u32 *)(USB0_BASE + COMMCTRL)) = 0;
+    /*USB1 is HOST*/
+    (*(volatile u32 *)(USB1_BASE + COMMCTRL)) = 0;
+    /* Set USBPHY normal operation (Function only) */
+    (*(volatile u16 *)(USBF_BASE + LPSTS)) |= (0x1u << 14);     /* USBPHY.SUSPM = 1 (func only) */
+    /* Overcurrent is not supported */
+    (*(volatile u32 *)(USB0_BASE + HcRhDescriptorA)) |= (0x1u << 12);       /* NOCP = 1 */
+    (*(volatile u32 *)(USB1_BASE + HcRhDescriptorA)) |= (0x1u << 12);       /* NOCP = 1 */
+}
+
+
+int board_init(void)
+{
+    /* adress of boot parameters */
+    gd->bd->bi_boot_params = CONFIG_SYS_TEXT_BASE + 0x50000;
+
+    board_usb_init();
+
+    gpio_set(PORT_LED_G, 1);
+
+    return 0;
+}
+
+
+int board_late_init(void)
+{
+    int retval = 0;
+    struct udevice *iic_dev;
+
+
+    /* Set clocks */ 
+    retval = i2c_get_chip_for_busnum(CONFIG_I2C_DEFAULT_BUS_NUMBER, I2C_VERSACLOCK_ADDR, I2C_VERSACLOCK_ADDR_LEN, &iic_dev);
+
+    if (retval == 0)
+    {
+        retval = dm_i2c_write(iic_dev, 0u, ren_5p35023b_settings, sizeof(ren_5p35023b_settings));
+    }
+    else
+    {
+        printf("%s: Couldn't setup system clocks!\n", __func__);
+    }
+
+#ifdef CONFIG_RENESAS_RZG2LWDT
+    rzg2l_reinitr_wdt();
+#endif // CONFIG_RENESAS_RZG2LWDT
+
+#ifdef RESTART_ON_COLD_RESET
+    restart_on_cold_reset();
+#endif
+    /* Read Mac Address and set*/
+    //retval = uclass_get_device_by_name(UCLASS_I2C_EEPROM, "eeprom@50", &iic_dev);
+    retval = i2c_get_chip_for_busnum(CONFIG_SYS_I2C_EEPROM_BUS, I2C_EEPROM_MAC_ADDR, CONFIG_SYS_I2C_EEPROM_ADDR_LEN, &iic_dev);
+    if (retval == 0)
+    {
+        const int ETH_ADDR_LEN = 6;
+        uint8_t ethaddr[ETH_ADDR_LEN];
+
+        retval = dm_i2c_read(iic_dev, ETHER_EEPROM_ADDR, ethaddr, ETH_ADDR_LEN);
+        if (retval == 0 ) 
+        {
+            if (is_valid_ethaddr(ethaddr))
+            {
+                eth_env_set_enetaddr("ethaddr", ethaddr);
+            }
+            else
+            {
+                printf("Invalid ethaddr format in eeprom!\n");
+            }
+        }
+        else
+        {
+            printf("Error reading configuration EEPROM!\n");
+        }
+    }
+    else
+    {
+        printf("%s: Cannot find EEPROM!\n", __func__);
+    }
+  
+    if (retval == 0) {
+        gpio_set(PORT_LED_B, 1);
+    }
+    return 0;
+}
+
+void reset_cpu(void)
+{
+#ifdef CONFIG_RENESAS_RZG2LWDT
+    struct udevice *wdt_dev;
+    if (uclass_get_device(UCLASS_WDT, WDT_INDEX, &wdt_dev) < 0) {
+        printf("failed to get wdt device. cannot reset\n");
+        return;
+    }
+    if (wdt_expire_now(wdt_dev, 0) < 0) {
+        printf("failed to expire_now wdt\n");
+    }
+#endif // CONFIG_RENESAS_RZG2LWDT
+}
diff --git a/board/renesas/vkrzg2l/Kconfig b/board/renesas/vkrzg2l/Kconfig
new file mode 100644
index 0000000000..f6265802ea
--- /dev/null
+++ b/board/renesas/vkrzg2l/Kconfig
@@ -0,0 +1,31 @@
+if TARGET_VKRZG2L
+
+config SYS_SOC
+        default "rmobile"
+
+config SYS_BOARD
+        default "vkrzg2l"
+
+config SYS_VENDOR
+        default "renesas"
+
+config SYS_CONFIG_NAME
+        default "vkrzg2l"
+
+config SYS_MMC_DEV
+	int
+	default 0
+
+config SYS_MMC_IMG_LOAD_PART
+	int
+	default 1
+
+config SYS_USB_DEV
+	int
+	default 0
+
+config SYS_USB_IMG_LOAD_PART
+	int
+	default 1
+endif
+
diff --git a/board/renesas/vkrzg2l/Makefile b/board/renesas/vkrzg2l/Makefile
new file mode 100644
index 0000000000..e97d06a9c3
--- /dev/null
+++ b/board/renesas/vkrzg2l/Makefile
@@ -0,0 +1,13 @@
+#
+# board/renesas/salvator-x/Makefile
+#
+# Copyright (C) 2015 Renesas Electronics Corporation
+#
+# SPDX-License-Identifier: GPL-2.0+
+#
+
+ifdef CONFIG_SPL_BUILD
+obj-y	:= ../rcar-common/gen3-spl.o
+else
+obj-y	:= vkrzg2l.o ../rcar-common/common.o
+endif
diff --git a/board/renesas/vkrzg2l/vkrzg2l.c b/board/renesas/vkrzg2l/vkrzg2l.c
new file mode 100644
index 0000000000..d80c50bf88
--- /dev/null
+++ b/board/renesas/vkrzg2l/vkrzg2l.c
@@ -0,0 +1,306 @@
+#include <common.h>
+#include <cpu_func.h>
+#include <image.h>
+#include <init.h>
+#include <malloc.h>
+#include <netdev.h>
+#include <dm.h>
+#include <dm/platform_data/serial_sh.h>
+#include <asm/processor.h>
+#include <asm/mach-types.h>
+#include <asm/io.h>
+#include <linux/bitops.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/rmobile.h>
+#include <asm/arch/rcar-mstp.h>
+#include <asm/arch/sh_sdhi.h>
+#include <i2c.h>
+#include <mmc.h>
+#include <stdio.h>
+#include <rzg2l_wdt.h>
+#include <renesas/rzg_pfc.h>
+DECLARE_GLOBAL_DATA_PTR;
+
+#define ETH_CH0     (PFC_BASE + 0x300c)
+#define ETH_CH1     (PFC_BASE + 0x3010)
+#define I2C_CH1     (PFC_BASE + 0x1870)
+#define ETH_PVDD_3300   0x00
+#define ETH_PVDD_1800   0x01
+#define ETH_PVDD_2500   0x02
+#define ETH_MII_RGMII   (PFC_BASE + 0x3018)
+
+/* CPG */
+#define CPG_BASE                    0x11010000
+#define CPG_CLKON_BASE              (CPG_BASE + 0x500)
+#define CPG_RESET_BASE              (CPG_BASE + 0x800)
+#define CPG_RESET_ETH               (CPG_RESET_BASE + 0x7C)
+#define CPG_RESET_I2C               (CPG_RESET_BASE + 0x80)
+#define CPG_PL2_SDHI_DSEL           (CPG_BASE + 0x218)
+#define CPG_CLK_STATUS              (CPG_BASE + 0x280)
+#define CPG_RST_USB                 (CPG_BASE + 0x878)
+#define CPG_CLKON_USB               (CPG_BASE + 0x578)
+
+#define USBPHY_BASE     0x11c40000
+#define USB0_BASE       0x11c50000
+#define USB1_BASE       0x11c70000
+#define USBF_BASE       0x11c60000
+#define USBPHY_RESET    (USBPHY_BASE + 0x000u)
+#define COMMCTRL        0x800
+#define HcRhDescriptorA 0x048
+#define LPSTS           0x102
+
+#define RPC_CMNCR       0x10060000
+
+#define PFC_Pn(n)   (PFC_BASE + 0x0010ull + (n))      /* Port register R/W */
+#define PFC_PMn(n)  (PFC_BASE + 0x0120ull + (n) * 2)  /* Port mode register R/W */
+#define PFC_PMCn(n) (PFC_BASE + 0x0210ull + (n))      /* Port mode control register */
+#define PFC_PFCn(n) (PFC_BASE + 0x0440ull + (n) * 4)  /* Port function control register */
+#define PFC_PINn(n) (PFC_BASE + 0x0810ull + (n))      /* Port input register */
+
+#define COMMA   ,
+#define P(p, b)     p COMMA b
+
+#define PORT_LED_R          P( 8, 2)
+#define PORT_LED_G          P(17, 2)
+#define PORT_LED_B          P(19, 1)
+#define PORT_LED_Y          P(15, 0)
+
+#define PORT_ET0_RESETn     P(39, 2)     
+#define PORT_ET1_RESETn     P( 7, 0)
+
+#define PORT_USB0_VBUSEN    P( 4, 0)
+#define PORT_USB0_OVRCUR    P( 5, 0)
+#define PORT_USB1_VBUSEN    P( 8, 0)
+#define PORT_USB1_OVRCUR    P( 8, 1)
+
+#define PORT_SD_PWR_EN      P(19, 0)
+
+#define PORT_USB0_SELn      P( 5, 2)
+
+/* WDT */
+#define WDT_INDEX		0
+
+enum pfc_pin_gpio_mode {GPIO_HiZ=0, GPIO_IN=1, GPIO_OUT=2, GPIO_IO=3};
+enum pfc_pin_func_mode {FUNC0=0, FUNC1, FUNC2, FUNC3, FUNC4, FUNC5 };
+
+
+// assigned-clock-rates = <12288000>, <25000000>,
+//                        <25000000>, <12288000>,
+//                        <11289600>, <24000000>;
+static const u8 ren_5p35023b_settings[] = {
+    0x00, 0x00, 0x11, 0x19, 0x00, 0x42, 0xcc, 0x2b, 0x04, 0x32, 0x00, 0x1a, 0x5f, 0x12, 0x90, 0x79,
+    0x02, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x24, 0x19, 0xbf, 0x3f, 0x30, 0x90, 0x86,
+    0x80, 0xb2, 0x05, 0xc4, 0x9c
+};
+
+
+/* Arguments:
+   n = port(1-48)
+   b = bit(0-4)
+   d = direction(GPIO_HiZ, GPIO_IN, GPIO_OUT, GPIO_IO)
+*/
+static void pfc_set_gpio(u8 n, u8 b, u8 d)
+{
+   *(volatile u8 *)PFC_PMCn(n) &= ~(1ul << b); /* 0b: Port Mode (GPIO) */
+   *(volatile u16 *)PFC_PMn(n) = (*(volatile u16 *)PFC_PMn(n) & ~(0b11<<(b*2))) | (((u16)d & 0b11) << (b*2)); /* set port mode */
+}
+
+/* Arguments:
+   n = port(1-11)
+   b = bit(0-15)
+   v = value (0 or 1)
+*/
+void gpio_set(u8 n, u8 b, u8 v)
+{
+   /* The pin should have been configured as GPIO_OUT using pfc_set_gpio */
+    if ( v ) 
+        *(volatile u8 *)PFC_Pn(n) |= 1UL << b;       // Set pin 
+    else
+        *(volatile u8 *)PFC_Pn(n) &= ~(1UL << b);    // Clear pin
+}
+
+/* Arguments:
+   n = port(1-40)
+   b = bit(0-4)
+   return = current pin level (0 or 1);
+*/
+static u8 gpio_read(u8 n, u8 b)
+{
+   /* The pin should have been configured as GPIO_IN using pfc_set_gpio */
+   //printf("PINn(%d) %04X\n",n,*(volatile u8 *)PFC_PINn(n));
+   return ( *(volatile u8 *)PFC_PINn(n) >> b ) & 0x01;
+}
+
+
+/* Arguments:
+    n = port number (P1-P40)
+    b = bit number (0-4)
+    func = Alternative function ('FUNC0'-'FUNC5')
+*/
+void pfc_set_pin_function(u16 n, u16 b, u8 func)
+{
+   *(volatile u8 *)PFC_PMCn(n) |= (1ul << b); /* 1b: Peripheral Function Mode (Peripheral Function) */
+
+   *(volatile u32 *)PFC_PFCn(n) = (*(volatile u32 *)PFC_PFCn(n) & ~(0b111<<(b*4))) | (((u16)func & 0b111) << (b*4)); /* set port mode */
+}
+
+
+void s_init(void)
+{
+    /* SD power control: P19_0 = 1; */
+    *(volatile u32 *)(PFC_PMC23) &= 0xFFFFFFFE; /* Port func mode 0b0 */
+    *(volatile u32 *)(PFC_PM23) = (*(volatile u32 *)(PFC_PM23) & 0xFFFFFFFC) | 0x2; /* Port output mode 0b10 */
+    *(volatile u32 *)(PFC_P23) = (*(volatile u32 *)(PFC_P23) & 0xFFFFFFFE) | 0x1;   /* Port 19[0] output value 0b1*/
+
+    /* can go in board_eht_init() once enabled */
+    *(volatile u32 *)(ETH_CH0) = (*(volatile u32 *)(ETH_CH0) & 0xFFFFFFFC) | ETH_PVDD_1800;
+    *(volatile u32 *)(ETH_CH1) = (*(volatile u32 *)(ETH_CH1) & 0xFFFFFFFC) | ETH_PVDD_1800;
+    /* Enable RGMII for both ETH{0,1} */
+    *(volatile u32 *)(ETH_MII_RGMII) = (*(volatile u32 *)(ETH_MII_RGMII) & 0xFFFFFFFC);
+    /* ETH CLK */
+    *(volatile u32 *)(CPG_RESET_ETH) = 0x30003;
+    /* I2C CLK */
+    *(volatile u32 *)(CPG_RESET_I2C) = 0xF000F;
+    /* I2C pin non GPIO enable */
+    *(volatile u32 *)(I2C_CH1) = 0x01010101;
+    /* SD CLK */
+    *(volatile u32 *)(CPG_PL2_SDHI_DSEL) = 0x00110011;
+    while (*(volatile u32 *)(CPG_CLK_STATUS) != 0)
+        ;
+}
+
+
+int board_led_init(void)
+{
+    /* RED LED: P8_2 = 1; */
+    pfc_set_gpio(PORT_LED_R, GPIO_OUT); gpio_set(PORT_LED_R, 0);
+
+    /* GREEN LED: P17_2 = 1; */
+    pfc_set_gpio(PORT_LED_G, GPIO_OUT); gpio_set(PORT_LED_G, 0);
+
+    /* BLUE LED: P19_1 = 1; */
+    pfc_set_gpio(PORT_LED_B, GPIO_OUT); gpio_set(PORT_LED_B, 0);
+
+    /* YELLOW LED: P15_0 = 1; */
+    pfc_set_gpio(PORT_LED_Y, GPIO_OUT); gpio_set(PORT_LED_Y, 0);
+
+    return 0;
+}
+
+int board_early_init_f(void)
+{
+    /* LED's */
+    board_led_init();
+
+    gpio_set(PORT_LED_R, 1);
+
+    /* Ethernet 0 PHY Reset: P39_2 = 1; */
+    pfc_set_gpio(PORT_ET0_RESETn, GPIO_OUT);
+    gpio_set(PORT_ET0_RESETn, 1);
+
+    /* Ethernet 1 PHY Reset: P7_0 = 1; */
+    pfc_set_gpio(PORT_ET1_RESETn, GPIO_OUT);
+    gpio_set(PORT_ET1_RESETn, 1);
+
+    return 0;
+}
+
+
+static void board_usb_init(void)
+{
+    /* Select USB A */
+    pfc_set_gpio(PORT_USB0_SELn, GPIO_OUT);
+    gpio_set(PORT_USB0_SELn, 0);
+    /*Enable USB*/
+    (*(volatile u32 *)CPG_RST_USB) = 0x000f000f;
+    (*(volatile u32 *)CPG_CLKON_USB) = 0x000f000f;
+
+    /* Setup  */
+    /* Disable GPIO Write Protect */
+    (*(volatile u32 *)PFC_PWPR) &= ~(0x1u << 7);    /* PWPR.BOWI = 0 */
+    (*(volatile u32 *)PFC_PWPR) |= (0x1u << 6);     /* PWPR.PFCWE = 1 */
+
+    /* set P4_0 as Func.1 for VBUSEN */
+    pfc_set_pin_function(PORT_USB0_VBUSEN, FUNC1);
+
+    /* set P5_0 as Func.1 for OVERCUR */
+    pfc_set_pin_function(PORT_USB0_OVRCUR, FUNC1);
+
+    /* set P8_0 as Func.2 for VBUSEN */
+    pfc_set_pin_function(PORT_USB1_VBUSEN, FUNC2);
+
+    /* set P8_1 as Func.2 for OVERCUR */
+    pfc_set_pin_function(PORT_USB1_OVRCUR, FUNC2);
+
+    /* Enable write protect */
+    (*(volatile u32 *)PFC_PWPR) &= ~(0x1u << 6);    /* PWPR.PFCWE = 0 */
+    (*(volatile u32 *)PFC_PWPR) |= (0x1u << 7);     /* PWPR.BOWI = 1 */
+
+    /*Enable 2 USB ports*/
+    (*(volatile u32 *)USBPHY_RESET) = 0x00001000u;
+    /*USB0 is HOST*/
+    (*(volatile u32 *)(USB0_BASE + COMMCTRL)) = 0;
+    /*USB1 is HOST*/
+    (*(volatile u32 *)(USB1_BASE + COMMCTRL)) = 0;
+    /* Set USBPHY normal operation (Function only) */
+    (*(volatile u16 *)(USBF_BASE + LPSTS)) |= (0x1u << 14);     /* USBPHY.SUSPM = 1 (func only) */
+    /* Overcurrent is not supported */
+    (*(volatile u32 *)(USB0_BASE + HcRhDescriptorA)) |= (0x1u << 12);       /* NOCP = 1 */
+    (*(volatile u32 *)(USB1_BASE + HcRhDescriptorA)) |= (0x1u << 12);       /* NOCP = 1 */
+}
+
+
+int board_init(void)
+{
+    /* adress of boot parameters */
+    gd->bd->bi_boot_params = CONFIG_SYS_TEXT_BASE + 0x50000;
+
+    board_usb_init();
+
+    gpio_set(PORT_LED_G, 1);
+
+    return 0;
+}
+
+
+int board_late_init(void)
+{
+    int retval = 0;
+    struct udevice *iic_dev;
+
+
+    /* Set clocks */ 
+    retval = i2c_get_chip_for_busnum(CONFIG_I2C_DEFAULT_BUS_NUMBER, I2C_VERSACLOCK_ADDR, 1, &iic_dev);
+
+    if (retval == 0)
+        retval = dm_i2c_write(iic_dev, 0u, ren_5p35023b_settings, sizeof(ren_5p35023b_settings));
+
+
+#ifdef CONFIG_RENESAS_RZG2LWDT
+    rzg2l_reinitr_wdt();
+#endif // CONFIG_RENESAS_RZG2LWDT
+
+  
+    if (retval == 0) {
+        gpio_set(PORT_LED_B, 1);
+    }
+    return 0;
+}
+
+void reset_cpu(void)
+{
+#ifdef CONFIG_RENESAS_RZG2LWDT
+    struct udevice *wdt_dev;
+    if (uclass_get_device(UCLASS_WDT, WDT_INDEX, &wdt_dev) < 0) {
+        printf("failed to get wdt device. cannot reset\n");
+        return;
+    }
+    if (wdt_expire_now(wdt_dev, 0) < 0) {
+        printf("failed to expire_now wdt\n");
+    }
+#endif // CONFIG_RENESAS_RZG2LWDT
+}
diff --git a/board/renesas/vkrzg2lc/Kconfig b/board/renesas/vkrzg2lc/Kconfig
new file mode 100644
index 0000000000..c7165ac31f
--- /dev/null
+++ b/board/renesas/vkrzg2lc/Kconfig
@@ -0,0 +1,33 @@
+if TARGET_VKRZG2LC
+
+config SYS_SOC
+        default "rmobile"
+
+config SYS_BOARD
+        default "vkrzg2lc"
+
+config SYS_VENDOR
+        default "renesas"
+
+config SYS_CONFIG_NAME
+        default "vkrzg2lc"
+
+config SYS_MMC_DEV
+	int
+	default 1 if ENV_IS_IN_SPI_FLASH
+	default 0
+
+config SYS_MMC_IMG_LOAD_PART
+	int
+	default 1
+
+config SYS_USB_DEV
+	int
+	default 0
+
+config SYS_USB_IMG_LOAD_PART
+	int
+	default 1
+
+endif
+
diff --git a/board/renesas/vkrzg2lc/Makefile b/board/renesas/vkrzg2lc/Makefile
new file mode 100644
index 0000000000..ab39eff77b
--- /dev/null
+++ b/board/renesas/vkrzg2lc/Makefile
@@ -0,0 +1,13 @@
+#
+# board/renesas/salvator-x/Makefile
+#
+# Copyright (C) 2015 Renesas Electronics Corporation
+#
+# SPDX-License-Identifier: GPL-2.0+
+#
+
+ifdef CONFIG_SPL_BUILD
+obj-y	:= ../rcar-common/gen3-spl.o
+else
+obj-y	:= vkrzg2lc.o ../rcar-common/common.o
+endif
diff --git a/board/renesas/vkrzg2lc/vkrzg2lc.c b/board/renesas/vkrzg2lc/vkrzg2lc.c
new file mode 100644
index 0000000000..46391d01c9
--- /dev/null
+++ b/board/renesas/vkrzg2lc/vkrzg2lc.c
@@ -0,0 +1,388 @@
+#include <common.h>
+#include <cpu_func.h>
+#include <image.h>
+#include <init.h>
+#include <malloc.h>
+#include <netdev.h>
+#include <net.h>
+#include <dm.h>
+#include <dm/device.h>
+#include <dm/uclass.h>
+#include <dm/platform_data/serial_sh.h>
+#include <asm/processor.h>
+#include <asm/mach-types.h>
+#include <asm/io.h>
+#include <linux/bitops.h>
+#include <linux/errno.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/rmobile.h>
+#include <asm/arch/rcar-mstp.h>
+#include <asm/arch/sh_sdhi.h>
+#include <i2c.h>
+#include <i2c_eeprom.h>
+#include <mmc.h>
+#include <wdt.h>
+#include <rzg2l_wdt.h>
+#include <renesas/rzg_pfc.h>
+#include <linux/delay.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define ETH_CH0         (PFC_BASE + 0x300c)
+#define I2C_CH1         (PFC_BASE + 0x1870)
+#define ETH_PVDD_3300   0x00
+#define ETH_PVDD_1800   0x01
+#define ETH_PVDD_2500   0x02
+#define ETH_MII_RGMII   (PFC_BASE + 0x3018)
+
+/* CPG */
+#define CPG_BASE                    0x11010000
+#define CPG_CLKON_BASE              (CPG_BASE + 0x500)
+#define CPG_RESET_BASE              (CPG_BASE + 0x800)
+#define CPG_RESET_ETH               (CPG_RESET_BASE + 0x7C)
+#define CPG_RESET_I2C               (CPG_RESET_BASE + 0x80)
+#define CPG_PL2_SDHI_DSEL           (CPG_BASE + 0x218)
+#define CPG_CLK_STATUS              (CPG_BASE + 0x280)
+#define CPG_RST_USB                 (CPG_BASE + 0x878)
+#define CPG_CLKON_USB               (CPG_BASE + 0x578)
+
+#define USBPHY_BASE     0x11c40000
+#define USB0_BASE       0x11c50000
+#define USB1_BASE       0x11c70000
+#define USBF_BASE       0x11c60000
+#define USBPHY_RESET    (USBPHY_BASE + 0x000u)
+#define COMMCTRL        0x800
+#define HcRhDescriptorA 0x048
+#define LPSTS           0x102
+
+#define RPC_CMNCR       0x10060000
+
+#define RESTART_ON_COLD_RESET
+
+#define PFC_Pn(n)   (PFC_BASE + 0x0010ull + (n))      /* Port register R/W */
+#define PFC_PMn(n)  (PFC_BASE + 0x0120ull + (n) * 2)  /* Port mode register R/W */
+#define PFC_PMCn(n) (PFC_BASE + 0x0210ull + (n))      /* Port mode control register */
+#define PFC_PFCn(n) (PFC_BASE + 0x0440ull + (n) * 4)  /* Port function control register */
+#define PFC_PINn(n) (PFC_BASE + 0x0810ull + (n))      /* Port input register */
+
+#define COMMA   ,
+#define P(p, b)     p COMMA b
+
+#define PORT_LED_R          P( 43, 3)
+
+#define PORT_USB0_VBUSEN    P( 4, 0)
+#define PORT_USB0_OVRCUR    P( 5, 0)
+#define PORT_USB1_VBUSEN    P( 42, 0)
+#define PORT_USB1_OVRCUR    P( 42, 1)
+
+#define DO_RESET_LCD_PANEL 1
+
+#define PORT_PANEL_RST      P(  4, 1)
+#define PORT_PANEL_RST1     P( 22, 1)
+
+/* WDT */
+#define WDT_INDEX       0
+
+enum pfc_pin_gpio_mode {GPIO_HiZ=0, GPIO_IN=1, GPIO_OUT=2, GPIO_IO=3};
+enum pfc_pin_func_mode {FUNC0=0, FUNC1, FUNC2, FUNC3, FUNC4, FUNC5 };
+
+
+// assigned-clock-rates = <12288000>, <25000000>,
+//                        <25000000>, <12288000>,
+//                        <11289600>, <24000000>;
+static const u8 ren_5p35023b_settings[] = {
+    0x00, 0x00, 0x11, 0x19, 0x00, 0x42, 0xcc, 0x2b, 0x04, 0x32, 0x00, 0x1a, 0x5f, 0x12, 0x90, 0x79,
+    0x02, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x24, 0x19, 0xbf, 0x3f, 0x30, 0x90, 0x86,
+    0x80, 0xb2, 0x05, 0xc4, 0x9c
+};
+
+
+/* Arguments:
+   n = port(1-48)
+   b = bit(0-4)
+   d = direction(GPIO_HiZ, GPIO_IN, GPIO_OUT, GPIO_IO)
+*/
+static void pfc_set_gpio(u8 n, u8 b, u8 d)
+{
+   *(volatile u8 *)PFC_PMCn(n) &= ~(1ul << b); /* 0b: Port Mode (GPIO) */
+   *(volatile u16 *)PFC_PMn(n) = (*(volatile u16 *)PFC_PMn(n) & ~(0b11<<(b*2))) | (((u16)d & 0b11) << (b*2)); /* set port mode */
+}
+
+/* Arguments:
+   n = port(1-11)
+   b = bit(0-15)
+   v = value (0 or 1)
+*/
+void gpio_set(u8 n, u8 b, u8 v)
+{
+   /* The pin should have been configured as GPIO_OUT using pfc_set_gpio */
+    if ( v ) 
+        *(volatile u8 *)PFC_Pn(n) |= 1UL << b;       // Set pin 
+    else
+        *(volatile u8 *)PFC_Pn(n) &= ~(1UL << b);    // Clear pin
+}
+
+/* Arguments:
+   n = port(1-40)
+   b = bit(0-4)
+   return = current pin level (0 or 1);
+*/
+static u8 gpio_read(u8 n, u8 b)
+{
+   /* The pin should have been configured as GPIO_IN using pfc_set_gpio */
+   //printf("PINn(%d) %04X\n",n,*(volatile u8 *)PFC_PINn(n));
+   return ( *(volatile u8 *)PFC_PINn(n) >> b ) & 0x01;
+}
+
+
+/* Arguments:
+    n = port number (P1-P40)
+    b = bit number (0-4)
+    func = Alternative function ('FUNC0'-'FUNC5')
+*/
+void pfc_set_pin_function(u16 n, u16 b, u8 func)
+{
+   *(volatile u8 *)PFC_PMCn(n) |= (1ul << b); /* 1b: Peripheral Function Mode (Peripheral Function) */
+
+   *(volatile u32 *)PFC_PFCn(n) = (*(volatile u32 *)PFC_PFCn(n) & ~(0b111<<(b*4))) | (((u16)func & 0b111) << (b*4)); /* set port mode */
+}
+
+
+void s_init(void)
+{
+    /* can go in board_eht_init() once enabled */
+    *(volatile u32 *)(ETH_CH0) = (*(volatile u32 *)(ETH_CH0) & 0xFFFFFFFC) | ETH_PVDD_1800;
+    /* Enable RGMII for ETH0 */
+    *(volatile u32 *)(ETH_MII_RGMII) = (*(volatile u32 *)(ETH_MII_RGMII) & 0xFFFFFFFC);
+    /* ETH CLK */
+    *(volatile u32 *)(CPG_RESET_ETH) = 0x30001;
+    /* I2C CLK */
+    *(volatile u32 *)(CPG_RESET_I2C) = 0xF000F;
+    /* I2C pin non GPIO enable */
+    *(volatile u32 *)(I2C_CH1) = 0x01010101;    
+    /* SD CLK */
+    *(volatile u32 *)(CPG_PL2_SDHI_DSEL) = 0x00110011;
+    while (*(volatile u32 *)(CPG_CLK_STATUS) != 0)
+            ;
+
+    *(volatile u32 *)(RPC_CMNCR) = 0x01FFF300;
+}
+
+#define WARM_RESET_PATTERN "This is an warm reset!"
+#define RST_PATTERN_LEN (size_t)(sizeof(WARM_RESET_PATTERN)-1)
+#define PATTERN_LOC 0x0002e000
+
+#define I2C_PMIC_ADDR               0x12
+#define I2C_PMIC_ADDR_LEN           1
+#define I2C_PMIC_REG_SOFTRST        0x6D
+#define I2C_PMIC_SOFTRST_COLDRST    (1<<0)
+#define I2C_PMIC_SOFTRST_WARMRST    (1<<1)
+
+void restart_on_cold_reset(void)
+{
+    if ( strncmp((const char *)PATTERN_LOC, WARM_RESET_PATTERN, RST_PATTERN_LEN) != 0 ) 
+    { 
+        strncpy((char *)PATTERN_LOC, WARM_RESET_PATTERN, RST_PATTERN_LEN);
+
+        printf("%s: Cold RESET detected!\n", __func__);
+
+        mdelay(100);
+       
+#if 1 
+        struct udevice *wdt_dev;
+        if (uclass_get_device(UCLASS_WDT, WDT_INDEX, &wdt_dev) < 0) {
+            printf("failed to get wdt device. cannot reset\n");
+            return;
+        }
+        if (wdt_expire_now(wdt_dev, 1) < 0) {
+            printf("failed to expire_now wdt\n");
+        }
+#else 
+        struct udevice *iic_dev;
+
+        if (i2c_get_chip_for_busnum(CONFIG_I2C_DEFAULT_BUS_NUMBER, I2C_PMIC_ADDR, I2C_PMIC_ADDR_LEN, &iic_dev) != 0 ) 
+        {
+            log_err("failed to get PMIC device. cannot reset\n");
+            return;
+        }
+
+        if ( dm_i2c_reg_write(iic_dev, I2C_PMIC_REG_SOFTRST, (unsigned char)I2C_PMIC_SOFTRST_WARMRST) < 0)
+        {
+            log_err("failed to force PMIC software reset\n");
+        }
+        else
+        {
+            log_debug("Waiting for RESET!\n");
+            hang();
+        }
+#endif
+    }
+    else
+    {
+        printf("%s: Warm RESET detected!\n", __func__);
+    }
+}
+
+static int board_led_init(void)
+{
+    /* RED LED: P8_2 = 1; */
+    pfc_set_gpio(PORT_LED_R, GPIO_OUT); gpio_set(PORT_LED_R, 0);
+
+    return 0;
+}
+
+// workaround for EE00700 artifacts
+static void board_panel_init(void)
+{
+#if DO_RESET_LCD_PANEL == 1
+	pfc_set_gpio(PORT_PANEL_RST, GPIO_OUT);
+	pfc_set_gpio(PORT_PANEL_RST1, GPIO_OUT);
+
+	gpio_set(PORT_PANEL_RST, 0);
+	gpio_set(PORT_PANEL_RST1, 0);
+	mdelay(5);
+	gpio_set(PORT_PANEL_RST, 1);
+	gpio_set(PORT_PANEL_RST1, 1);
+#endif
+}
+
+int board_early_init_f(void)
+{
+    /* LED's */
+    board_led_init();
+
+    //gpio_set(PORT_LED_R, 1);
+
+	board_panel_init();
+
+    return 0;
+}
+
+
+static void board_usb_init(void)
+{
+    /*Enable USB*/
+    (*(volatile u32 *)CPG_RST_USB) = 0x000f000f;
+    (*(volatile u32 *)CPG_CLKON_USB) = 0x000f000f;
+
+    /* Setup  */
+    /* Disable GPIO Write Protect */
+    (*(volatile u32 *)PFC_PWPR) &= ~(0x1u << 7);    /* PWPR.BOWI = 0 */
+    (*(volatile u32 *)PFC_PWPR) |= (0x1u << 6);     /* PWPR.PFCWE = 1 */
+
+    /* set P4_0 as Func.1 for VBUSEN */
+    pfc_set_pin_function(PORT_USB0_VBUSEN, FUNC1);
+
+    /* set P5_0 as Func.1 for OVERCUR */
+    pfc_set_pin_function(PORT_USB0_OVRCUR, FUNC1);
+
+    /* set P42_0 as Func.1 for VBUSEN */
+    pfc_set_pin_function(PORT_USB1_VBUSEN, FUNC1);
+
+    /* set P42_1 as Func.1 for OVERCUR */
+    pfc_set_pin_function(PORT_USB1_OVRCUR, FUNC1);
+
+    /* Enable write protect */
+    (*(volatile u32 *)PFC_PWPR) &= ~(0x1u << 6);    /* PWPR.PFCWE = 0 */
+    (*(volatile u32 *)PFC_PWPR) |= (0x1u << 7);     /* PWPR.BOWI = 1 */
+
+    /*Enable 2 USB ports*/
+    (*(volatile u32 *)USBPHY_RESET) = 0x00001000u;
+    /*USB0 is HOST*/
+    (*(volatile u32 *)(USB0_BASE + COMMCTRL)) = 0;
+    /*USB1 is HOST*/
+    (*(volatile u32 *)(USB1_BASE + COMMCTRL)) = 0;
+    /* Set USBPHY normal operation (Function only) */
+    (*(volatile u16 *)(USBF_BASE + LPSTS)) |= (0x1u << 14);     /* USBPHY.SUSPM = 1 (func only) */
+    /* Overcurrent is not supported */
+    (*(volatile u32 *)(USB0_BASE + HcRhDescriptorA)) |= (0x1u << 12);       /* NOCP = 1 */
+    (*(volatile u32 *)(USB1_BASE + HcRhDescriptorA)) |= (0x1u << 12);       /* NOCP = 1 */
+}
+
+
+int board_init(void)
+{
+    /* adress of boot parameters */
+    gd->bd->bi_boot_params = CONFIG_SYS_TEXT_BASE + 0x50000;
+
+    board_usb_init();
+
+    return 0;
+}
+
+
+int board_late_init(void)
+{
+    int off, retval = 0;
+    struct udevice *iic_dev;
+
+    /* Set clocks */ 
+    retval = i2c_get_chip_for_busnum(CONFIG_I2C_DEFAULT_BUS_NUMBER, I2C_VERSACLOCK_ADDR, I2C_VERSACLOCK_ADDR_LEN, &iic_dev);
+
+    if (retval == 0)
+    {
+        retval = dm_i2c_write(iic_dev, 0u, ren_5p35023b_settings, sizeof(ren_5p35023b_settings));
+    }
+    else
+    {
+        printf("%s: Couldn't setup system clocks!\n", __func__);
+    }
+
+#ifdef CONFIG_RENESAS_RZG2LWDT
+    rzg2l_reinitr_wdt();
+#endif // CONFIG_RENESAS_RZG2LWDT
+
+#ifdef RESTART_ON_COLD_RESET
+    restart_on_cold_reset();
+#endif
+    /* Read Mac Address and set*/
+    //retval = uclass_get_device_by_name(UCLASS_I2C_EEPROM, "eeprom@50", &iic_dev);
+    retval = i2c_get_chip_for_busnum(CONFIG_SYS_I2C_EEPROM_BUS, I2C_EEPROM_MAC_ADDR, CONFIG_SYS_I2C_EEPROM_ADDR_LEN, &iic_dev);
+    if (retval == 0)
+    {
+        const int ETH_ADDR_LEN = 6;
+        uint8_t ethaddr[ETH_ADDR_LEN];
+
+        retval = dm_i2c_read(iic_dev, ETHER_EEPROM_ADDR, ethaddr, ETH_ADDR_LEN);
+        if (retval == 0 ) 
+        {
+            if (is_valid_ethaddr(ethaddr))
+            {
+                eth_env_set_enetaddr("ethaddr", ethaddr);
+            }
+            else
+            {
+                printf("Invalid ethaddr format in eeprom!\n");
+            }
+        }
+        else
+        {
+            printf("Error reading configuration EEPROM!\n");
+        }
+    }
+    else
+    {
+        printf("%s: Cannot find EEPROM!\n", __func__);
+    }
+  
+    if (retval == 0) {
+        gpio_set(PORT_LED_R, 1);
+    }
+    return 0;
+}
+
+void reset_cpu(void)
+{
+#ifdef CONFIG_RENESAS_RZG2LWDT
+    struct udevice *wdt_dev;
+    if (uclass_get_device(UCLASS_WDT, WDT_INDEX, &wdt_dev) < 0) {
+        printf("failed to get wdt device. cannot reset\n");
+        return;
+    }
+    if (wdt_expire_now(wdt_dev, 0) < 0) {
+        printf("failed to expire_now wdt\n");
+    }
+#endif // CONFIG_RENESAS_RZG2LWDT
+}
diff --git a/board/renesas/vkrzg2ul/Kconfig b/board/renesas/vkrzg2ul/Kconfig
new file mode 100644
index 0000000000..28faa214ec
--- /dev/null
+++ b/board/renesas/vkrzg2ul/Kconfig
@@ -0,0 +1,33 @@
+if TARGET_VKRZG2UL
+
+config SYS_SOC
+        default "rmobile"
+
+config SYS_BOARD
+        default "vkrzg2ul"
+
+config SYS_VENDOR
+        default "renesas"
+
+config SYS_CONFIG_NAME
+        default "vkrzg2ul"
+
+config SYS_MMC_DEV
+	int
+	default 1 if ENV_IS_IN_SPI_FLASH
+	default 0
+
+config SYS_MMC_IMG_LOAD_PART
+	int
+	default 1
+
+config SYS_USB_DEV
+	int
+	default 0
+
+config SYS_USB_IMG_LOAD_PART
+	int
+	default 1
+
+endif
+
diff --git a/board/renesas/vkrzg2ul/Makefile b/board/renesas/vkrzg2ul/Makefile
new file mode 100644
index 0000000000..5b28952fc6
--- /dev/null
+++ b/board/renesas/vkrzg2ul/Makefile
@@ -0,0 +1,13 @@
+#
+# board/renesas/salvator-x/Makefile
+#
+# Copyright (C) 2015 Renesas Electronics Corporation
+#
+# SPDX-License-Identifier: GPL-2.0+
+#
+
+ifdef CONFIG_SPL_BUILD
+obj-y	:= ../rcar-common/gen3-spl.o
+else
+obj-y	:= vkrzg2ul.o ../rcar-common/common.o
+endif
diff --git a/board/renesas/vkrzg2ul/vkrzg2ul.c b/board/renesas/vkrzg2ul/vkrzg2ul.c
new file mode 100644
index 0000000000..d92a5d0066
--- /dev/null
+++ b/board/renesas/vkrzg2ul/vkrzg2ul.c
@@ -0,0 +1,335 @@
+#include <common.h>
+#include <cpu_func.h>
+#include <image.h>
+#include <init.h>
+#include <malloc.h>
+#include <netdev.h>
+#include <net.h>
+#include <dm.h>
+#include <dm/device.h>
+#include <dm/uclass.h>
+#include <dm/platform_data/serial_sh.h>
+#include <asm/processor.h>
+#include <asm/mach-types.h>
+#include <asm/io.h>
+#include <linux/bitops.h>
+#include <linux/errno.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/rmobile.h>
+#include <asm/arch/rcar-mstp.h>
+#include <asm/arch/sh_sdhi.h>
+#include <i2c.h>
+#include <i2c_eeprom.h>
+#include <mmc.h>
+#include <wdt.h>
+#include <rzg2l_wdt.h>
+#include <renesas/rzg_pfc.h>
+#include <linux/delay.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+
+#define ETH_CH0         (PFC_BASE + 0x300c)
+#define ETH_CH1		    (PFC_BASE + 0x3010)
+#define I2C_CH1         (PFC_BASE + 0x1870)
+#define ETH_PVDD_3300   0x00
+#define ETH_PVDD_1800   0x01
+#define ETH_PVDD_2500   0x02
+#define ETH_MII_RGMII   (PFC_BASE + 0x3018)
+
+/* CPG */
+#define CPG_BASE                    0x11010000
+#define CPG_CLKON_BASE              (CPG_BASE + 0x500)
+#define CPG_RESET_BASE              (CPG_BASE + 0x800)
+#define CPG_RESET_ETH               (CPG_RESET_BASE + 0x7C)
+#define CPG_RESET_I2C               (CPG_RESET_BASE + 0x80)
+#define CPG_PL2_SDHI_DSEL           (CPG_BASE + 0x218)
+#define CPG_CLK_STATUS              (CPG_BASE + 0x280)
+#define CPG_RST_USB                 (CPG_BASE + 0x878)
+#define CPG_CLKON_USB               (CPG_BASE + 0x578)
+
+#define USBPHY_BASE     0x11c40000
+#define USB0_BASE       0x11c50000
+#define USB1_BASE       0x11c70000
+#define USBF_BASE       0x11c60000
+#define USBPHY_RESET    (USBPHY_BASE + 0x000u)
+#define COMMCTRL        0x800
+#define HcRhDescriptorA 0x048
+#define LPSTS           0x102
+
+#define RPC_CMNCR       0x10060000
+
+#define PFC_Pn(n)   (PFC_BASE + 0x0010ull + (n))      /* Port register R/W */
+#define PFC_PMn(n)  (PFC_BASE + 0x0120ull + (n) * 2)  /* Port mode register R/W */
+#define PFC_PMCn(n) (PFC_BASE + 0x0210ull + (n))      /* Port mode control register */
+#define PFC_PFCn(n) (PFC_BASE + 0x0440ull + (n) * 4)  /* Port function control register */
+#define PFC_PINn(n) (PFC_BASE + 0x0810ull + (n))      /* Port input register */
+
+#define COMMA   ,
+#define P(p, b)     p COMMA b
+
+#define PORT_LED_R          P(17, 2)
+
+#define PORT_USB0_VBUSEN    P( 5, 0)
+#define PORT_USB0_OVRCUR    P( 5, 2)
+#define PORT_USB1_VBUSEN    P(18, 4)
+#define PORT_USB1_OVRCUR    P(18, 5)
+
+#define PORT_ET0_RESETn     P( 4, 2)     
+#define PORT_ET1_RESETn     P(10, 1)
+
+#define PORT_SD_PWR_EN      P( 8, 2)
+
+
+/* WDT */
+#define WDT_INDEX       0
+
+enum pfc_pin_gpio_mode {GPIO_HiZ=0, GPIO_IN=1, GPIO_OUT=2, GPIO_IO=3};
+enum pfc_pin_func_mode {FUNC0=0, FUNC1, FUNC2, FUNC3, FUNC4, FUNC5, FUNC6, FUNC7 };
+
+
+// assigned-clock-rates = <12288000>, <25000000>,
+//                        <25000000>, <32768>,
+//                        <11289600>, <24000000>;
+//static const u8 ren_5p35023b_settings[] = {
+//    0x00, 0x00, 0x11, 0x19, 0x00, 0x42, 0xcc, 0x2b, 0x04, 0x32, 0x00, 0x1a, 0x5f, 0x12, 0x90, 0x79,
+//    0x02, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x24, 0x19, 0xbf, 0x3f, 0x30, 0x90, 0x86,
+//    0x80, 0xb2, 0x05, 0xc4, 0x9c
+//};
+
+// assigned-clock-rates = <12288000>, <25000000>,
+//                        <25000000>, <OFF>,
+//                        <11289600>, <24000000>;
+static const u8 ren_5p35023b_settings[] = {
+    0x00, 0x00, 0x11, 0x19, 0x00, 0x42, 0xCC, 0x2B, 0x04, 0x32, 0x00, 0x1A, 0x5F, 0x12, 0x90, 0x79,
+    0x02, 0x4C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x24, 0x19, 0xBF, 0x3F, 0x30, 0x80, 0x86,
+    0x80, 0xC2, 0x45, 0xC4, 0x9E, 0x6E
+};
+
+/* Arguments:
+   n = port(1-48)
+   b = bit(0-4)
+   d = direction(GPIO_HiZ, GPIO_IN, GPIO_OUT, GPIO_IO)
+*/
+static void pfc_set_gpio(u8 n, u8 b, u8 d)
+{
+   *(volatile u8 *)PFC_PMCn(n) &= ~(1ul << b); /* 0b: Port Mode (GPIO) */
+   *(volatile u16 *)PFC_PMn(n) = (*(volatile u16 *)PFC_PMn(n) & ~(0b11<<(b*2))) | (((u16)d & 0b11) << (b*2)); /* set port mode */
+}
+
+/* Arguments:
+   n = port(1-11)
+   b = bit(0-15)
+   v = value (0 or 1)
+*/
+void gpio_set(u8 n, u8 b, u8 v)
+{
+   /* The pin should have been configured as GPIO_OUT using pfc_set_gpio */
+    if ( v ) 
+        *(volatile u8 *)PFC_Pn(n) |= 1UL << b;       // Set pin 
+    else
+        *(volatile u8 *)PFC_Pn(n) &= ~(1UL << b);    // Clear pin
+}
+
+/* Arguments:
+   n = port(1-40)
+   b = bit(0-4)
+   return = current pin level (0 or 1);
+*/
+static u8 gpio_read(u8 n, u8 b)
+{
+   /* The pin should have been configured as GPIO_IN using pfc_set_gpio */
+   //printf("PINn(%d) %04X\n",n,*(volatile u8 *)PFC_PINn(n));
+   return ( *(volatile u8 *)PFC_PINn(n) >> b ) & 0x01;
+}
+
+
+/* Arguments:
+    n = port number (P1-P40)
+    b = bit number (0-4)
+    func = Alternative function ('FUNC1'-'FUNC7')
+*/
+void pfc_set_pin_function(u16 n, u16 b, u8 func)
+{
+   *(volatile u8 *)PFC_PMCn(n) |= (1ul << b); /* 1b: Peripheral Function Mode (Peripheral Function) */
+
+   *(volatile u32 *)PFC_PFCn(n) = (*(volatile u32 *)PFC_PFCn(n) & ~(0b111<<(b*4))) | (((u16)func & 0b111) << (b*4)); /* set port mode */
+}
+
+
+void s_init(void)
+{
+    pfc_set_gpio(PORT_SD_PWR_EN, GPIO_OUT); 
+    gpio_set(PORT_SD_PWR_EN, 1);
+
+    /* can go in board_eht_init() once enabled */
+    *(volatile u32 *)(ETH_CH0) = (*(volatile u32 *)(ETH_CH0) & 0xFFFFFFFC) | ETH_PVDD_1800;
+	*(volatile u32 *)(ETH_CH1) = (*(volatile u32 *)(ETH_CH1) & 0xFFFFFFFC) | ETH_PVDD_1800;
+    /* Enable RGMII for ETH0 */
+    *(volatile u32 *)(ETH_MII_RGMII) = (*(volatile u32 *)(ETH_MII_RGMII) & 0xFFFFFFFC);
+    /* ETH CLK */
+    *(volatile u32 *)(CPG_RESET_ETH) = 0x30003;
+    /* I2C CLK */
+    *(volatile u32 *)(CPG_RESET_I2C) = 0xF000F;
+    /* I2C pin non GPIO enable */
+    *(volatile u32 *)(I2C_CH1) = 0x01010101;    
+    /* SD CLK */
+    *(volatile u32 *)(CPG_PL2_SDHI_DSEL) = 0x00110011;
+    while (*(volatile u32 *)(CPG_CLK_STATUS) != 0)
+            ;
+
+    *(volatile u32 *)(RPC_CMNCR) = 0x01FFF300;
+}
+
+
+static int board_led_init(void)
+{
+    /* RED LED: P8_2 = 1; */
+    pfc_set_gpio(PORT_LED_R, GPIO_OUT); gpio_set(PORT_LED_R, 0);
+
+    return 0;
+}
+
+
+int board_early_init_f(void)
+{
+    /* LED's */
+    board_led_init();
+
+    /* Ethernet 0 PHY Reset:  */
+    //pfc_set_gpio(PORT_ET0_RESETn, GPIO_OUT);
+    //gpio_set(PORT_ET0_RESETn, 1);
+
+    /* Ethernet 1 PHY Reset:  */
+    //pfc_set_gpio(PORT_ET1_RESETn, GPIO_OUT);
+    //gpio_set(PORT_ET1_RESETn, 1);
+
+
+    return 0;
+}
+
+
+static void board_usb_init(void)
+{
+    /*Enable USB*/
+    (*(volatile u32 *)CPG_RST_USB) = 0x000f000f;
+    (*(volatile u32 *)CPG_CLKON_USB) = 0x000f000f;
+
+    /* Setup  */
+    /* Disable GPIO Write Protect */
+    (*(volatile u32 *)PFC_PWPR) &= ~(0x1u << 7);    /* PWPR.BOWI = 0 */
+    (*(volatile u32 *)PFC_PWPR) |= (0x1u << 6);     /* PWPR.PFCWE = 1 */
+
+    /* set P5_0 as Func.1 for VBUSEN */
+    pfc_set_pin_function(PORT_USB0_VBUSEN, FUNC1);
+
+    /* set P5_2 as Func.1 for OVERCUR */
+    pfc_set_pin_function(PORT_USB0_OVRCUR, FUNC1);
+
+    /* set P18_4 as Func.4 for VBUSEN */
+    pfc_set_pin_function(PORT_USB1_VBUSEN, FUNC4);
+
+    /* set P18_5 as Func.4 for OVERCUR */
+    pfc_set_pin_function(PORT_USB1_OVRCUR, FUNC4);
+
+    /* Enable write protect */
+    (*(volatile u32 *)PFC_PWPR) &= ~(0x1u << 6);    /* PWPR.PFCWE = 0 */
+    (*(volatile u32 *)PFC_PWPR) |= (0x1u << 7);     /* PWPR.BOWI = 1 */
+
+    /*Enable 2 USB ports*/
+    (*(volatile u32 *)USBPHY_RESET) = 0x00001000u;
+    /*USB0 is HOST*/
+    (*(volatile u32 *)(USB0_BASE + COMMCTRL)) = 0;
+    /*USB1 is HOST*/
+    (*(volatile u32 *)(USB1_BASE + COMMCTRL)) = 0;
+    /* Set USBPHY normal operation (Function only) */
+    (*(volatile u16 *)(USBF_BASE + LPSTS)) |= (0x1u << 14);     /* USBPHY.SUSPM = 1 (func only) */
+    /* Overcurrent is not supported */
+    (*(volatile u32 *)(USB0_BASE + HcRhDescriptorA)) |= (0x1u << 12);       /* NOCP = 1 */
+    (*(volatile u32 *)(USB1_BASE + HcRhDescriptorA)) |= (0x1u << 12);       /* NOCP = 1 */
+}
+
+
+int board_init(void)
+{
+    /* adress of boot parameters */
+    gd->bd->bi_boot_params = CONFIG_SYS_TEXT_BASE + 0x50000;
+
+    board_usb_init();
+
+    return 0;
+}
+
+
+int board_late_init(void)
+{
+    int off, retval = 0;
+    struct udevice *iic_dev;
+
+    /* Set clocks */ 
+    retval = i2c_get_chip_for_busnum(CONFIG_I2C_DEFAULT_BUS_NUMBER, I2C_VERSACLOCK_ADDR, 1, &iic_dev);
+
+    if (retval == 0)
+    {
+        retval = dm_i2c_write(iic_dev, 0u, ren_5p35023b_settings, sizeof(ren_5p35023b_settings));
+    }
+    else
+    {
+        printf("%s: Couldn't setup system clocks!\n", __func__);
+    }
+
+#ifdef CONFIG_RENESAS_RZG2LWDT
+    rzg2l_reinitr_wdt();
+#endif // CONFIG_RENESAS_RZG2LWDT
+
+    /* Read Mac Address and set*/
+    //retval = uclass_get_device_by_name(UCLASS_I2C_EEPROM, "eeprom@50", &iic_dev);
+    retval = i2c_get_chip_for_busnum(CONFIG_SYS_I2C_EEPROM_BUS, CONFIG_SYS_I2C_EEPROM_ADDR, CONFIG_SYS_I2C_EEPROM_ADDR_LEN, &iic_dev);
+    if (retval == 0)
+    {
+        const int ETH_ADDR_LEN = 6;
+        uint8_t ethaddr[ETH_ADDR_LEN];
+
+        retval = dm_i2c_read(iic_dev, ETHER_EEPROM_ADDR, ethaddr, ETH_ADDR_LEN);
+        if (retval == 0 ) 
+        {
+            if (is_valid_ethaddr(ethaddr))
+            {
+                eth_env_set_enetaddr("ethaddr", ethaddr);
+            }
+            else
+            {
+                printf("Invalid ethaddr format in eeprom!\n");
+            }
+        }
+        else
+        {
+            printf("Error reading configuration EEPROM!\n");
+        }
+    }
+    else
+    {
+        printf("%s: Cannot find EEPROM!\n", __func__);
+    }
+  
+    if (retval == 0) {
+        gpio_set(PORT_LED_R, 1);
+    }
+    return 0;
+}
+
+void reset_cpu(void)
+{
+#ifdef CONFIG_RENESAS_RZG2LWDT
+    struct udevice *wdt_dev;
+    if (uclass_get_device(UCLASS_WDT, WDT_INDEX, &wdt_dev) < 0) {
+        printf("failed to get wdt device. cannot reset\n");
+        return;
+    }
+    if (wdt_expire_now(wdt_dev, 0) < 0) {
+        printf("failed to expire_now wdt\n");
+    }
+#endif // CONFIG_RENESAS_RZG2LWDT
+}
diff --git a/board/renesas/vkrzv2l/Kconfig b/board/renesas/vkrzv2l/Kconfig
new file mode 100644
index 0000000000..022e8b5a65
--- /dev/null
+++ b/board/renesas/vkrzv2l/Kconfig
@@ -0,0 +1,28 @@
+if TARGET_VKRZV2L
+
+config SYS_SOC
+        default "rmobile"
+
+config SYS_BOARD
+        default "vkrzv2l"
+
+config SYS_VENDOR
+        default "renesas"
+
+config SYS_CONFIG_NAME
+        default "vkrzv2l"
+
+config SYS_MMC_DEV
+	int
+	default 0
+
+config SYS_MMC_IMG_LOAD_PART
+	int
+	default 1
+
+config OPENCVA
+	int
+	default 0
+
+endif
+
diff --git a/board/renesas/vkrzv2l/Makefile b/board/renesas/vkrzv2l/Makefile
new file mode 100644
index 0000000000..09067c859c
--- /dev/null
+++ b/board/renesas/vkrzv2l/Makefile
@@ -0,0 +1,14 @@
+#
+# board/renesas/salvator-x/Makefile
+#
+# Copyright (C) 2015 Renesas Electronics Corporation
+#
+# SPDX-License-Identifier: GPL-2.0+
+#
+
+ifdef CONFIG_SPL_BUILD
+obj-y	:= ../rcar-common/gen3-spl.o
+else
+obj-y	+= vkrzv2l.o
+obj-y	+= ../rcar-common/common.o
+endif
diff --git a/board/renesas/vkrzv2l/vkrzv2l.c b/board/renesas/vkrzv2l/vkrzv2l.c
new file mode 100644
index 0000000000..d6516c550e
--- /dev/null
+++ b/board/renesas/vkrzv2l/vkrzv2l.c
@@ -0,0 +1,306 @@
+#include <common.h>
+#include <cpu_func.h>
+#include <image.h>
+#include <init.h>
+#include <malloc.h>
+#include <netdev.h>
+#include <dm.h>
+#include <dm/platform_data/serial_sh.h>
+#include <asm/processor.h>
+#include <asm/mach-types.h>
+#include <asm/io.h>
+#include <linux/bitops.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/rmobile.h>
+#include <asm/arch/rcar-mstp.h>
+#include <asm/arch/sh_sdhi.h>
+#include <i2c.h>
+#include <mmc.h>
+#include <stdio.h>
+#include <renesas/rzg_pfc.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define ETH_CH0     (PFC_BASE + 0x300c)
+#define ETH_CH1     (PFC_BASE + 0x3010)
+#define I2C_CH1     (PFC_BASE + 0x1870)
+#define ETH_PVDD_3300   0x00
+#define ETH_PVDD_1800   0x01
+#define ETH_PVDD_2500   0x02
+#define ETH_MII_RGMII   (PFC_BASE + 0x3018)
+
+/* CPG */
+#define CPG_BASE                    0x11010000
+#define CPG_CLKON_BASE              (CPG_BASE + 0x500)
+#define CPG_RESET_BASE              (CPG_BASE + 0x800)
+#define CPG_RESET_ETH               (CPG_RESET_BASE + 0x7C)
+#define CPG_RESET_I2C               (CPG_RESET_BASE + 0x80)
+#define CPG_PL2_SDHI_DSEL           (CPG_BASE + 0x218)
+#define CPG_CLK_STATUS              (CPG_BASE + 0x280)
+#define CPG_RST_USB                 (CPG_BASE + 0x878)
+#define CPG_CLKON_USB               (CPG_BASE + 0x578)
+
+#define USBPHY_BASE     0x11c40000
+#define USB0_BASE       0x11c50000
+#define USB1_BASE       0x11c70000
+#define USBF_BASE       0x11c60000
+#define USBPHY_RESET    (USBPHY_BASE + 0x000u)
+#define COMMCTRL        0x800
+#define HcRhDescriptorA 0x048
+#define LPSTS           0x102
+
+#define RPC_CMNCR       0x10060000
+
+#define PFC_Pn(n)   (PFC_BASE + 0x0010ull + n)      /* Port register R/W */
+#define PFC_PMn(n)  (PFC_BASE + 0x0120ull + n * 2)  /* Port mode register R/W */
+#define PFC_PMCn(n) (PFC_BASE + 0x0210ull + n)      /* Port mode control register */
+#define PFC_PFCn(n) (PFC_BASE + 0x0440ull + n * 4)  /* Port function control register */
+#define PFC_PINn(n) (PFC_BASE + 0x0810ull + n)      /* Port input register */
+
+#define COMMA   ,
+#define P(p, b)     p COMMA b
+
+#define PORT_LED_R          P( 8, 2)
+#define PORT_LED_G          P(17, 2)
+#define PORT_LED_B          P(19, 1)
+#define PORT_LED_Y          P(15, 0)
+
+#define PORT_ET0_RESETn     P(39, 2)     
+#define PORT_ET1_RESETn     P( 7, 0)
+
+#define PORT_USB0_VBUSEN    P( 4, 0)
+#define PORT_USB0_OVRCUR    P( 5, 0)
+#define PORT_USB1_VBUSEN    P( 8, 0)
+#define PORT_USB1_OVRCUR    P( 8, 1)
+
+#define PORT_SD_PWR_EN      P(19, 0)
+
+#define PORT_USB0_SELn      P( 5, 2)
+
+/* WDT */
+#define WDT_INDEX		0
+
+enum pfc_pin_gpio_mode {GPIO_HiZ=0, GPIO_IN=1, GPIO_OUT=2, GPIO_IO=3};
+enum pfc_pin_func_mode {FUNC0=0, FUNC1, FUNC2, FUNC3, FUNC4, FUNC5 };
+
+
+// assigned-clock-rates = <12288000>, <25000000>,
+//                        <25000000>, <12288000>,
+//                        <11289600>, <24000000>;
+static const u8 ren_5p35023b_settings[] = {
+    0x00, 0x00, 0x11, 0x19, 0x00, 0x42, 0xcc, 0x2b, 0x04, 0x32, 0x00, 0x1a, 0x5f, 0x12, 0x90, 0x79,
+    0x02, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x24, 0x19, 0xbf, 0x3f, 0x30, 0x90, 0x86,
+    0x80, 0xb2, 0x05, 0xc4, 0x9c
+};
+
+
+/* Arguments:
+   n = port(1-48)
+   b = bit(0-4)
+   d = direction(GPIO_HiZ, GPIO_IN, GPIO_OUT, GPIO_IO)
+*/
+static void pfc_set_gpio(u8 n, u8 b, u8 d)
+{
+   *(volatile u8 *)PFC_PMCn(n) &= ~(1ul << b); /* 0b: Port Mode (GPIO) */
+   *(volatile u16 *)PFC_PMn(n) = (*(volatile u16 *)PFC_PMn(n) & ~(0b11<<(b*2))) | (((u16)d & 0b11) << (b*2)); /* set port mode */
+}
+
+/* Arguments:
+   n = port(1-11)
+   b = bit(0-15)
+   v = value (0 or 1)
+*/
+void gpio_set(u8 n, u8 b, u8 v)
+{
+   /* The pin should have been configured as GPIO_OUT using pfc_set_gpio */
+    if ( v ) 
+        *(volatile u8 *)PFC_Pn(n) |= 1UL << b;       // Set pin 
+    else
+        *(volatile u8 *)PFC_Pn(n) &= ~(1UL << b);    // Clear pin
+}
+
+/* Arguments:
+   n = port(1-40)
+   b = bit(0-4)
+   return = current pin level (0 or 1);
+*/
+static u8 gpio_read(u8 n, u8 b)
+{
+   /* The pin should have been configured as GPIO_IN using pfc_set_gpio */
+   //printf("PINn(%d) %04X\n",n,*(volatile u8 *)PFC_PINn(n));
+   return ( *(volatile u8 *)PFC_PINn(n) >> b ) & 0x01;
+}
+
+
+/* Arguments:
+    n = port number (P1-P40)
+    b = bit number (0-4)
+    func = Alternative function ('FUNC0'-'FUNC5')
+*/
+void pfc_set_pin_function(u16 n, u16 b, u8 func)
+{
+   *(volatile u8 *)PFC_PMCn(n) |= (1ul << b); /* 1b: Peripheral Function Mode (Peripheral Function) */
+
+   *(volatile u32 *)PFC_PFCn(n) = (*(volatile u32 *)PFC_PFCn(n) & ~(0b111<<(b*4))) | (((u16)func & 0b111) << (b*4)); /* set port mode */
+}
+
+
+void s_init(void)
+{
+    /* SD power control: P19_0 = 1; */
+    *(volatile u32 *)(PFC_PMC23) &= 0xFFFFFFFE; /* Port func mode 0b0 */
+    *(volatile u32 *)(PFC_PM23) = (*(volatile u32 *)(PFC_PM23) & 0xFFFFFFFC) | 0x2; /* Port output mode 0b10 */
+    *(volatile u32 *)(PFC_P23) = (*(volatile u32 *)(PFC_P23) & 0xFFFFFFFE) | 0x1;   /* Port 19[0] output value 0b1*/
+
+    /* can go in board_eht_init() once enabled */
+    *(volatile u32 *)(ETH_CH0) = (*(volatile u32 *)(ETH_CH0) & 0xFFFFFFFC) | ETH_PVDD_1800;
+    *(volatile u32 *)(ETH_CH1) = (*(volatile u32 *)(ETH_CH1) & 0xFFFFFFFC) | ETH_PVDD_1800;
+    /* Enable RGMII for both ETH{0,1} */
+    *(volatile u32 *)(ETH_MII_RGMII) = (*(volatile u32 *)(ETH_MII_RGMII) & 0xFFFFFFFC);
+    /* ETH CLK */
+    *(volatile u32 *)(CPG_RESET_ETH) = 0x30003;
+    /* I2C CLK */
+    *(volatile u32 *)(CPG_RESET_I2C) = 0xF000F;
+    /* I2C pin non GPIO enable */
+    *(volatile u32 *)(I2C_CH1) = 0x01010101;
+    /* SD CLK */
+    *(volatile u32 *)(CPG_PL2_SDHI_DSEL) = 0x00110011;
+    while (*(volatile u32 *)(CPG_CLK_STATUS) != 0)
+        ;
+}
+
+
+int board_led_init(void)
+{
+    /* RED LED: P8_2 = 1; */
+    pfc_set_gpio(PORT_LED_R, GPIO_OUT); gpio_set(PORT_LED_R, 0);
+
+    /* GREEN LED: P17_2 = 1; */
+    pfc_set_gpio(PORT_LED_G, GPIO_OUT); gpio_set(PORT_LED_G, 0);
+
+    /* BLUE LED: P19_1 = 1; */
+    pfc_set_gpio(PORT_LED_B, GPIO_OUT); gpio_set(PORT_LED_B, 0);
+
+    /* YELLOW LED: P15_0 = 1; */
+    pfc_set_gpio(PORT_LED_Y, GPIO_OUT); gpio_set(PORT_LED_Y, 0);
+
+    return 0;
+}
+
+int board_early_init_f(void)
+{
+    /* LED's */
+    board_led_init();
+
+    gpio_set(PORT_LED_R, 1);
+
+    /* Ethernet 0 PHY Reset: P39_2 = 1; */
+    pfc_set_gpio(PORT_ET0_RESETn, GPIO_OUT);
+    gpio_set(PORT_ET0_RESETn, 1);
+
+    /* Ethernet 1 PHY Reset: P7_0 = 1; */
+    pfc_set_gpio(PORT_ET1_RESETn, GPIO_OUT);
+    gpio_set(PORT_ET1_RESETn, 1);
+
+    return 0;
+}
+
+
+static void board_usb_init(void)
+{
+    /* Select USB A */
+    pfc_set_gpio(PORT_USB0_SELn, GPIO_OUT);
+    gpio_set(PORT_USB0_SELn, 0);
+    /*Enable USB*/
+    (*(volatile u32 *)CPG_RST_USB) = 0x000f000f;
+    (*(volatile u32 *)CPG_CLKON_USB) = 0x000f000f;
+
+    /* Setup  */
+    /* Disable GPIO Write Protect */
+    (*(volatile u32 *)PFC_PWPR) &= ~(0x1u << 7);    /* PWPR.BOWI = 0 */
+    (*(volatile u32 *)PFC_PWPR) |= (0x1u << 6);     /* PWPR.PFCWE = 1 */
+
+    /* set P4_0 as Func.1 for VBUSEN */
+    pfc_set_pin_function(PORT_USB0_VBUSEN, FUNC1);
+
+    /* set P5_0 as Func.1 for OVERCUR */
+    pfc_set_pin_function(PORT_USB0_OVRCUR, FUNC1);
+
+    /* set P8_0 as Func.2 for VBUSEN */
+    pfc_set_pin_function(PORT_USB1_VBUSEN, FUNC2);
+
+    /* set P8_1 as Func.2 for OVERCUR */
+    pfc_set_pin_function(PORT_USB1_OVRCUR, FUNC2);
+
+    /* Enable write protect */
+    (*(volatile u32 *)PFC_PWPR) &= ~(0x1u << 6);    /* PWPR.PFCWE = 0 */
+    (*(volatile u32 *)PFC_PWPR) |= (0x1u << 7);     /* PWPR.BOWI = 1 */
+
+    /*Enable 2 USB ports*/
+    (*(volatile u32 *)USBPHY_RESET) = 0x00001000u;
+    /*USB0 is HOST*/
+    (*(volatile u32 *)(USB0_BASE + COMMCTRL)) = 0;
+    /*USB1 is HOST*/
+    (*(volatile u32 *)(USB1_BASE + COMMCTRL)) = 0;
+    /* Set USBPHY normal operation (Function only) */
+    (*(volatile u16 *)(USBF_BASE + LPSTS)) |= (0x1u << 14);     /* USBPHY.SUSPM = 1 (func only) */
+    /* Overcurrent is not supported */
+    (*(volatile u32 *)(USB0_BASE + HcRhDescriptorA)) |= (0x1u << 12);       /* NOCP = 1 */
+    (*(volatile u32 *)(USB1_BASE + HcRhDescriptorA)) |= (0x1u << 12);       /* NOCP = 1 */
+}
+
+
+int board_init(void)
+{
+    /* adress of boot parameters */
+    gd->bd->bi_boot_params = CONFIG_SYS_TEXT_BASE + 0x50000;
+
+    board_usb_init();
+
+    gpio_set(PORT_LED_G, 1);
+
+    return 0;
+}
+
+
+int board_late_init(void)
+{
+    int retval = 0;
+    struct udevice *iic_dev;
+
+
+    /* Set clocks */ 
+    retval = i2c_get_chip_for_busnum(CONFIG_I2C_DEFAULT_BUS_NUMBER, I2C_VERSACLOCK_ADDR, 1, &iic_dev);
+
+    if (retval == 0)
+        retval = dm_i2c_write(iic_dev, 0u, ren_5p35023b_settings, sizeof(ren_5p35023b_settings));
+
+
+#ifdef CONFIG_RENESAS_RZG2LWDT
+    rzg2l_reinitr_wdt();
+#endif // CONFIG_RENESAS_RZG2LWDT
+
+  
+    if (retval == 0) {
+        gpio_set(PORT_LED_B, 1);
+    }
+    return 0;
+}
+
+void reset_cpu(void)
+{
+#ifdef CONFIG_RENESAS_RZG2LWDT
+    struct udevice *wdt_dev;
+    if (uclass_get_device(UCLASS_WDT, WDT_INDEX, &wdt_dev) < 0) {
+        printf("failed to get wdt device. cannot reset\n");
+        return;
+    }
+    if (wdt_expire_now(wdt_dev, 0) < 0) {
+        printf("failed to expire_now wdt\n");
+    }
+#endif // CONFIG_RENESAS_RZG2LWDT
+}
diff --git a/configs/vk-d184280e-emmc_defconfig b/configs/vk-d184280e-emmc_defconfig
new file mode 100644
index 0000000000..8ade5f19ce
--- /dev/null
+++ b/configs/vk-d184280e-emmc_defconfig
@@ -0,0 +1,122 @@
+CONFIG_USB_GADGET=y
+CONFIG_USB_RENESAS_USBHS=y
+CONFIG_USB_FUNCTION_FASTBOOT=y
+CONFIG_FASTBOOT_BUF_ADDR=0x4D000000
+CONFIG_FASTBOOT_BUF_SIZE=0x8000000
+CONFIG_FASTBOOT_USB_DEV=1
+CONFIG_FASTBOOT_MMC_BOOT_SUPPORT=y
+CONFIG_FASTBOOT_MMC_BOOT1_NAME="mmc0boot0"
+CONFIG_FASTBOOT_MMC_BOOT2_NAME="mmc0boot1"
+CONFIG_FASTBOOT_MMC_USER_SUPPORT=y
+CONFIG_FASTBOOT_MMC_USER_NAME="mmc0"
+CONFIG_FASTBOOT_GPT_NAME="gpt"
+CONFIG_FASTBOOT_MBR_NAME="mbr"
+CONFIG_FASTBOOT_FLASH=y
+#On RZ/G2L 0 is eMMC - 1 is SDCard.
+CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_USB_GADGET_MANUFACTURER="Renesas"
+CONFIG_USB_GADGET_VENDOR_NUM=0x18D1
+CONFIG_USB_GADGET_PRODUCT_NUM=0x4E23
+CONFIG_CMD_FASTBOOT=y
+CONFIG_USB_FUNCTION_MASS_STORAGE=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_ARM=y
+CONFIG_ARCH_CPU_INIT=y
+CONFIG_ARCH_RMOBILE=y
+CONFIG_SYS_TEXT_BASE=0x50000000
+CONFIG_DM_GPIO=y
+CONFIG_RCAR_GEN3=y
+CONFIG_R9A07G044C=y
+CONFIG_TARGET_VK_D184280E=y
+CONFIG_SPL=n
+CONFIG_DEFAULT_DEVICE_TREE="vk-d184280e"
+CONFIG_SMBIOS_PRODUCT_NAME=""
+# CONFIG_ANDROID_BOOT_IMAGE is not set
+CONFIG_FIT=y
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="rw rootwait earlycon root=/dev/mmcblk0p2 ${extrabootargs}"
+CONFIG_SUPPORT_RAW_INITRD=y
+CONFIG_DEFAULT_FDT_FILE="vk-d184280e.dtb"
+CONFIG_VERSION_VARIABLE=y
+CONFIG_CMD_CM33=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_OF_CONTROL=y
+CONFIG_OF_LIST="vk-d184280e"
+CONFIG_MULTI_DTB_FIT_LZO=y
+CONFIG_MULTI_DTB_FIT_USER_DEFINED_AREA=y
+CONFIG_ENV_OVERWRITE=y
+#
+CONFIG_ENV_IS_IN_MMC=y
+CONFIG_SYS_MMC_ENV_DEV=0
+CONFIG_SYS_MMC_ENV_PART=1
+CONFIG_ENV_SIZE=0x20000
+CONFIG_ENV_OFFSET=0xFFFE0000
+#
+CONFIG_SYS_RELOC_GD_ENV_ADDR=y
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_REGMAP=y
+CONFIG_SYSCON=y
+CONFIG_CLK=y
+CONFIG_CLK_RENESAS=y
+CONFIG_CLK_R9A07G044L=y
+CONFIG_UDP_FUNCTION_FASTBOOT=y
+#CONFIG_FASTBOOT_BUF_ADDR=0x82000000
+#CONFIG_FASTBOOT_FLASH=y
+#CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_RCAR_GPIO=y
+CONFIG_RZG2L_GPIO=y
+CONFIG_DM=y
+CONFIG_DM_I2C=y
+CONFIG_MISC=y
+CONFIG_SYS_I2C_RCAR_IIC=y
+CONFIG_SYS_I2C_RZG2L_RIIC=y
+CONFIG_SH_SDHI=y
+CONFIG_BITBANGMII=y
+CONFIG_PHY_REALTEK=y
+CONFIG_DM_ETH=y
+CONFIG_RENESAS_RAVB=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_PCI_RCAR_GEN3=y
+CONFIG_PINCTRL_PFC_RZG2L=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_SCIF_CONSOLE=y
+CONFIG_TEE=y
+CONFIG_OPTEE=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_GENERIC=y
+CONFIG_USB_STORAGE=y
+CONFIG_OF_LIBFDT_OVERLAY=y
+CONFIG_SMBIOS_MANUFACTURER=""
+CONFIG_WDT=y
+CONFIG_RENESAS_RZG2LWDT=y
+CONFIG_CMD_WDT=y
+CONFIG_BOARD_LATE_INIT=y
+CONFIG_CMD_EEPROM=y
+CONFIG_I2C_SET_DEFAULT_BUS_NUM=y
+CONFIG_I2C_DEFAULT_BUS_NUMBER=0
+CONFIG_I2C_EEPROM=y
+CONFIG_SYS_I2C_EEPROM_ADDR=0x50
+CONFIG_SYS_I2C_EEPROM_BUS=0
+CONFIG_SYS_I2C_EEPROM_ADDR_LEN=1
+
diff --git a/configs/vk-d184280e_1-emmc_defconfig b/configs/vk-d184280e_1-emmc_defconfig
new file mode 100644
index 0000000000..90130c29b5
--- /dev/null
+++ b/configs/vk-d184280e_1-emmc_defconfig
@@ -0,0 +1,122 @@
+CONFIG_USB_GADGET=y
+CONFIG_USB_RENESAS_USBHS=y
+CONFIG_USB_FUNCTION_FASTBOOT=y
+CONFIG_FASTBOOT_BUF_ADDR=0x4D000000
+CONFIG_FASTBOOT_BUF_SIZE=0x8000000
+CONFIG_FASTBOOT_USB_DEV=1
+CONFIG_FASTBOOT_MMC_BOOT_SUPPORT=y
+CONFIG_FASTBOOT_MMC_BOOT1_NAME="mmc0boot0"
+CONFIG_FASTBOOT_MMC_BOOT2_NAME="mmc0boot1"
+CONFIG_FASTBOOT_MMC_USER_SUPPORT=y
+CONFIG_FASTBOOT_MMC_USER_NAME="mmc0"
+CONFIG_FASTBOOT_GPT_NAME="gpt"
+CONFIG_FASTBOOT_MBR_NAME="mbr"
+CONFIG_FASTBOOT_FLASH=y
+#On RZ/G2L 0 is eMMC - 1 is SDCard.
+CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_USB_GADGET_MANUFACTURER="Renesas"
+CONFIG_USB_GADGET_VENDOR_NUM=0x18D1
+CONFIG_USB_GADGET_PRODUCT_NUM=0x4E23
+CONFIG_CMD_FASTBOOT=y
+CONFIG_USB_FUNCTION_MASS_STORAGE=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_ARM=y
+CONFIG_ARCH_CPU_INIT=y
+CONFIG_ARCH_RMOBILE=y
+CONFIG_SYS_TEXT_BASE=0x50000000
+CONFIG_DM_GPIO=y
+CONFIG_RCAR_GEN3=y
+CONFIG_R9A07G044C=y
+CONFIG_TARGET_VK_D184280E_1=y
+CONFIG_SPL=n
+CONFIG_DEFAULT_DEVICE_TREE="vk-d184280e-1"
+CONFIG_SMBIOS_PRODUCT_NAME=""
+# CONFIG_ANDROID_BOOT_IMAGE is not set
+CONFIG_FIT=y
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="rw rootwait earlycon root=/dev/mmcblk0p1 ${extrabootargs}"
+CONFIG_SUPPORT_RAW_INITRD=y
+CONFIG_DEFAULT_FDT_FILE="vk-d184280e-1.dtb"
+CONFIG_VERSION_VARIABLE=y
+CONFIG_CMD_CM33=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_OF_CONTROL=y
+CONFIG_OF_LIST="vk-d184280e-1"
+CONFIG_MULTI_DTB_FIT_LZO=y
+CONFIG_MULTI_DTB_FIT_USER_DEFINED_AREA=y
+CONFIG_ENV_OVERWRITE=y
+#
+CONFIG_ENV_IS_IN_MMC=y
+CONFIG_SYS_MMC_ENV_DEV=0
+CONFIG_SYS_MMC_ENV_PART=1
+CONFIG_ENV_SIZE=0x20000
+CONFIG_ENV_OFFSET=0xFFFE0000
+#
+CONFIG_SYS_RELOC_GD_ENV_ADDR=y
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_REGMAP=y
+CONFIG_SYSCON=y
+CONFIG_CLK=y
+CONFIG_CLK_RENESAS=y
+CONFIG_CLK_R9A07G044L=y
+CONFIG_UDP_FUNCTION_FASTBOOT=y
+#CONFIG_FASTBOOT_BUF_ADDR=0x82000000
+#CONFIG_FASTBOOT_FLASH=y
+#CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_RCAR_GPIO=y
+CONFIG_RZG2L_GPIO=y
+CONFIG_DM=y
+CONFIG_DM_I2C=y
+CONFIG_MISC=y
+CONFIG_SYS_I2C_RCAR_IIC=y
+CONFIG_SYS_I2C_RZG2L_RIIC=y
+CONFIG_SH_SDHI=y
+CONFIG_BITBANGMII=y
+CONFIG_PHY_REALTEK=y
+CONFIG_DM_ETH=y
+CONFIG_RENESAS_RAVB=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_PCI_RCAR_GEN3=y
+CONFIG_PINCTRL_PFC_RZG2L=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_SCIF_CONSOLE=y
+CONFIG_TEE=y
+CONFIG_OPTEE=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_GENERIC=y
+CONFIG_USB_STORAGE=y
+CONFIG_OF_LIBFDT_OVERLAY=y
+CONFIG_SMBIOS_MANUFACTURER=""
+CONFIG_WDT=y
+CONFIG_RENESAS_RZG2LWDT=y
+CONFIG_CMD_WDT=y
+CONFIG_BOARD_LATE_INIT=y
+CONFIG_CMD_EEPROM=y
+CONFIG_I2C_SET_DEFAULT_BUS_NUM=y
+CONFIG_I2C_DEFAULT_BUS_NUMBER=0
+CONFIG_I2C_EEPROM=y
+CONFIG_SYS_I2C_EEPROM_ADDR=0x50
+CONFIG_SYS_I2C_EEPROM_BUS=0
+CONFIG_SYS_I2C_EEPROM_ADDR_LEN=1
+
diff --git a/configs/vkcmg2lc-emmc_defconfig b/configs/vkcmg2lc-emmc_defconfig
new file mode 100644
index 0000000000..9211a6f4a9
--- /dev/null
+++ b/configs/vkcmg2lc-emmc_defconfig
@@ -0,0 +1,135 @@
+CONFIG_USB_GADGET=y
+CONFIG_USB_RENESAS_USBHS=y
+CONFIG_USB_FUNCTION_FASTBOOT=y
+CONFIG_FASTBOOT_BUF_ADDR=0x4D000000
+CONFIG_FASTBOOT_BUF_SIZE=0x8000000
+CONFIG_FASTBOOT_USB_DEV=1
+CONFIG_FASTBOOT_MMC_BOOT_SUPPORT=y
+CONFIG_FASTBOOT_MMC_BOOT1_NAME="mmc0boot0"
+CONFIG_FASTBOOT_MMC_BOOT2_NAME="mmc0boot1"
+CONFIG_FASTBOOT_MMC_USER_SUPPORT=y
+CONFIG_FASTBOOT_MMC_USER_NAME="mmc0"
+CONFIG_FASTBOOT_GPT_NAME="gpt"
+CONFIG_FASTBOOT_MBR_NAME="mbr"
+CONFIG_FASTBOOT_FLASH=y
+#On RZ/G2L 0 is eMMC - 1 is SDCard.
+CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_USB_GADGET_MANUFACTURER="Renesas"
+CONFIG_USB_GADGET_VENDOR_NUM=0x18D1
+CONFIG_USB_GADGET_PRODUCT_NUM=0x4E23
+CONFIG_CMD_FASTBOOT=y
+CONFIG_USB_FUNCTION_MASS_STORAGE=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_ARM=y
+CONFIG_ARCH_CPU_INIT=y
+CONFIG_ARCH_RMOBILE=y
+CONFIG_SYS_TEXT_BASE=0x50000000
+CONFIG_DM_GPIO=y
+CONFIG_RCAR_GEN3=y
+CONFIG_R9A07G044C=y
+CONFIG_TARGET_VKCMG2LC=y
+CONFIG_SPL=n
+CONFIG_DEFAULT_DEVICE_TREE="vkcmg2lc"
+CONFIG_SMBIOS_PRODUCT_NAME=""
+# CONFIG_ANDROID_BOOT_IMAGE is not set
+CONFIG_FIT=y
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="rw rootwait earlycon root=/dev/mmcblk0p1 ${extrabootargs}"
+CONFIG_SUPPORT_RAW_INITRD=y
+CONFIG_DEFAULT_FDT_FILE="vkcmg2lc.dtb"
+CONFIG_VERSION_VARIABLE=y
+CONFIG_CMD_CM33=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_OF_CONTROL=y
+CONFIG_OF_LIST="vkcmg2lc"
+CONFIG_MULTI_DTB_FIT_LZO=y
+CONFIG_MULTI_DTB_FIT_USER_DEFINED_AREA=y
+CONFIG_ENV_OVERWRITE=y
+#
+CONFIG_ENV_IS_IN_MMC=y
+CONFIG_SYS_MMC_ENV_DEV=0
+CONFIG_SYS_MMC_ENV_PART=1
+CONFIG_ENV_SIZE=0x20000
+CONFIG_ENV_OFFSET=0xFFFE0000
+#
+CONFIG_SYS_RELOC_GD_ENV_ADDR=y
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_REGMAP=y
+CONFIG_SYSCON=y
+CONFIG_CLK=y
+CONFIG_CLK_RENESAS=y
+CONFIG_CLK_R9A07G044L=y
+CONFIG_UDP_FUNCTION_FASTBOOT=y
+#CONFIG_FASTBOOT_BUF_ADDR=0x82000000
+#CONFIG_FASTBOOT_FLASH=y
+#CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_RCAR_GPIO=y
+CONFIG_RZG2L_GPIO=y
+CONFIG_DM=y
+CONFIG_DM_I2C=y
+CONFIG_MISC=y
+CONFIG_SYS_I2C_RCAR_IIC=y
+CONFIG_SYS_I2C_RZG2L_RIIC=y
+CONFIG_SH_SDHI=y
+CONFIG_BITBANGMII=y
+CONFIG_PHY_REALTEK=y
+CONFIG_DM_ETH=y
+CONFIG_RENESAS_RAVB=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_PCI_RCAR_GEN3=y
+CONFIG_PINCTRL_PFC_RZG2L=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_SCIF_CONSOLE=y
+CONFIG_TEE=y
+CONFIG_OPTEE=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_GENERIC=y
+CONFIG_USB_STORAGE=y
+CONFIG_OF_LIBFDT_OVERLAY=y
+CONFIG_SMBIOS_MANUFACTURER=""
+CONFIG_WDT=y
+CONFIG_RENESAS_RZG2LWDT=y
+CONFIG_CMD_WDT=y
+CONFIG_BOARD_LATE_INIT=y
+CONFIG_CMD_EEPROM=y
+CONFIG_I2C_SET_DEFAULT_BUS_NUM=y
+CONFIG_I2C_DEFAULT_BUS_NUMBER=0
+CONFIG_I2C_EEPROM=y
+CONFIG_SYS_I2C_EEPROM_ADDR=0x50
+CONFIG_SYS_I2C_EEPROM_BUS=0
+CONFIG_SYS_I2C_EEPROM_ADDR_LEN=1
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_BAR=y
+CONFIG_SPI_FLASH_USE_4K_SECTORS=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_RENESAS_RPC_SPI=y
+CONFIG_CMD_SF=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_PCA953X=y
+CONFIG_DM_PCA953X=y
+CONFIG_CMD_PCA953X=y
+CONFIG_SYS_I2C_PCA953X_ADDR=0x70
+CONFIG_SYS_I2C_PCA953X_WIDTH=8
diff --git a/configs/vkcmg2lc-qspi_defconfig b/configs/vkcmg2lc-qspi_defconfig
new file mode 100644
index 0000000000..b25f357473
--- /dev/null
+++ b/configs/vkcmg2lc-qspi_defconfig
@@ -0,0 +1,134 @@
+CONFIG_USB_GADGET=y
+CONFIG_USB_RENESAS_USBHS=y
+CONFIG_USB_FUNCTION_FASTBOOT=y
+CONFIG_FASTBOOT_BUF_ADDR=0x4D000000
+CONFIG_FASTBOOT_BUF_SIZE=0x8000000
+CONFIG_FASTBOOT_USB_DEV=1
+CONFIG_FASTBOOT_MMC_BOOT_SUPPORT=y
+CONFIG_FASTBOOT_MMC_BOOT1_NAME="mmc0boot0"
+CONFIG_FASTBOOT_MMC_BOOT2_NAME="mmc0boot1"
+CONFIG_FASTBOOT_MMC_USER_SUPPORT=y
+CONFIG_FASTBOOT_MMC_USER_NAME="mmc0"
+CONFIG_FASTBOOT_GPT_NAME="gpt"
+CONFIG_FASTBOOT_MBR_NAME="mbr"
+CONFIG_FASTBOOT_FLASH=y
+#On RZ/G2L 0 is eMMC - 1 is SDCard.
+CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_USB_GADGET_MANUFACTURER="Renesas"
+CONFIG_USB_GADGET_VENDOR_NUM=0x18D1
+CONFIG_USB_GADGET_PRODUCT_NUM=0x4E23
+CONFIG_CMD_FASTBOOT=y
+CONFIG_USB_FUNCTION_MASS_STORAGE=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_ARM=y
+CONFIG_ARCH_CPU_INIT=y
+CONFIG_ARCH_RMOBILE=y
+CONFIG_SYS_TEXT_BASE=0x50000000
+CONFIG_DM_GPIO=y
+CONFIG_RCAR_GEN3=y
+CONFIG_R9A07G044C=y
+CONFIG_TARGET_VKCMG2LC=y
+CONFIG_SPL=n
+CONFIG_DEFAULT_DEVICE_TREE="vkcmg2lc"
+CONFIG_SMBIOS_PRODUCT_NAME=""
+# CONFIG_ANDROID_BOOT_IMAGE is not set
+CONFIG_FIT=y
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="rw rootwait earlycon root=/dev/mmcblk1p1 ${extrabootargs}"
+CONFIG_SUPPORT_RAW_INITRD=y
+CONFIG_DEFAULT_FDT_FILE="vkcmg2lc.dtb"
+CONFIG_VERSION_VARIABLE=y
+CONFIG_CMD_CM33=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_OF_CONTROL=y
+CONFIG_OF_LIST="vkcmg2lc"
+CONFIG_MULTI_DTB_FIT_LZO=y
+CONFIG_MULTI_DTB_FIT_USER_DEFINED_AREA=y
+CONFIG_ENV_OVERWRITE=y
+#
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_ENV_SIZE=0x20000
+CONFIG_ENV_OFFSET=0x1E0000
+CONFIG_ENV_SECT_SIZE=0x1000
+#
+CONFIG_SYS_RELOC_GD_ENV_ADDR=y
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_REGMAP=y
+CONFIG_SYSCON=y
+CONFIG_CLK=y
+CONFIG_CLK_RENESAS=y
+CONFIG_CLK_R9A07G044L=y
+CONFIG_UDP_FUNCTION_FASTBOOT=y
+#CONFIG_FASTBOOT_BUF_ADDR=0x82000000
+#CONFIG_FASTBOOT_FLASH=y
+#CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_RCAR_GPIO=y
+CONFIG_RZG2L_GPIO=y
+CONFIG_DM=y
+CONFIG_DM_I2C=y
+CONFIG_MISC=y
+CONFIG_SYS_I2C_RCAR_IIC=y
+CONFIG_SYS_I2C_RZG2L_RIIC=y
+CONFIG_SH_SDHI=y
+CONFIG_BITBANGMII=y
+CONFIG_PHY_REALTEK=y
+CONFIG_DM_ETH=y
+CONFIG_RENESAS_RAVB=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_PCI_RCAR_GEN3=y
+CONFIG_PINCTRL_PFC_RZG2L=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_SCIF_CONSOLE=y
+CONFIG_TEE=y
+CONFIG_OPTEE=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_GENERIC=y
+CONFIG_USB_STORAGE=y
+CONFIG_OF_LIBFDT_OVERLAY=y
+CONFIG_SMBIOS_MANUFACTURER=""
+CONFIG_WDT=y
+CONFIG_RENESAS_RZG2LWDT=y
+CONFIG_CMD_WDT=y
+CONFIG_BOARD_LATE_INIT=y
+CONFIG_CMD_EEPROM=y
+CONFIG_I2C_SET_DEFAULT_BUS_NUM=y
+CONFIG_I2C_DEFAULT_BUS_NUMBER=0
+CONFIG_I2C_EEPROM=y
+CONFIG_SYS_I2C_EEPROM_ADDR=0x50
+CONFIG_SYS_I2C_EEPROM_BUS=0
+CONFIG_SYS_I2C_EEPROM_ADDR_LEN=1
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_BAR=y
+CONFIG_SPI_FLASH_USE_4K_SECTORS=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_RENESAS_RPC_SPI=y
+CONFIG_CMD_SF=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_PCA953X=y
+CONFIG_DM_PCA953X=y
+CONFIG_CMD_PCA953X=y
+CONFIG_SYS_I2C_PCA953X_ADDR=0x70
+CONFIG_SYS_I2C_PCA953X_WIDTH=8
diff --git a/configs/vkcmg2lc_1-emmc_defconfig b/configs/vkcmg2lc_1-emmc_defconfig
new file mode 100644
index 0000000000..9c7dce0839
--- /dev/null
+++ b/configs/vkcmg2lc_1-emmc_defconfig
@@ -0,0 +1,135 @@
+CONFIG_USB_GADGET=y
+CONFIG_USB_RENESAS_USBHS=y
+CONFIG_USB_FUNCTION_FASTBOOT=y
+CONFIG_FASTBOOT_BUF_ADDR=0x4D000000
+CONFIG_FASTBOOT_BUF_SIZE=0x8000000
+CONFIG_FASTBOOT_USB_DEV=1
+CONFIG_FASTBOOT_MMC_BOOT_SUPPORT=y
+CONFIG_FASTBOOT_MMC_BOOT1_NAME="mmc0boot0"
+CONFIG_FASTBOOT_MMC_BOOT2_NAME="mmc0boot1"
+CONFIG_FASTBOOT_MMC_USER_SUPPORT=y
+CONFIG_FASTBOOT_MMC_USER_NAME="mmc0"
+CONFIG_FASTBOOT_GPT_NAME="gpt"
+CONFIG_FASTBOOT_MBR_NAME="mbr"
+CONFIG_FASTBOOT_FLASH=y
+#On RZ/G2L 0 is eMMC - 1 is SDCard.
+CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_USB_GADGET_MANUFACTURER="Renesas"
+CONFIG_USB_GADGET_VENDOR_NUM=0x18D1
+CONFIG_USB_GADGET_PRODUCT_NUM=0x4E23
+CONFIG_CMD_FASTBOOT=y
+CONFIG_USB_FUNCTION_MASS_STORAGE=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_ARM=y
+CONFIG_ARCH_CPU_INIT=y
+CONFIG_ARCH_RMOBILE=y
+CONFIG_SYS_TEXT_BASE=0x50000000
+CONFIG_DM_GPIO=y
+CONFIG_RCAR_GEN3=y
+CONFIG_R9A07G044C=y
+CONFIG_TARGET_VKCMG2LC_1=y
+CONFIG_SPL=n
+CONFIG_DEFAULT_DEVICE_TREE="vkcmg2lc_1"
+CONFIG_SMBIOS_PRODUCT_NAME=""
+# CONFIG_ANDROID_BOOT_IMAGE is not set
+CONFIG_FIT=y
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="rw rootwait earlycon root=/dev/mmcblk0p1 ${extrabootargs}"
+CONFIG_SUPPORT_RAW_INITRD=y
+CONFIG_DEFAULT_FDT_FILE="vkcmg2lc_1.dtb"
+CONFIG_VERSION_VARIABLE=y
+CONFIG_CMD_CM33=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_OF_CONTROL=y
+CONFIG_OF_LIST="vkcmg2lc_1"
+CONFIG_MULTI_DTB_FIT_LZO=y
+CONFIG_MULTI_DTB_FIT_USER_DEFINED_AREA=y
+CONFIG_ENV_OVERWRITE=y
+#
+CONFIG_ENV_IS_IN_MMC=y
+CONFIG_SYS_MMC_ENV_DEV=0
+CONFIG_SYS_MMC_ENV_PART=1
+CONFIG_ENV_SIZE=0x20000
+CONFIG_ENV_OFFSET=0xFFFE0000
+#
+CONFIG_SYS_RELOC_GD_ENV_ADDR=y
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_REGMAP=y
+CONFIG_SYSCON=y
+CONFIG_CLK=y
+CONFIG_CLK_RENESAS=y
+CONFIG_CLK_R9A07G044L=y
+CONFIG_UDP_FUNCTION_FASTBOOT=y
+#CONFIG_FASTBOOT_BUF_ADDR=0x82000000
+#CONFIG_FASTBOOT_FLASH=y
+#CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_RCAR_GPIO=y
+CONFIG_RZG2L_GPIO=y
+CONFIG_DM=y
+CONFIG_DM_I2C=y
+CONFIG_MISC=y
+CONFIG_SYS_I2C_RCAR_IIC=y
+CONFIG_SYS_I2C_RZG2L_RIIC=y
+CONFIG_SH_SDHI=y
+CONFIG_BITBANGMII=y
+CONFIG_PHY_REALTEK=y
+CONFIG_DM_ETH=y
+CONFIG_RENESAS_RAVB=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_PCI_RCAR_GEN3=y
+CONFIG_PINCTRL_PFC_RZG2L=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_SCIF_CONSOLE=y
+CONFIG_TEE=y
+CONFIG_OPTEE=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_GENERIC=y
+CONFIG_USB_STORAGE=y
+CONFIG_OF_LIBFDT_OVERLAY=y
+CONFIG_SMBIOS_MANUFACTURER=""
+CONFIG_WDT=y
+CONFIG_RENESAS_RZG2LWDT=y
+CONFIG_CMD_WDT=y
+CONFIG_BOARD_LATE_INIT=y
+CONFIG_CMD_EEPROM=y
+CONFIG_I2C_SET_DEFAULT_BUS_NUM=y
+CONFIG_I2C_DEFAULT_BUS_NUMBER=0
+CONFIG_I2C_EEPROM=y
+CONFIG_SYS_I2C_EEPROM_ADDR=0x50
+CONFIG_SYS_I2C_EEPROM_BUS=0
+CONFIG_SYS_I2C_EEPROM_ADDR_LEN=1
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_BAR=y
+CONFIG_SPI_FLASH_USE_4K_SECTORS=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_RENESAS_RPC_SPI=y
+CONFIG_CMD_SF=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_PCA953X=y
+CONFIG_DM_PCA953X=y
+CONFIG_CMD_PCA953X=y
+CONFIG_SYS_I2C_PCA953X_ADDR=0x70
+CONFIG_SYS_I2C_PCA953X_WIDTH=8
diff --git a/configs/vkcmv2l-emmc_defconfig b/configs/vkcmv2l-emmc_defconfig
new file mode 100644
index 0000000000..614c858e93
--- /dev/null
+++ b/configs/vkcmv2l-emmc_defconfig
@@ -0,0 +1,130 @@
+CONFIG_USB_GADGET=y
+CONFIG_USB_RENESAS_USBHS=y
+CONFIG_USB_FUNCTION_FASTBOOT=y
+CONFIG_FASTBOOT_BUF_ADDR=0x4D000000
+CONFIG_FASTBOOT_BUF_SIZE=0x8000000
+CONFIG_FASTBOOT_USB_DEV=1
+CONFIG_FASTBOOT_MMC_BOOT_SUPPORT=y
+CONFIG_FASTBOOT_MMC_BOOT1_NAME="mmc0boot0"
+CONFIG_FASTBOOT_MMC_BOOT2_NAME="mmc0boot1"
+CONFIG_FASTBOOT_MMC_USER_SUPPORT=y
+CONFIG_FASTBOOT_MMC_USER_NAME="mmc0"
+CONFIG_FASTBOOT_GPT_NAME="gpt"
+CONFIG_FASTBOOT_MBR_NAME="mbr"
+CONFIG_FASTBOOT_FLASH=y
+#On RZ/G2L 0 is eMMC - 1 is SDCard.
+CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_USB_GADGET_MANUFACTURER="Renesas"
+CONFIG_USB_GADGET_VENDOR_NUM=0x18D1
+CONFIG_USB_GADGET_PRODUCT_NUM=0x4E23
+CONFIG_CMD_FASTBOOT=y
+CONFIG_USB_FUNCTION_MASS_STORAGE=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_ARM=y
+CONFIG_ARCH_CPU_INIT=y
+CONFIG_ARCH_RMOBILE=y
+CONFIG_SYS_TEXT_BASE=0x50000000
+CONFIG_DM_GPIO=y
+CONFIG_RCAR_GEN3=y
+CONFIG_R9A07G054L=y
+CONFIG_TARGET_VKCMV2L=y
+CONFIG_SPL=n
+CONFIG_DEFAULT_DEVICE_TREE="vkcmv2l"
+CONFIG_SMBIOS_PRODUCT_NAME=""
+# CONFIG_ANDROID_BOOT_IMAGE is not set
+CONFIG_FIT=y
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="rw rootwait earlycon root=/dev/mmcblk0p1 ${extrabootargs}"
+CONFIG_SUPPORT_RAW_INITRD=y
+CONFIG_DEFAULT_FDT_FILE="vkcmv2l.dtb"
+CONFIG_VERSION_VARIABLE=y
+CONFIG_CMD_CM33=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_OF_CONTROL=y
+CONFIG_OF_LIST="vkcmv2l"
+CONFIG_MULTI_DTB_FIT_LZO=y
+CONFIG_MULTI_DTB_FIT_USER_DEFINED_AREA=y
+CONFIG_ENV_OVERWRITE=y
+#
+CONFIG_ENV_IS_IN_MMC=y
+CONFIG_SYS_MMC_ENV_DEV=0
+CONFIG_SYS_MMC_ENV_PART=1
+CONFIG_ENV_SIZE=0x20000
+CONFIG_ENV_OFFSET=0xFFFE0000
+#
+CONFIG_SYS_RELOC_GD_ENV_ADDR=y
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_REGMAP=y
+CONFIG_SYSCON=y
+CONFIG_CLK=y
+CONFIG_CLK_RENESAS=y
+CONFIG_CLK_R9A07G054L=y
+CONFIG_UDP_FUNCTION_FASTBOOT=y
+#CONFIG_FASTBOOT_BUF_ADDR=0x82000000
+#CONFIG_FASTBOOT_FLASH=y
+#CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_RCAR_GPIO=y
+CONFIG_RZG2L_GPIO=y
+CONFIG_DM=y
+CONFIG_DM_I2C=y
+CONFIG_MISC=y
+CONFIG_SYS_I2C_RCAR_IIC=y
+CONFIG_SYS_I2C_RZG2L_RIIC=y
+CONFIG_SH_SDHI=y
+CONFIG_BITBANGMII=y
+CONFIG_PHY_REALTEK=y
+CONFIG_DM_ETH=y
+CONFIG_RENESAS_RAVB=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_PCI_RCAR_GEN3=y
+CONFIG_PINCTRL_PFC_RZG2L=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_SCIF_CONSOLE=y
+CONFIG_TEE=y
+CONFIG_OPTEE=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_GENERIC=y
+CONFIG_USB_STORAGE=y
+CONFIG_OF_LIBFDT_OVERLAY=y
+CONFIG_SMBIOS_MANUFACTURER=""
+CONFIG_WDT=y
+CONFIG_RENESAS_RZG2LWDT=y
+CONFIG_CMD_WDT=y
+CONFIG_BOARD_LATE_INIT=y
+CONFIG_CMD_EEPROM=y
+CONFIG_I2C_SET_DEFAULT_BUS_NUM=y
+CONFIG_I2C_DEFAULT_BUS_NUMBER=3
+CONFIG_I2C_EEPROM=y
+CONFIG_SYS_I2C_EEPROM_ADDR=0x50
+CONFIG_SYS_I2C_EEPROM_BUS=3
+CONFIG_SYS_I2C_EEPROM_ADDR_LEN=1
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_BAR=y
+CONFIG_SPI_FLASH_USE_4K_SECTORS=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_RENESAS_RPC_SPI=y
+CONFIG_CMD_SF=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_DM_SPI_FLASH=y
diff --git a/configs/vkcmv2l-qspi_defconfig b/configs/vkcmv2l-qspi_defconfig
new file mode 100644
index 0000000000..f61ee81c5e
--- /dev/null
+++ b/configs/vkcmv2l-qspi_defconfig
@@ -0,0 +1,129 @@
+CONFIG_USB_GADGET=y
+CONFIG_USB_RENESAS_USBHS=y
+CONFIG_USB_FUNCTION_FASTBOOT=y
+CONFIG_FASTBOOT_BUF_ADDR=0x4D000000
+CONFIG_FASTBOOT_BUF_SIZE=0x8000000
+CONFIG_FASTBOOT_USB_DEV=1
+CONFIG_FASTBOOT_MMC_BOOT_SUPPORT=y
+CONFIG_FASTBOOT_MMC_BOOT1_NAME="mmc0boot0"
+CONFIG_FASTBOOT_MMC_BOOT2_NAME="mmc0boot1"
+CONFIG_FASTBOOT_MMC_USER_SUPPORT=y
+CONFIG_FASTBOOT_MMC_USER_NAME="mmc0"
+CONFIG_FASTBOOT_GPT_NAME="gpt"
+CONFIG_FASTBOOT_MBR_NAME="mbr"
+CONFIG_FASTBOOT_FLASH=y
+#On RZ/G2L 0 is eMMC - 1 is SDCard.
+CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_USB_GADGET_MANUFACTURER="Renesas"
+CONFIG_USB_GADGET_VENDOR_NUM=0x18D1
+CONFIG_USB_GADGET_PRODUCT_NUM=0x4E23
+CONFIG_CMD_FASTBOOT=y
+CONFIG_USB_FUNCTION_MASS_STORAGE=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_ARM=y
+CONFIG_ARCH_CPU_INIT=y
+CONFIG_ARCH_RMOBILE=y
+CONFIG_SYS_TEXT_BASE=0x50000000
+CONFIG_DM_GPIO=y
+CONFIG_RCAR_GEN3=y
+CONFIG_R9A07G054L=y
+CONFIG_TARGET_VKCMV2L=y
+CONFIG_SPL=n
+CONFIG_DEFAULT_DEVICE_TREE="vkcmv2l"
+CONFIG_SMBIOS_PRODUCT_NAME=""
+# CONFIG_ANDROID_BOOT_IMAGE is not set
+CONFIG_FIT=y
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="rw rootwait earlycon root=/dev/mmcblk0p1 ${extrabootargs}"
+CONFIG_SUPPORT_RAW_INITRD=y
+CONFIG_DEFAULT_FDT_FILE="vkcmv2l.dtb"
+CONFIG_VERSION_VARIABLE=y
+CONFIG_CMD_CM33=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_OF_CONTROL=y
+CONFIG_OF_LIST="vkcmv2l"
+CONFIG_MULTI_DTB_FIT_LZO=y
+CONFIG_MULTI_DTB_FIT_USER_DEFINED_AREA=y
+CONFIG_ENV_OVERWRITE=y
+#
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_ENV_SIZE=0x20000
+CONFIG_ENV_OFFSET=0x1E0000
+CONFIG_ENV_SECT_SIZE=0x1000
+#
+CONFIG_SYS_RELOC_GD_ENV_ADDR=y
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_REGMAP=y
+CONFIG_SYSCON=y
+CONFIG_CLK=y
+CONFIG_CLK_RENESAS=y
+CONFIG_CLK_R9A07G054L=y
+CONFIG_UDP_FUNCTION_FASTBOOT=y
+#CONFIG_FASTBOOT_BUF_ADDR=0x82000000
+#CONFIG_FASTBOOT_FLASH=y
+#CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_RCAR_GPIO=y
+CONFIG_RZG2L_GPIO=y
+CONFIG_DM=y
+CONFIG_DM_I2C=y
+CONFIG_MISC=y
+CONFIG_SYS_I2C_RCAR_IIC=y
+CONFIG_SYS_I2C_RZG2L_RIIC=y
+CONFIG_SH_SDHI=y
+CONFIG_BITBANGMII=y
+CONFIG_PHY_REALTEK=y
+CONFIG_DM_ETH=y
+CONFIG_RENESAS_RAVB=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_PCI_RCAR_GEN3=y
+CONFIG_PINCTRL_PFC_RZG2L=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_SCIF_CONSOLE=y
+CONFIG_TEE=y
+CONFIG_OPTEE=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_GENERIC=y
+CONFIG_USB_STORAGE=y
+CONFIG_OF_LIBFDT_OVERLAY=y
+CONFIG_SMBIOS_MANUFACTURER=""
+CONFIG_WDT=y
+CONFIG_RENESAS_RZG2LWDT=y
+CONFIG_CMD_WDT=y
+CONFIG_BOARD_LATE_INIT=y
+#CONFIG_CMD_EEPROM=y
+CONFIG_I2C_SET_DEFAULT_BUS_NUM=y
+CONFIG_I2C_DEFAULT_BUS_NUMBER=3
+CONFIG_I2C_EEPROM=y
+CONFIG_SYS_I2C_EEPROM_ADDR=0x50
+CONFIG_SYS_I2C_EEPROM_BUS=3
+CONFIG_SYS_I2C_EEPROM_ADDR_LEN=1
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_BAR=y
+CONFIG_SPI_FLASH_USE_4K_SECTORS=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_RENESAS_RPC_SPI=y
+CONFIG_CMD_SF=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_DM_SPI_FLASH=y
diff --git a/configs/vkrzg2l-emmc_defconfig b/configs/vkrzg2l-emmc_defconfig
new file mode 100644
index 0000000000..aad4532c62
--- /dev/null
+++ b/configs/vkrzg2l-emmc_defconfig
@@ -0,0 +1,133 @@
+CONFIG_USB_GADGET=y
+CONFIG_USB_RENESAS_USBHS=y
+CONFIG_USB_FUNCTION_FASTBOOT=y
+CONFIG_FASTBOOT_BUF_ADDR=0x4D000000
+CONFIG_FASTBOOT_BUF_SIZE=0x8000000
+CONFIG_FASTBOOT_USB_DEV=1
+CONFIG_FASTBOOT_MMC_BOOT_SUPPORT=y
+CONFIG_FASTBOOT_MMC_BOOT1_NAME="mmc0boot0"
+CONFIG_FASTBOOT_MMC_BOOT2_NAME="mmc0boot1"
+CONFIG_FASTBOOT_MMC_USER_SUPPORT=y
+CONFIG_FASTBOOT_MMC_USER_NAME="mmc0"
+CONFIG_FASTBOOT_GPT_NAME="gpt"
+CONFIG_FASTBOOT_MBR_NAME="mbr"
+CONFIG_FASTBOOT_FLASH=y
+#On RZ/G2L 0 is eMMC - 1 is SDCard.
+CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_USB_GADGET_MANUFACTURER="Renesas"
+CONFIG_USB_GADGET_VENDOR_NUM=0x18D1
+CONFIG_USB_GADGET_PRODUCT_NUM=0x4E23
+CONFIG_CMD_FASTBOOT=y
+CONFIG_USB_FUNCTION_MASS_STORAGE=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_ARM=y
+CONFIG_ARCH_CPU_INIT=y
+CONFIG_ARCH_RMOBILE=y
+CONFIG_SYS_TEXT_BASE=0x50000000
+CONFIG_DM_GPIO=y
+CONFIG_RCAR_GEN3=y
+CONFIG_R9A07G044L=y
+CONFIG_TARGET_VKRZG2L=y
+CONFIG_SPL=n
+CONFIG_DEFAULT_DEVICE_TREE="vkrzg2l"
+CONFIG_SMBIOS_PRODUCT_NAME=""
+# CONFIG_ANDROID_BOOT_IMAGE is not set
+CONFIG_FIT=y
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="rw rootwait earlycon root=/dev/mmcblk0p1 ${extrabootargs}"
+CONFIG_SUPPORT_RAW_INITRD=y
+CONFIG_DEFAULT_FDT_FILE="vkrzg2l.dtb"
+CONFIG_VERSION_VARIABLE=y
+CONFIG_CMD_CM33=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_OF_CONTROL=y
+CONFIG_OF_LIST="vkrzg2l"
+CONFIG_MULTI_DTB_FIT_LZO=y
+CONFIG_MULTI_DTB_FIT_USER_DEFINED_AREA=y
+CONFIG_ENV_OVERWRITE=y
+#
+CONFIG_ENV_IS_IN_MMC=y
+CONFIG_SYS_MMC_ENV_DEV=0
+CONFIG_SYS_MMC_ENV_PART=1
+CONFIG_ENV_SIZE=0x20000
+CONFIG_ENV_OFFSET=0xFFFE0000
+#
+CONFIG_SYS_RELOC_GD_ENV_ADDR=y
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_REGMAP=y
+CONFIG_SYSCON=y
+CONFIG_CLK=y
+CONFIG_CLK_RENESAS=y
+CONFIG_CLK_R9A07G044L=y
+CONFIG_UDP_FUNCTION_FASTBOOT=y
+#CONFIG_FASTBOOT_BUF_ADDR=0x82000000
+#CONFIG_FASTBOOT_FLASH=y
+#CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_RCAR_GPIO=y
+CONFIG_RZG2L_GPIO=y
+CONFIG_DM=y
+CONFIG_DM_I2C=y
+CONFIG_MISC=y
+CONFIG_SYS_I2C_RCAR_IIC=y
+CONFIG_SYS_I2C_RZG2L_RIIC=y
+CONFIG_SH_SDHI=y
+CONFIG_BITBANGMII=y
+CONFIG_PHY_REALTEK=y
+CONFIG_DM_ETH=y
+CONFIG_RENESAS_RAVB=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_PCI_RCAR_GEN3=y
+CONFIG_PINCTRL_PFC_RZG2L=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_SCIF_CONSOLE=y
+CONFIG_TEE=y
+CONFIG_OPTEE=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_GENERIC=y
+CONFIG_USB_STORAGE=y
+CONFIG_OF_LIBFDT_OVERLAY=y
+CONFIG_SMBIOS_MANUFACTURER=""
+CONFIG_WDT=y
+CONFIG_RENESAS_RZG2LWDT=y
+CONFIG_CMD_WDT=y
+CONFIG_BOARD_LATE_INIT=y
+#CONFIG_CMD_EEPROM=y
+CONFIG_I2C_SET_DEFAULT_BUS_NUM=y
+CONFIG_I2C_DEFAULT_BUS_NUMBER=3
+#CONFIG_I2C_EEPROM=y
+#CONFIG_SYS_I2C_EEPROM_ADDR=0x50
+#CONFIG_SYS_I2C_EEPROM_BUS=3
+#CONFIG_SYS_I2C_EEPROM_ADDR_LEN=1
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_BAR=y
+CONFIG_SPI_FLASH_USE_4K_SECTORS=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_RENESAS_RPC_SPI=y
+CONFIG_CMD_SF=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_DM_SPI_FLASH=y
+#
+CONFIG_SYS_USB_DEV=0
+CONFIG_SYS_USB_IMG_LOAD_PART=1
diff --git a/configs/vkrzg2l-qspi_defconfig b/configs/vkrzg2l-qspi_defconfig
new file mode 100644
index 0000000000..138df625ad
--- /dev/null
+++ b/configs/vkrzg2l-qspi_defconfig
@@ -0,0 +1,129 @@
+CONFIG_USB_GADGET=y
+CONFIG_USB_RENESAS_USBHS=y
+CONFIG_USB_FUNCTION_FASTBOOT=y
+CONFIG_FASTBOOT_BUF_ADDR=0x4D000000
+CONFIG_FASTBOOT_BUF_SIZE=0x8000000
+CONFIG_FASTBOOT_USB_DEV=1
+CONFIG_FASTBOOT_MMC_BOOT_SUPPORT=y
+CONFIG_FASTBOOT_MMC_BOOT1_NAME="mmc0boot0"
+CONFIG_FASTBOOT_MMC_BOOT2_NAME="mmc0boot1"
+CONFIG_FASTBOOT_MMC_USER_SUPPORT=y
+CONFIG_FASTBOOT_MMC_USER_NAME="mmc0"
+CONFIG_FASTBOOT_GPT_NAME="gpt"
+CONFIG_FASTBOOT_MBR_NAME="mbr"
+CONFIG_FASTBOOT_FLASH=y
+#On RZ/G2L 0 is eMMC - 1 is SDCard.
+CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_USB_GADGET_MANUFACTURER="Renesas"
+CONFIG_USB_GADGET_VENDOR_NUM=0x18D1
+CONFIG_USB_GADGET_PRODUCT_NUM=0x4E23
+CONFIG_CMD_FASTBOOT=y
+CONFIG_USB_FUNCTION_MASS_STORAGE=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_ARM=y
+CONFIG_ARCH_CPU_INIT=y
+CONFIG_ARCH_RMOBILE=y
+CONFIG_SYS_TEXT_BASE=0x50000000
+CONFIG_DM_GPIO=y
+CONFIG_RCAR_GEN3=y
+CONFIG_R9A07G044L=y
+CONFIG_TARGET_VKRZG2L=y
+CONFIG_SPL=n
+CONFIG_DEFAULT_DEVICE_TREE="vkrzg2l"
+CONFIG_SMBIOS_PRODUCT_NAME=""
+# CONFIG_ANDROID_BOOT_IMAGE is not set
+CONFIG_FIT=y
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="rw rootwait earlycon root=/dev/mmcblk0p1 ${extrabootargs}"
+CONFIG_SUPPORT_RAW_INITRD=y
+CONFIG_DEFAULT_FDT_FILE="vkrzg2l.dtb"
+CONFIG_VERSION_VARIABLE=y
+CONFIG_CMD_CM33=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_OF_CONTROL=y
+CONFIG_OF_LIST="vkrzg2l"
+CONFIG_MULTI_DTB_FIT_LZO=y
+CONFIG_MULTI_DTB_FIT_USER_DEFINED_AREA=y
+CONFIG_ENV_OVERWRITE=y
+#
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_ENV_SIZE=0x20000
+CONFIG_ENV_OFFSET=0x1E0000
+CONFIG_ENV_SECT_SIZE=0x1000
+#
+CONFIG_SYS_RELOC_GD_ENV_ADDR=y
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_REGMAP=y
+CONFIG_SYSCON=y
+CONFIG_CLK=y
+CONFIG_CLK_RENESAS=y
+CONFIG_CLK_R9A07G044L=y
+CONFIG_UDP_FUNCTION_FASTBOOT=y
+#CONFIG_FASTBOOT_BUF_ADDR=0x82000000
+#CONFIG_FASTBOOT_FLASH=y
+#CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_RCAR_GPIO=y
+CONFIG_RZG2L_GPIO=y
+CONFIG_DM=y
+CONFIG_DM_I2C=y
+CONFIG_MISC=y
+CONFIG_SYS_I2C_RCAR_IIC=y
+CONFIG_SYS_I2C_RZG2L_RIIC=y
+CONFIG_SH_SDHI=y
+CONFIG_BITBANGMII=y
+CONFIG_PHY_REALTEK=y
+CONFIG_DM_ETH=y
+CONFIG_RENESAS_RAVB=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_PCI_RCAR_GEN3=y
+CONFIG_PINCTRL_PFC_RZG2L=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_SCIF_CONSOLE=y
+CONFIG_TEE=y
+CONFIG_OPTEE=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_GENERIC=y
+CONFIG_USB_STORAGE=y
+CONFIG_OF_LIBFDT_OVERLAY=y
+CONFIG_SMBIOS_MANUFACTURER=""
+CONFIG_WDT=y
+CONFIG_RENESAS_RZG2LWDT=y
+CONFIG_CMD_WDT=y
+CONFIG_BOARD_LATE_INIT=y
+#CONFIG_CMD_EEPROM=y
+CONFIG_I2C_SET_DEFAULT_BUS_NUM=y
+CONFIG_I2C_DEFAULT_BUS_NUMBER=3
+#CONFIG_I2C_EEPROM=y
+#CONFIG_SYS_I2C_EEPROM_ADDR=0x50
+#CONFIG_SYS_I2C_EEPROM_BUS=3
+#CONFIG_SYS_I2C_EEPROM_ADDR_LEN=1
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_BAR=y
+CONFIG_SPI_FLASH_USE_4K_SECTORS=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_RENESAS_RPC_SPI=y
+CONFIG_CMD_SF=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_DM_SPI_FLASH=y
diff --git a/configs/vkrzg2lc-emmc_defconfig b/configs/vkrzg2lc-emmc_defconfig
new file mode 100644
index 0000000000..c3baa4e45f
--- /dev/null
+++ b/configs/vkrzg2lc-emmc_defconfig
@@ -0,0 +1,130 @@
+CONFIG_USB_GADGET=y
+CONFIG_USB_RENESAS_USBHS=y
+CONFIG_USB_FUNCTION_FASTBOOT=y
+CONFIG_FASTBOOT_BUF_ADDR=0x4D000000
+CONFIG_FASTBOOT_BUF_SIZE=0x8000000
+CONFIG_FASTBOOT_USB_DEV=1
+CONFIG_FASTBOOT_MMC_BOOT_SUPPORT=y
+CONFIG_FASTBOOT_MMC_BOOT1_NAME="mmc0boot0"
+CONFIG_FASTBOOT_MMC_BOOT2_NAME="mmc0boot1"
+CONFIG_FASTBOOT_MMC_USER_SUPPORT=y
+CONFIG_FASTBOOT_MMC_USER_NAME="mmc0"
+CONFIG_FASTBOOT_GPT_NAME="gpt"
+CONFIG_FASTBOOT_MBR_NAME="mbr"
+CONFIG_FASTBOOT_FLASH=y
+#On RZ/G2L 0 is eMMC - 1 is SDCard.
+CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_USB_GADGET_MANUFACTURER="Renesas"
+CONFIG_USB_GADGET_VENDOR_NUM=0x18D1
+CONFIG_USB_GADGET_PRODUCT_NUM=0x4E23
+CONFIG_CMD_FASTBOOT=y
+CONFIG_USB_FUNCTION_MASS_STORAGE=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_ARM=y
+CONFIG_ARCH_CPU_INIT=y
+CONFIG_ARCH_RMOBILE=y
+CONFIG_SYS_TEXT_BASE=0x50000000
+CONFIG_DM_GPIO=y
+CONFIG_RCAR_GEN3=y
+CONFIG_R9A07G044C=y
+CONFIG_TARGET_VKRZG2LC=y
+CONFIG_SPL=n
+CONFIG_DEFAULT_DEVICE_TREE="vkrzg2lc"
+CONFIG_SMBIOS_PRODUCT_NAME=""
+# CONFIG_ANDROID_BOOT_IMAGE is not set
+CONFIG_FIT=y
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="rw rootwait earlycon root=/dev/mmcblk0p2 ${extrabootargs}"
+CONFIG_SUPPORT_RAW_INITRD=y
+CONFIG_DEFAULT_FDT_FILE="vkrzg2lc.dtb"
+CONFIG_VERSION_VARIABLE=y
+CONFIG_CMD_CM33=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_OF_CONTROL=y
+CONFIG_OF_LIST="vkrzg2lc"
+CONFIG_MULTI_DTB_FIT_LZO=y
+CONFIG_MULTI_DTB_FIT_USER_DEFINED_AREA=y
+CONFIG_ENV_OVERWRITE=y
+#
+CONFIG_ENV_IS_IN_MMC=y
+CONFIG_SYS_MMC_ENV_DEV=0
+CONFIG_SYS_MMC_ENV_PART=1
+CONFIG_ENV_SIZE=0x20000
+CONFIG_ENV_OFFSET=0xFFFE0000
+#
+CONFIG_SYS_RELOC_GD_ENV_ADDR=y
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_REGMAP=y
+CONFIG_SYSCON=y
+CONFIG_CLK=y
+CONFIG_CLK_RENESAS=y
+CONFIG_CLK_R9A07G044L=y
+CONFIG_UDP_FUNCTION_FASTBOOT=y
+#CONFIG_FASTBOOT_BUF_ADDR=0x82000000
+#CONFIG_FASTBOOT_FLASH=y
+#CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_RCAR_GPIO=y
+CONFIG_RZG2L_GPIO=y
+CONFIG_DM=y
+CONFIG_DM_I2C=y
+CONFIG_MISC=y
+CONFIG_SYS_I2C_RCAR_IIC=y
+CONFIG_SYS_I2C_RZG2L_RIIC=y
+CONFIG_SH_SDHI=y
+CONFIG_BITBANGMII=y
+CONFIG_PHY_REALTEK=y
+CONFIG_DM_ETH=y
+CONFIG_RENESAS_RAVB=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_PCI_RCAR_GEN3=y
+CONFIG_PINCTRL_PFC_RZG2L=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_SCIF_CONSOLE=y
+CONFIG_TEE=y
+CONFIG_OPTEE=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_GENERIC=y
+CONFIG_USB_STORAGE=y
+CONFIG_OF_LIBFDT_OVERLAY=y
+CONFIG_SMBIOS_MANUFACTURER=""
+CONFIG_WDT=y
+CONFIG_RENESAS_RZG2LWDT=y
+CONFIG_CMD_WDT=y
+CONFIG_BOARD_LATE_INIT=y
+CONFIG_CMD_EEPROM=y
+CONFIG_I2C_SET_DEFAULT_BUS_NUM=y
+CONFIG_I2C_DEFAULT_BUS_NUMBER=0
+CONFIG_I2C_EEPROM=y
+CONFIG_SYS_I2C_EEPROM_ADDR=0x50
+CONFIG_SYS_I2C_EEPROM_BUS=0
+CONFIG_SYS_I2C_EEPROM_ADDR_LEN=1
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_BAR=y
+CONFIG_SPI_FLASH_USE_4K_SECTORS=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_RENESAS_RPC_SPI=y
+CONFIG_CMD_SF=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_DM_SPI_FLASH=y
diff --git a/configs/vkrzg2lc-qspi_defconfig b/configs/vkrzg2lc-qspi_defconfig
new file mode 100644
index 0000000000..295f0a8180
--- /dev/null
+++ b/configs/vkrzg2lc-qspi_defconfig
@@ -0,0 +1,129 @@
+CONFIG_USB_GADGET=y
+CONFIG_USB_RENESAS_USBHS=y
+CONFIG_USB_FUNCTION_FASTBOOT=y
+CONFIG_FASTBOOT_BUF_ADDR=0x4D000000
+CONFIG_FASTBOOT_BUF_SIZE=0x8000000
+CONFIG_FASTBOOT_USB_DEV=1
+CONFIG_FASTBOOT_MMC_BOOT_SUPPORT=y
+CONFIG_FASTBOOT_MMC_BOOT1_NAME="mmc0boot0"
+CONFIG_FASTBOOT_MMC_BOOT2_NAME="mmc0boot1"
+CONFIG_FASTBOOT_MMC_USER_SUPPORT=y
+CONFIG_FASTBOOT_MMC_USER_NAME="mmc0"
+CONFIG_FASTBOOT_GPT_NAME="gpt"
+CONFIG_FASTBOOT_MBR_NAME="mbr"
+CONFIG_FASTBOOT_FLASH=y
+#On RZ/G2L 0 is eMMC - 1 is SDCard.
+CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_USB_GADGET_MANUFACTURER="Renesas"
+CONFIG_USB_GADGET_VENDOR_NUM=0x18D1
+CONFIG_USB_GADGET_PRODUCT_NUM=0x4E23
+CONFIG_CMD_FASTBOOT=y
+CONFIG_USB_FUNCTION_MASS_STORAGE=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_ARM=y
+CONFIG_ARCH_CPU_INIT=y
+CONFIG_ARCH_RMOBILE=y
+CONFIG_SYS_TEXT_BASE=0x50000000
+CONFIG_DM_GPIO=y
+CONFIG_RCAR_GEN3=y
+CONFIG_R9A07G044C=y
+CONFIG_TARGET_VKRZG2LC=y
+CONFIG_SPL=n
+CONFIG_DEFAULT_DEVICE_TREE="vkrzg2lc"
+CONFIG_SMBIOS_PRODUCT_NAME=""
+# CONFIG_ANDROID_BOOT_IMAGE is not set
+CONFIG_FIT=y
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="rw rootwait earlycon root=/dev/mmcblk1p1 ${extrabootargs}"
+CONFIG_SUPPORT_RAW_INITRD=y
+CONFIG_DEFAULT_FDT_FILE="vkrzg2lc.dtb"
+CONFIG_VERSION_VARIABLE=y
+CONFIG_CMD_CM33=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_OF_CONTROL=y
+CONFIG_OF_LIST="vkrzg2lc"
+CONFIG_MULTI_DTB_FIT_LZO=y
+CONFIG_MULTI_DTB_FIT_USER_DEFINED_AREA=y
+CONFIG_ENV_OVERWRITE=y
+#
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_ENV_SIZE=0x20000
+CONFIG_ENV_OFFSET=0x1E0000
+CONFIG_ENV_SECT_SIZE=0x1000
+#
+CONFIG_SYS_RELOC_GD_ENV_ADDR=y
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_REGMAP=y
+CONFIG_SYSCON=y
+CONFIG_CLK=y
+CONFIG_CLK_RENESAS=y
+CONFIG_CLK_R9A07G044L=y
+CONFIG_UDP_FUNCTION_FASTBOOT=y
+#CONFIG_FASTBOOT_BUF_ADDR=0x82000000
+#CONFIG_FASTBOOT_FLASH=y
+#CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_RCAR_GPIO=y
+CONFIG_RZG2L_GPIO=y
+CONFIG_DM=y
+CONFIG_DM_I2C=y
+CONFIG_MISC=y
+CONFIG_SYS_I2C_RCAR_IIC=y
+CONFIG_SYS_I2C_RZG2L_RIIC=y
+CONFIG_SH_SDHI=y
+CONFIG_BITBANGMII=y
+CONFIG_PHY_REALTEK=y
+CONFIG_DM_ETH=y
+CONFIG_RENESAS_RAVB=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_PCI_RCAR_GEN3=y
+CONFIG_PINCTRL_PFC_RZG2L=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_SCIF_CONSOLE=y
+CONFIG_TEE=y
+CONFIG_OPTEE=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_GENERIC=y
+CONFIG_USB_STORAGE=y
+CONFIG_OF_LIBFDT_OVERLAY=y
+CONFIG_SMBIOS_MANUFACTURER=""
+CONFIG_WDT=y
+CONFIG_RENESAS_RZG2LWDT=y
+CONFIG_CMD_WDT=y
+CONFIG_BOARD_LATE_INIT=y
+CONFIG_CMD_EEPROM=y
+CONFIG_I2C_SET_DEFAULT_BUS_NUM=y
+CONFIG_I2C_DEFAULT_BUS_NUMBER=0
+CONFIG_I2C_EEPROM=y
+CONFIG_SYS_I2C_EEPROM_ADDR=0x50
+CONFIG_SYS_I2C_EEPROM_BUS=0
+CONFIG_SYS_I2C_EEPROM_ADDR_LEN=1
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_BAR=y
+CONFIG_SPI_FLASH_USE_4K_SECTORS=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_RENESAS_RPC_SPI=y
+CONFIG_CMD_SF=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_DM_SPI_FLASH=y
diff --git a/configs/vkrzg2ul-emmc_defconfig b/configs/vkrzg2ul-emmc_defconfig
new file mode 100644
index 0000000000..89e8203adf
--- /dev/null
+++ b/configs/vkrzg2ul-emmc_defconfig
@@ -0,0 +1,130 @@
+CONFIG_USB_GADGET=y
+CONFIG_USB_RENESAS_USBHS=y
+CONFIG_USB_FUNCTION_FASTBOOT=y
+CONFIG_FASTBOOT_BUF_ADDR=0x4D000000
+CONFIG_FASTBOOT_BUF_SIZE=0x8000000
+CONFIG_FASTBOOT_USB_DEV=1
+CONFIG_FASTBOOT_MMC_BOOT_SUPPORT=y
+CONFIG_FASTBOOT_MMC_BOOT1_NAME="mmc0boot0"
+CONFIG_FASTBOOT_MMC_BOOT2_NAME="mmc0boot1"
+CONFIG_FASTBOOT_MMC_USER_SUPPORT=y
+CONFIG_FASTBOOT_MMC_USER_NAME="mmc0"
+CONFIG_FASTBOOT_GPT_NAME="gpt"
+CONFIG_FASTBOOT_MBR_NAME="mbr"
+CONFIG_FASTBOOT_FLASH=y
+#On RZ/G2L 0 is eMMC - 1 is SDCard.
+CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_USB_GADGET_MANUFACTURER="Renesas"
+CONFIG_USB_GADGET_VENDOR_NUM=0x18D1
+CONFIG_USB_GADGET_PRODUCT_NUM=0x4E23
+CONFIG_CMD_FASTBOOT=y
+CONFIG_USB_FUNCTION_MASS_STORAGE=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_ARM=y
+CONFIG_ARCH_CPU_INIT=y
+CONFIG_ARCH_RMOBILE=y
+CONFIG_SYS_TEXT_BASE=0x50000000
+CONFIG_DM_GPIO=y
+CONFIG_RCAR_GEN3=y
+CONFIG_R9A07G043U=y
+CONFIG_TARGET_VKRZG2UL=y
+CONFIG_SPL=n
+CONFIG_DEFAULT_DEVICE_TREE="vkrzg2ul"
+CONFIG_SMBIOS_PRODUCT_NAME=""
+# CONFIG_ANDROID_BOOT_IMAGE is not set
+CONFIG_FIT=y
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="rw rootwait earlycon root=/dev/mmcblk0p1 ${extrabootargs}"
+CONFIG_SUPPORT_RAW_INITRD=y
+CONFIG_DEFAULT_FDT_FILE="vkrzg2ul.dtb"
+CONFIG_VERSION_VARIABLE=y
+CONFIG_CMD_CM33=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_OF_CONTROL=y
+CONFIG_OF_LIST="vkrzg2ul"
+CONFIG_MULTI_DTB_FIT_LZO=y
+CONFIG_MULTI_DTB_FIT_USER_DEFINED_AREA=y
+CONFIG_ENV_OVERWRITE=y
+#
+CONFIG_ENV_IS_IN_MMC=y
+CONFIG_SYS_MMC_ENV_DEV=0
+CONFIG_SYS_MMC_ENV_PART=1
+CONFIG_ENV_SIZE=0x20000
+CONFIG_ENV_OFFSET=0xFFFE0000
+#
+CONFIG_SYS_RELOC_GD_ENV_ADDR=y
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_REGMAP=y
+CONFIG_SYSCON=y
+CONFIG_CLK=y
+CONFIG_CLK_RENESAS=y
+CONFIG_CLK_R9A07G043U=y
+CONFIG_UDP_FUNCTION_FASTBOOT=y
+#CONFIG_FASTBOOT_BUF_ADDR=0x82000000
+#CONFIG_FASTBOOT_FLASH=y
+#CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_RCAR_GPIO=y
+CONFIG_RZG2L_GPIO=y
+CONFIG_DM=y
+CONFIG_DM_I2C=y
+CONFIG_MISC=y
+CONFIG_SYS_I2C_RCAR_IIC=y
+CONFIG_SYS_I2C_RZG2L_RIIC=y
+CONFIG_SH_SDHI=y
+CONFIG_BITBANGMII=y
+CONFIG_PHY_REALTEK=y
+CONFIG_DM_ETH=y
+CONFIG_RENESAS_RAVB=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_PCI_RCAR_GEN3=y
+CONFIG_PINCTRL_PFC_RZG2L=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_SCIF_CONSOLE=y
+CONFIG_TEE=y
+CONFIG_OPTEE=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_GENERIC=y
+CONFIG_USB_STORAGE=y
+CONFIG_OF_LIBFDT_OVERLAY=y
+CONFIG_SMBIOS_MANUFACTURER=""
+CONFIG_WDT=y
+CONFIG_RENESAS_RZG2LWDT=y
+CONFIG_CMD_WDT=y
+CONFIG_BOARD_LATE_INIT=y
+CONFIG_CMD_EEPROM=y
+CONFIG_I2C_SET_DEFAULT_BUS_NUM=y
+CONFIG_I2C_DEFAULT_BUS_NUMBER=0
+CONFIG_I2C_EEPROM=y
+CONFIG_SYS_I2C_EEPROM_ADDR=0x50
+CONFIG_SYS_I2C_EEPROM_BUS=1
+CONFIG_SYS_I2C_EEPROM_ADDR_LEN=1
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_BAR=y
+CONFIG_SPI_FLASH_USE_4K_SECTORS=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_RENESAS_RPC_SPI=y
+CONFIG_CMD_SF=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_DM_SPI_FLASH=y
diff --git a/configs/vkrzg2ul-qspi_defconfig b/configs/vkrzg2ul-qspi_defconfig
new file mode 100644
index 0000000000..1542db19e4
--- /dev/null
+++ b/configs/vkrzg2ul-qspi_defconfig
@@ -0,0 +1,129 @@
+CONFIG_USB_GADGET=y
+CONFIG_USB_RENESAS_USBHS=y
+CONFIG_USB_FUNCTION_FASTBOOT=y
+CONFIG_FASTBOOT_BUF_ADDR=0x4D000000
+CONFIG_FASTBOOT_BUF_SIZE=0x8000000
+CONFIG_FASTBOOT_USB_DEV=1
+CONFIG_FASTBOOT_MMC_BOOT_SUPPORT=y
+CONFIG_FASTBOOT_MMC_BOOT1_NAME="mmc0boot0"
+CONFIG_FASTBOOT_MMC_BOOT2_NAME="mmc0boot1"
+CONFIG_FASTBOOT_MMC_USER_SUPPORT=y
+CONFIG_FASTBOOT_MMC_USER_NAME="mmc0"
+CONFIG_FASTBOOT_GPT_NAME="gpt"
+CONFIG_FASTBOOT_MBR_NAME="mbr"
+CONFIG_FASTBOOT_FLASH=y
+#On RZ/G2L 0 is eMMC - 1 is SDCard.
+CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_USB_GADGET_MANUFACTURER="Renesas"
+CONFIG_USB_GADGET_VENDOR_NUM=0x18D1
+CONFIG_USB_GADGET_PRODUCT_NUM=0x4E23
+CONFIG_CMD_FASTBOOT=y
+CONFIG_USB_FUNCTION_MASS_STORAGE=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_ARM=y
+CONFIG_ARCH_CPU_INIT=y
+CONFIG_ARCH_RMOBILE=y
+CONFIG_SYS_TEXT_BASE=0x50000000
+CONFIG_DM_GPIO=y
+CONFIG_RCAR_GEN3=y
+CONFIG_R9A07G043U=y
+CONFIG_TARGET_VKRZG2UL=y
+CONFIG_SPL=n
+CONFIG_DEFAULT_DEVICE_TREE="vkrzg2ul"
+CONFIG_SMBIOS_PRODUCT_NAME=""
+# CONFIG_ANDROID_BOOT_IMAGE is not set
+CONFIG_FIT=y
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="rw rootwait earlycon root=/dev/mmcblk1p1 ${extrabootargs}"
+CONFIG_SUPPORT_RAW_INITRD=y
+CONFIG_DEFAULT_FDT_FILE="vkrzg2ul.dtb"
+CONFIG_VERSION_VARIABLE=y
+CONFIG_CMD_CM33=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_OF_CONTROL=y
+CONFIG_OF_LIST="vkrzg2ul"
+CONFIG_MULTI_DTB_FIT_LZO=y
+CONFIG_MULTI_DTB_FIT_USER_DEFINED_AREA=y
+CONFIG_ENV_OVERWRITE=y
+#
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_ENV_SIZE=0x20000
+CONFIG_ENV_OFFSET=0x1E0000
+CONFIG_ENV_SECT_SIZE=0x1000
+#
+CONFIG_SYS_RELOC_GD_ENV_ADDR=y
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_REGMAP=y
+CONFIG_SYSCON=y
+CONFIG_CLK=y
+CONFIG_CLK_RENESAS=y
+CONFIG_CLK_R9A07G043U=y
+CONFIG_UDP_FUNCTION_FASTBOOT=y
+#CONFIG_FASTBOOT_BUF_ADDR=0x82000000
+#CONFIG_FASTBOOT_FLASH=y
+#CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_RCAR_GPIO=y
+CONFIG_RZG2L_GPIO=y
+CONFIG_DM=y
+CONFIG_DM_I2C=y
+CONFIG_MISC=y
+CONFIG_SYS_I2C_RCAR_IIC=y
+CONFIG_SYS_I2C_RZG2L_RIIC=y
+CONFIG_SH_SDHI=y
+CONFIG_BITBANGMII=y
+CONFIG_PHY_REALTEK=y
+CONFIG_DM_ETH=y
+CONFIG_RENESAS_RAVB=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_PCI_RCAR_GEN3=y
+CONFIG_PINCTRL_PFC_RZG2L=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_SCIF_CONSOLE=y
+CONFIG_TEE=y
+CONFIG_OPTEE=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_GENERIC=y
+CONFIG_USB_STORAGE=y
+CONFIG_OF_LIBFDT_OVERLAY=y
+CONFIG_SMBIOS_MANUFACTURER=""
+CONFIG_WDT=y
+CONFIG_RENESAS_RZG2LWDT=y
+CONFIG_CMD_WDT=y
+CONFIG_BOARD_LATE_INIT=y
+CONFIG_CMD_EEPROM=y
+CONFIG_I2C_SET_DEFAULT_BUS_NUM=y
+CONFIG_I2C_DEFAULT_BUS_NUMBER=0
+CONFIG_I2C_EEPROM=y
+CONFIG_SYS_I2C_EEPROM_ADDR=0x50
+CONFIG_SYS_I2C_EEPROM_BUS=1
+CONFIG_SYS_I2C_EEPROM_ADDR_LEN=1
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_BAR=y
+CONFIG_SPI_FLASH_USE_4K_SECTORS=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_RENESAS_RPC_SPI=y
+CONFIG_CMD_SF=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_DM_SPI_FLASH=y
diff --git a/configs/vkrzv2l-emmc_defconfig b/configs/vkrzv2l-emmc_defconfig
new file mode 100644
index 0000000000..cad3aa5409
--- /dev/null
+++ b/configs/vkrzv2l-emmc_defconfig
@@ -0,0 +1,130 @@
+CONFIG_USB_GADGET=y
+CONFIG_USB_RENESAS_USBHS=y
+CONFIG_USB_FUNCTION_FASTBOOT=y
+CONFIG_FASTBOOT_BUF_ADDR=0x4D000000
+CONFIG_FASTBOOT_BUF_SIZE=0x8000000
+CONFIG_FASTBOOT_USB_DEV=1
+CONFIG_FASTBOOT_MMC_BOOT_SUPPORT=y
+CONFIG_FASTBOOT_MMC_BOOT1_NAME="mmc0boot0"
+CONFIG_FASTBOOT_MMC_BOOT2_NAME="mmc0boot1"
+CONFIG_FASTBOOT_MMC_USER_SUPPORT=y
+CONFIG_FASTBOOT_MMC_USER_NAME="mmc0"
+CONFIG_FASTBOOT_GPT_NAME="gpt"
+CONFIG_FASTBOOT_MBR_NAME="mbr"
+CONFIG_FASTBOOT_FLASH=y
+#On RZ/G2L 0 is eMMC - 1 is SDCard.
+CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_USB_GADGET_MANUFACTURER="Renesas"
+CONFIG_USB_GADGET_VENDOR_NUM=0x18D1
+CONFIG_USB_GADGET_PRODUCT_NUM=0x4E23
+CONFIG_CMD_FASTBOOT=y
+CONFIG_USB_FUNCTION_MASS_STORAGE=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_ARM=y
+CONFIG_ARCH_CPU_INIT=y
+CONFIG_ARCH_RMOBILE=y
+CONFIG_SYS_TEXT_BASE=0x50000000
+CONFIG_DM_GPIO=y
+CONFIG_RCAR_GEN3=y
+CONFIG_R9A07G054L=y
+CONFIG_TARGET_VKRZV2L=y
+CONFIG_SPL=n
+CONFIG_DEFAULT_DEVICE_TREE="vkrzv2l"
+CONFIG_SMBIOS_PRODUCT_NAME=""
+# CONFIG_ANDROID_BOOT_IMAGE is not set
+CONFIG_FIT=y
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="rw rootwait earlycon root=/dev/mmcblk0p1 ${extrabootargs}"
+CONFIG_SUPPORT_RAW_INITRD=y
+CONFIG_DEFAULT_FDT_FILE="vkrzv2l.dtb"
+CONFIG_VERSION_VARIABLE=y
+CONFIG_CMD_CM33=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_OF_CONTROL=y
+CONFIG_OF_LIST="vkrzv2l"
+CONFIG_MULTI_DTB_FIT_LZO=y
+CONFIG_MULTI_DTB_FIT_USER_DEFINED_AREA=y
+CONFIG_ENV_OVERWRITE=y
+#
+CONFIG_ENV_IS_IN_MMC=y
+CONFIG_SYS_MMC_ENV_DEV=0
+CONFIG_SYS_MMC_ENV_PART=1
+CONFIG_ENV_SIZE=0x20000
+CONFIG_ENV_OFFSET=0xFFFE0000
+#
+CONFIG_SYS_RELOC_GD_ENV_ADDR=y
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_REGMAP=y
+CONFIG_SYSCON=y
+CONFIG_CLK=y
+CONFIG_CLK_RENESAS=y
+CONFIG_CLK_R9A07G054L=y
+CONFIG_UDP_FUNCTION_FASTBOOT=y
+#CONFIG_FASTBOOT_BUF_ADDR=0x82000000
+#CONFIG_FASTBOOT_FLASH=y
+#CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_RCAR_GPIO=y
+CONFIG_RZG2L_GPIO=y
+CONFIG_DM=y
+CONFIG_DM_I2C=y
+CONFIG_MISC=y
+CONFIG_SYS_I2C_RCAR_IIC=y
+CONFIG_SYS_I2C_RZG2L_RIIC=y
+CONFIG_SH_SDHI=y
+CONFIG_BITBANGMII=y
+CONFIG_PHY_REALTEK=y
+CONFIG_DM_ETH=y
+CONFIG_RENESAS_RAVB=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_PCI_RCAR_GEN3=y
+CONFIG_PINCTRL_PFC_RZG2L=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_SCIF_CONSOLE=y
+CONFIG_TEE=y
+CONFIG_OPTEE=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_GENERIC=y
+CONFIG_USB_STORAGE=y
+CONFIG_OF_LIBFDT_OVERLAY=y
+CONFIG_SMBIOS_MANUFACTURER=""
+CONFIG_WDT=y
+CONFIG_RENESAS_RZG2LWDT=y
+CONFIG_CMD_WDT=y
+CONFIG_BOARD_LATE_INIT=y
+#CONFIG_CMD_EEPROM=y
+CONFIG_I2C_SET_DEFAULT_BUS_NUM=y
+CONFIG_I2C_DEFAULT_BUS_NUMBER=3
+#CONFIG_I2C_EEPROM=y
+#CONFIG_SYS_I2C_EEPROM_ADDR=0x50
+#CONFIG_SYS_I2C_EEPROM_BUS=3
+#CONFIG_SYS_I2C_EEPROM_ADDR_LEN=1
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_BAR=y
+CONFIG_SPI_FLASH_USE_4K_SECTORS=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_RENESAS_RPC_SPI=y
+CONFIG_CMD_SF=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_DM_SPI_FLASH=y
diff --git a/configs/vkrzv2l-qspi_defconfig b/configs/vkrzv2l-qspi_defconfig
new file mode 100644
index 0000000000..b81cdb0118
--- /dev/null
+++ b/configs/vkrzv2l-qspi_defconfig
@@ -0,0 +1,129 @@
+CONFIG_USB_GADGET=y
+CONFIG_USB_RENESAS_USBHS=y
+CONFIG_USB_FUNCTION_FASTBOOT=y
+CONFIG_FASTBOOT_BUF_ADDR=0x4D000000
+CONFIG_FASTBOOT_BUF_SIZE=0x8000000
+CONFIG_FASTBOOT_USB_DEV=1
+CONFIG_FASTBOOT_MMC_BOOT_SUPPORT=y
+CONFIG_FASTBOOT_MMC_BOOT1_NAME="mmc0boot0"
+CONFIG_FASTBOOT_MMC_BOOT2_NAME="mmc0boot1"
+CONFIG_FASTBOOT_MMC_USER_SUPPORT=y
+CONFIG_FASTBOOT_MMC_USER_NAME="mmc0"
+CONFIG_FASTBOOT_GPT_NAME="gpt"
+CONFIG_FASTBOOT_MBR_NAME="mbr"
+CONFIG_FASTBOOT_FLASH=y
+#On RZ/G2L 0 is eMMC - 1 is SDCard.
+CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_USB_GADGET_MANUFACTURER="Renesas"
+CONFIG_USB_GADGET_VENDOR_NUM=0x18D1
+CONFIG_USB_GADGET_PRODUCT_NUM=0x4E23
+CONFIG_CMD_FASTBOOT=y
+CONFIG_USB_FUNCTION_MASS_STORAGE=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_ARM=y
+CONFIG_ARCH_CPU_INIT=y
+CONFIG_ARCH_RMOBILE=y
+CONFIG_SYS_TEXT_BASE=0x50000000
+CONFIG_DM_GPIO=y
+CONFIG_RCAR_GEN3=y
+CONFIG_R9A07G054L=y
+CONFIG_TARGET_VKRZV2L=y
+CONFIG_SPL=n
+CONFIG_DEFAULT_DEVICE_TREE="vkrzv2l"
+CONFIG_SMBIOS_PRODUCT_NAME=""
+# CONFIG_ANDROID_BOOT_IMAGE is not set
+CONFIG_FIT=y
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="rw rootwait earlycon root=/dev/mmcblk0p1 ${extrabootargs}"
+CONFIG_SUPPORT_RAW_INITRD=y
+CONFIG_DEFAULT_FDT_FILE="vkrzv2l.dtb"
+CONFIG_VERSION_VARIABLE=y
+CONFIG_CMD_CM33=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_OF_CONTROL=y
+CONFIG_OF_LIST="vkrzv2l"
+CONFIG_MULTI_DTB_FIT_LZO=y
+CONFIG_MULTI_DTB_FIT_USER_DEFINED_AREA=y
+CONFIG_ENV_OVERWRITE=y
+#
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_ENV_SIZE=0x20000
+CONFIG_ENV_OFFSET=0x1E0000
+CONFIG_ENV_SECT_SIZE=0x1000
+#
+CONFIG_SYS_RELOC_GD_ENV_ADDR=y
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_REGMAP=y
+CONFIG_SYSCON=y
+CONFIG_CLK=y
+CONFIG_CLK_RENESAS=y
+CONFIG_CLK_R9A07G054L=y
+CONFIG_UDP_FUNCTION_FASTBOOT=y
+#CONFIG_FASTBOOT_BUF_ADDR=0x82000000
+#CONFIG_FASTBOOT_FLASH=y
+#CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_RCAR_GPIO=y
+CONFIG_RZG2L_GPIO=y
+CONFIG_DM=y
+CONFIG_DM_I2C=y
+CONFIG_MISC=y
+CONFIG_SYS_I2C_RCAR_IIC=y
+CONFIG_SYS_I2C_RZG2L_RIIC=y
+CONFIG_SH_SDHI=y
+CONFIG_BITBANGMII=y
+CONFIG_PHY_REALTEK=y
+CONFIG_DM_ETH=y
+CONFIG_RENESAS_RAVB=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_PCI_RCAR_GEN3=y
+CONFIG_PINCTRL_PFC_RZG2L=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_SCIF_CONSOLE=y
+CONFIG_TEE=y
+CONFIG_OPTEE=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_GENERIC=y
+CONFIG_USB_STORAGE=y
+CONFIG_OF_LIBFDT_OVERLAY=y
+CONFIG_SMBIOS_MANUFACTURER=""
+CONFIG_WDT=y
+CONFIG_RENESAS_RZG2LWDT=y
+CONFIG_CMD_WDT=y
+CONFIG_BOARD_LATE_INIT=y
+#CONFIG_CMD_EEPROM=y
+CONFIG_I2C_SET_DEFAULT_BUS_NUM=y
+CONFIG_I2C_DEFAULT_BUS_NUMBER=3
+#CONFIG_I2C_EEPROM=y
+#CONFIG_SYS_I2C_EEPROM_ADDR=0x50
+#CONFIG_SYS_I2C_EEPROM_BUS=3
+#CONFIG_SYS_I2C_EEPROM_ADDR_LEN=1
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_BAR=y
+CONFIG_SPI_FLASH_USE_4K_SECTORS=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_RENESAS_RPC_SPI=y
+CONFIG_CMD_SF=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_DM_SPI_FLASH=y
diff --git a/drivers/mtd/spi/spi-nor-ids.c b/drivers/mtd/spi/spi-nor-ids.c
index 1e837babb3..ac89fb0b2a 100644
--- a/drivers/mtd/spi/spi-nor-ids.c
+++ b/drivers/mtd/spi/spi-nor-ids.c
@@ -158,7 +158,7 @@ const struct flash_info spi_nor_ids[] = {
 	{ INFO("mx25l12833f", 0xc22018, 0, 64 * 1024, 256, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ ) },
 	{ INFO("mx25u12835f", 0xc22538, 0, 64 * 1024, 256, SECT_4K) },
 	{ INFO("mx25l12855e", 0xc22618, 0, 64 * 1024, 256, 0) },
-	{ INFO("mx25l25635e", 0xc22019, 0, 64 * 1024, 512, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
+	{ INFO("mx25l25645g", 0xc22019, 0, 64 * 1024, 512, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
 	{ INFO("mx25u25645g", 0xc22539, 0, 64 * 1024, 512, SECT_4K | SPI_NOR_4B_OPCODES) },
 	{ INFO("mx25v8035f",  0xc22314, 0, 64 * 1024,  16, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
 	{ INFO("mx25r1635f",  0xc22815, 0, 64 * 1024,  32, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
diff --git a/include/configs/vk-d184280e.h b/include/configs/vk-d184280e.h
new file mode 100644
index 0000000000..55e24db79f
--- /dev/null
+++ b/include/configs/vk-d184280e.h
@@ -0,0 +1,246 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (C) 2021 Renesas Electronics Corporation
+ */
+
+#ifndef __VK_D184280E_H
+#define __VK_D184280E_H
+
+#include <asm/arch/rmobile.h>
+#include "vk_fdt_overlay.h"
+
+#define __p(x)   x
+
+#define CONFIG_REMAKE_ELF
+
+#ifdef CONFIG_SPL
+#define CONFIG_SPL_TARGET   "spl/u-boot-spl.scif"
+#endif
+
+/* boot option */
+
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+
+/* Generic Interrupt Controller Definitions */
+/* RZ/G2L use GIC-v3 */
+#define CONFIG_GICV3
+#define GICD_BASE   0x11900000
+#define GICR_BASE   0x11960000
+
+/* console */
+#define CONFIG_SYS_CBSIZE       2048
+#define CONFIG_SYS_BARGSIZE     CONFIG_SYS_CBSIZE
+#define CONFIG_SYS_MAXARGS      64
+#define CONFIG_SYS_BAUDRATE_TABLE   { 115200, 38400 }
+
+/* PHY needs a longer autoneg timeout */
+#define PHY_ANEG_TIMEOUT        20000
+
+/* MEMORY */
+#define CONFIG_SYS_INIT_SP_ADDR     CONFIG_SYS_TEXT_BASE
+
+/* SDHI clock freq */
+#define CONFIG_SH_SDHI_FREQ     133000000
+
+#define DRAM_RSV_SIZE           0x08000000
+#define CONFIG_SYS_SDRAM_BASE       (0x40000000 + DRAM_RSV_SIZE)
+
+#if CONFIG_TARGET_VK_D184280E_1
+#define CONFIG_SYS_SDRAM_SIZE       (0x40000000u - DRAM_RSV_SIZE) //total 1GB
+#else
+#define CONFIG_SYS_SDRAM_SIZE       (0x80000000u - DRAM_RSV_SIZE) //total 2GB
+#endif
+
+#define CONFIG_SYS_LOAD_ADDR        0x58000000
+#define CONFIG_LOADADDR         CONFIG_SYS_LOAD_ADDR // Default load address for tfpt,bootp...
+#define CONFIG_VERY_BIG_RAM
+#if CONFIG_TARGET_VK_D184280E_1
+#define CONFIG_MAX_MEM_MAPPED       (0x40000000u - DRAM_RSV_SIZE)
+#else
+#define CONFIG_MAX_MEM_MAPPED       (0x80000000u - DRAM_RSV_SIZE)
+#endif
+
+#define CONFIG_SYS_MONITOR_BASE     0x00000000
+#define CONFIG_SYS_MONITOR_LEN      (1 * 1024 * 1024)
+#define CONFIG_SYS_MALLOC_LEN       (64 * 1024 * 1024)
+#define CONFIG_SYS_BOOTM_LEN        (64 << 20)
+
+/* The HF/QSPI layout permits up to 1 MiB large bootloader blob */
+#define CONFIG_BOARD_SIZE_LIMIT     1048576
+
+/* I2C configuration */
+#define I2C_VERSACLOCK_ADDR  0x68
+#define I2C_VERSACLOCK_ADDR_LEN 1
+#define I2C_SYS_MODULE    0
+
+#ifndef CONFIG_SYS_I2C_EEPROM_ADDR 
+#define CONFIG_SYS_I2C_EEPROM_ADDR 0x50
+#endif
+#ifndef CONFIG_SYS_I2C_EEPROM_BUS
+#define CONFIG_SYS_I2C_EEPROM_BUS 0
+#endif
+
+#ifndef CONFIG_SYS_I2C_EEPROM_ADDR_LEN
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN 1
+#endif
+
+#define I2C_EEPROM_MAC_ADDR     0x58
+#define ETHER_EEPROM_ADDR       0x9A /* MAC address offset in EEPROM */
+
+#ifdef VEKATECH_UENV_FDTO_SUPPORT
+#define LOAD_FDT_OVERLAYS \
+    OVERLAY_SETTINGS \
+    GET_FDT_OVERLAY_mmc \
+    GET_FDT_OVERLAY_usb \
+    GET_FDT_OVERLAY_net
+#else
+#define LOAD_FDT_OVERLAYS \
+    "loadfdto_mmc=echo overlays are not supported!\0" \
+    "loadfdto_usb=echo overlays are not supported!\0" \
+    "loadfdto_net=echo overlays are not supported!\0"
+#endif
+
+/* Load rzv2l_cm33_rpmsg_demo to run */
+#define CM33_BOOT_ARGS \
+    "dcache off; " \
+    "mmc dev 0; " \
+    "fatload mmc 0:1 0x0001FF80 cm33/rzv2l_cm33_rpmsg_demo_secure_vector.bin; " \
+    "fatload mmc 0:1 0x42EFF440 cm33/rzv2l_cm33_rpmsg_demo_secure_code.bin; " \
+    "fatload mmc 0:1 0x00010000 cm33/rzv2l_cm33_rpmsg_demo_non_secure_vector.bin; " \
+    "fatload mmc 0:1 0x40010000 cm33/rzv2l_cm33_rpmsg_demo_non_secure_code.bin; " \
+    "cm33 start_debug 0x1001FF80 0x00010000; " \
+    "dcache on;"
+
+#define DEFAULT_MMC_UENV_ARGS \
+    "boardID="CONFIG_SYS_BOARD"\0" \
+    "image=Image\0" \
+    "fdtfile="CONFIG_DEFAULT_FDT_FILE"\0" \
+    "dtb_addr=0x48000000\0" \
+    "image_addr=0x48080000\0" \
+    "bootm_size=0x10000000\0" \
+    "loadaddr=0x58000000\0" \
+    "rd_addr=0x50000000\0" \
+    "mmcdev="__stringify(CONFIG_SYS_MMC_DEV)"\0" \
+    "mmcpart="__stringify(CONFIG_SYS_MMC_IMG_LOAD_PART)"\0" \
+    "tftpdir="CONFIG_SYS_BOARD"\0" \
+    "netrootfs=/nfs/"CONFIG_SYS_BOARD"\0" \
+    "netmask=255.255.255.0\0" \
+    "serverip=192.168.2.91\0" \
+    "usbdev="__stringify(CONFIG_SYS_USB_DEV)"\0" \
+    "usbpart="__stringify(CONFIG_SYS_USB_IMG_LOAD_PART)"\0" \
+    "usbbootdir=boot\0" \
+    "bootenvfile=uEnv.txt\0" \
+    "importbootenv=echo Importing environment ...; " \
+        "env import -t ${image_addr} ${filesize}\0" \
+    "bootimage=booti ${image_addr} - ${dtb_addr}\0" \
+    "bootimagerd=booti ${image_addr} ${rd_addr} ${dtb_addr}\0" \
+    "rdinitapp=/home/root/emmc_prog\0" \
+    "cpiofile=core-image-bsp-"CONFIG_SYS_BOARD"-mod.cpio.gz.u-boot\0"
+
+#define DEFAULT_MMC_RZG2LC_ARGS  DEFAULT_MMC_UENV_ARGS
+
+#define GET_IMAGE_USB \
+    "load_usb=echo trying usb...; "          \
+          "usb start; "                      \
+          "usb reset; "                      \
+          "if usb dev ${usbdev}; then "      \
+             "if run loadbootenv_usb; then " \
+                 "run importbootenv; "       \
+             "fi; "                          \
+             "if run loadfdt_usb; then "     \
+                "run loadfdto_usb; "          \
+                "if run loadimage_usb; then " \
+                    "run loadcpio_usb; "     \
+                "fi; "                       \
+             "fi; "                          \
+          "fi;\0"
+
+#define GET_IMAGE_MMC \
+    "load_mmc=echo trying mmc...; "               \
+            "if mmc dev ${mmcdev}; then "         \
+              "if mmc rescan; then "              \
+                  "if run loadbootenv_mmc; then " \
+                      "run importbootenv; "       \
+                  "fi; "                          \
+                  "if run loadfdt_mmc; then "     \
+                      "run loadfdto_mmc; "        \
+                      "run loadimage_mmc; "       \
+                  "fi; "                          \
+              "fi; "                              \
+            "fi;\0"
+
+#define GET_IMAGE_NET \
+    "load_net=echo trying net...; "         \
+            "setenv autoload no; dhcp; "    \
+            "if run loadbootenv_net; then " \
+                "run importbootenv; "       \
+            "fi; "                          \
+            "if run loadfdt_net; then "     \
+                "run loadfdto_net; "        \
+                "run loadimage_net; "       \
+            "fi;\0"
+
+#define BOOT_MMC                        \
+    "if run load_mmc; then "            \
+        "echo Starting from mmc ...; "  \
+        "run bootargs_mmc; "            \
+        "run bootimage; "               \
+    "else "                             \
+        "echo Cannot start from mmc!; " \
+    "fi; "
+
+#define BOOT_USB \
+    "if run load_usb; then "            \
+        "echo Starting from usb ...; "  \
+        "run bootargs_usb; "            \
+        "run bootimagerd; "             \
+    "else "                             \
+        "echo Cannot start from usb!; " \
+    "fi; "
+
+#define BOOT_NET \
+    "if run load_net; then "            \
+        "echo Starting from net ...; "  \
+        "run bootargs_net; "            \
+        "run bootimage; "               \
+    "else "                             \
+        "echo Cannot start from net!; " \
+    "fi; "
+
+/* ENV setting */
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+    DEFAULT_MMC_RZG2LC_ARGS \
+    LOAD_FDT_OVERLAYS \
+    "bootargs_mmc=setenv bootargs rw rootwait earlycon root=/dev/mmcblk"__stringify(CONFIG_SYS_MMC_DEV)"p2 ${extrabootargs}\0" \
+    "bootargs_net=setenv bootargs rw rootwait earlycon root=/dev/nfs ip=dhcp nfsroot=${serverip}:${netrootfs},vers=4,tcp ${extrabootargs}\0" \
+    "bootargs_usb=setenv bootargs rw rootwait earlycon root=/dev/ram0 rdinit=${rdinitapp} ${extrabootargs}\0" \
+    "loadbootenv_mmc=fatload mmc ${mmcdev} ${image_addr} ${bootenvfile}\0" \
+    "loadbootenv_usb=fatload usb ${usbdev} ${image_addr} ${bootenvfile}\0" \
+    "loadbootenv_net=tftp ${image_addr} ${serverip}:${tftpdir}/${bootenvfile}\0" \
+    "loadimage_mmc=fatload mmc ${mmcdev}:${mmcpart} ${image_addr} ${image}\0" \
+    "loadimage_usb=fatload usb ${usbdev}:${usbpart} ${image_addr} ${usbbootdir}/${image}\0" \
+    "loadimage_net=tftp ${image_addr} ${serverip}:${tftpdir}/${image}\0" \
+    "loadfdt_mmc=echo loading ${fdtfile}; fatload mmc ${mmcdev}:${mmcpart} ${dtb_addr} ${fdtfile}\0" \
+    "loadfdt_usb=echo loading ${fdtfile}; fatload usb ${usbdev}:${usbpart} ${dtb_addr} ${usbbootdir}/${fdtfile}\0" \
+    "loadfdt_net=echo loading ${fdtfile}; tftp ${dtb_addr} ${serverip}:${tftpdir}/${fdtfile}\0" \
+    "loadcpio_usb=echo loading ${cpiofile}; fatload usb ${usbdev}:${usbpart} ${rd_addr} ${usbbootdir}/${cpiofile}\0" \
+    GET_IMAGE_MMC \
+    GET_IMAGE_USB \
+    GET_IMAGE_NET \
+    "boot_mmc="BOOT_MMC"\0" \
+    "boot_usb="BOOT_USB"\0" \
+    "boot_net="BOOT_NET"\0"
+
+#define CONFIG_BOOTCOMMAND \
+        BOOT_USB    \
+        BOOT_MMC    \
+        BOOT_NET
+
+/* For board */
+/* Ethernet RAVB */
+#define CONFIG_BITBANGMII_MULTI
+
+#endif /* __VK_D184280E_H */
diff --git a/include/configs/vkcmg2lc.h b/include/configs/vkcmg2lc.h
new file mode 100644
index 0000000000..d3cc77da3a
--- /dev/null
+++ b/include/configs/vkcmg2lc.h
@@ -0,0 +1,247 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (C) 2021 Renesas Electronics Corporation
+ */
+
+#ifndef __VKCMG2LC_H
+#define __VKCMG2LC_H
+
+#include <asm/arch/rmobile.h>
+#include "vk_fdt_overlay.h"
+
+#define __p(x)   x
+
+#define CONFIG_REMAKE_ELF
+
+#ifdef CONFIG_SPL
+#define CONFIG_SPL_TARGET   "spl/u-boot-spl.scif"
+#endif
+
+/* boot option */
+
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+
+/* Generic Interrupt Controller Definitions */
+/* RZ/G2L use GIC-v3 */
+#define CONFIG_GICV3
+#define GICD_BASE   0x11900000
+#define GICR_BASE   0x11960000
+
+/* console */
+#define CONFIG_SYS_CBSIZE       2048
+#define CONFIG_SYS_BARGSIZE     CONFIG_SYS_CBSIZE
+#define CONFIG_SYS_MAXARGS      64
+#define CONFIG_SYS_BAUDRATE_TABLE   { 115200, 38400 }
+
+/* PHY needs a longer autoneg timeout */
+#define PHY_ANEG_TIMEOUT        20000
+
+/* MEMORY */
+#define CONFIG_SYS_INIT_SP_ADDR     CONFIG_SYS_TEXT_BASE
+
+/* SDHI clock freq */
+#define CONFIG_SH_SDHI_FREQ     133000000
+
+#define DRAM_RSV_SIZE           0x08000000
+
+#define CONFIG_SYS_SDRAM_BASE       (0x40000000 + DRAM_RSV_SIZE)
+#if CONFIG_TARGET_VKCMG2LC_1
+# define CONFIG_SYS_SDRAM_SIZE       (0x40000000u - DRAM_RSV_SIZE) //total 1GB
+#else
+# define CONFIG_SYS_SDRAM_SIZE       (0x80000000u - DRAM_RSV_SIZE) //total 2GB
+#endif
+
+#define CONFIG_SYS_LOAD_ADDR        0x58000000
+#define CONFIG_LOADADDR         CONFIG_SYS_LOAD_ADDR // Default load address for tfpt,bootp...
+#define CONFIG_VERY_BIG_RAM
+
+#if CONFIG_TARGET_VKCMG2LC_1
+# define CONFIG_MAX_MEM_MAPPED       (0x40000000u - DRAM_RSV_SIZE)
+#else
+# define CONFIG_MAX_MEM_MAPPED       (0x80000000u - DRAM_RSV_SIZE)
+#endif
+
+#define CONFIG_SYS_MONITOR_BASE     0x00000000
+#define CONFIG_SYS_MONITOR_LEN      (1 * 1024 * 1024)
+#define CONFIG_SYS_MALLOC_LEN       (64 * 1024 * 1024)
+#define CONFIG_SYS_BOOTM_LEN        (64 << 20)
+
+/* The HF/QSPI layout permits up to 1 MiB large bootloader blob */
+#define CONFIG_BOARD_SIZE_LIMIT     1048576
+
+/* I2C configuration */
+#define I2C_VERSACLOCK_ADDR  0x68
+#define I2C_VERSACLOCK_ADDR_LEN 1
+#define I2C_SYS_MODULE    0
+
+#ifndef CONFIG_SYS_I2C_EEPROM_ADDR 
+#define CONFIG_SYS_I2C_EEPROM_ADDR 0x50
+#endif
+#ifndef CONFIG_SYS_I2C_EEPROM_BUS
+#define CONFIG_SYS_I2C_EEPROM_BUS 0
+#endif
+
+#ifndef CONFIG_SYS_I2C_EEPROM_ADDR_LEN
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN 1
+#endif
+
+#define I2C_EEPROM_MAC_ADDR     0x58
+#define ETHER_EEPROM_ADDR       0x9A /* MAC address offset in EEPROM */
+
+#ifdef VEKATECH_UENV_FDTO_SUPPORT
+#define LOAD_FDT_OVERLAYS \
+    OVERLAY_SETTINGS \
+    GET_FDT_OVERLAY_mmc \
+    GET_FDT_OVERLAY_usb \
+    GET_FDT_OVERLAY_net
+#else
+#define LOAD_FDT_OVERLAYS \
+    "loadfdto_mmc=echo overlays are not supported!\0" \
+    "loadfdto_usb=echo overlays are not supported!\0" \
+    "loadfdto_net=echo overlays are not supported!\0"
+#endif
+
+/* Load rzv2l_cm33_rpmsg_demo to run */
+#define CM33_BOOT_ARGS \
+    "dcache off; " \
+    "mmc dev 0; " \
+    "fatload mmc 0:1 0x0001FF80 cm33/rzv2l_cm33_rpmsg_demo_secure_vector.bin; " \
+    "fatload mmc 0:1 0x42EFF440 cm33/rzv2l_cm33_rpmsg_demo_secure_code.bin; " \
+    "fatload mmc 0:1 0x00010000 cm33/rzv2l_cm33_rpmsg_demo_non_secure_vector.bin; " \
+    "fatload mmc 0:1 0x40010000 cm33/rzv2l_cm33_rpmsg_demo_non_secure_code.bin; " \
+    "cm33 start_debug 0x1001FF80 0x00010000; " \
+    "dcache on;"
+
+#define DEFAULT_MMC_UENV_ARGS \
+    "boardID="CONFIG_SYS_BOARD"\0" \
+    "image=Image\0" \
+    "fdtfile="CONFIG_DEFAULT_FDT_FILE"\0" \
+    "dtb_addr=0x48000000\0" \
+    "image_addr=0x48080000\0" \
+    "bootm_size=0x10000000\0" \
+    "loadaddr=0x58000000\0" \
+    "rd_addr=0x50000000\0" \
+    "mmcdev="__stringify(CONFIG_SYS_MMC_DEV)"\0" \
+    "mmcpart="__stringify(CONFIG_SYS_MMC_IMG_LOAD_PART)"\0" \
+    "tftpdir="CONFIG_SYS_BOARD"\0" \
+    "netrootfs=/nfs/"CONFIG_SYS_BOARD"\0" \
+    "netmask=255.255.255.0\0" \
+    "serverip=192.168.2.91\0" \
+    "usbdev="__stringify(CONFIG_SYS_USB_DEV)"\0" \
+    "usbpart="__stringify(CONFIG_SYS_USB_IMG_LOAD_PART)"\0" \
+    "usbbootdir=boot\0" \
+    "bootenvfile=uEnv.txt\0" \
+    "importbootenv=echo Importing environment ...; " \
+        "env import -t ${image_addr} ${filesize}\0" \
+    "bootimage=booti ${image_addr} - ${dtb_addr}\0" \
+    "bootimagerd=booti ${image_addr} ${rd_addr} ${dtb_addr}\0" \
+    "rdinitapp=/home/root/emmc_prog\0" \
+    "cpiofile=core-image-bsp-"CONFIG_SYS_BOARD"-mod.cpio.gz.u-boot\0"
+
+#define DEFAULT_MMC_CMG2LC_ARGS  DEFAULT_MMC_UENV_ARGS
+
+#define GET_IMAGE_USB \
+    "load_usb=echo trying usb...; "          \
+          "usb start; "                      \
+          "usb reset; "                      \
+          "if usb dev ${usbdev}; then "      \
+             "if run loadbootenv_usb; then " \
+                 "run importbootenv; "       \
+             "fi; "                          \
+             "if run loadfdt_usb; then "     \
+                "run loadfdto_usb; "          \
+                "if run loadimage_usb; then " \
+                    "run loadcpio_usb; "     \
+                "fi; "                       \
+             "fi; "                          \
+          "fi;\0"
+
+#define GET_IMAGE_MMC \
+    "load_mmc=echo trying mmc...; "               \
+            "if mmc dev ${mmcdev}; then "         \
+              "if mmc rescan; then "              \
+                  "if run loadbootenv_mmc; then " \
+                      "run importbootenv; "       \
+                  "fi; "                          \
+                  "if run loadfdt_mmc; then "     \
+                      "run loadfdto_mmc; "        \
+                      "run loadimage_mmc; "       \
+                  "fi; "                          \
+              "fi; "                              \
+            "fi;\0"
+
+#define GET_IMAGE_NET \
+    "load_net=echo trying net...; "         \
+            "setenv autoload no; dhcp; "    \
+            "if run loadbootenv_net; then " \
+                "run importbootenv; "       \
+            "fi; "                          \
+            "if run loadfdt_net; then "     \
+                "run loadfdto_net; "        \
+                "run loadimage_net; "       \
+            "fi;\0"
+
+#define BOOT_MMC                        \
+    "if run load_mmc; then "            \
+        "echo Starting from mmc ...; "  \
+        "run bootargs_mmc; "            \
+        "run bootimage; "               \
+    "else "                             \
+        "echo Cannot start from mmc!; " \
+    "fi; "
+
+#define BOOT_USB \
+    "if run load_usb; then "            \
+        "echo Starting from usb ...; "  \
+        "run bootargs_usb; "            \
+        "run bootimagerd; "             \
+    "else "                             \
+        "echo Cannot start from usb!; " \
+    "fi; "
+
+#define BOOT_NET \
+    "if run load_net; then "            \
+        "echo Starting from net ...; "  \
+        "run bootargs_net; "            \
+        "run bootimage; "               \
+    "else "                             \
+        "echo Cannot start from net!; " \
+    "fi; "
+
+/* ENV setting */
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+    DEFAULT_MMC_CMG2LC_ARGS \
+    LOAD_FDT_OVERLAYS \
+    "bootargs_mmc=setenv bootargs rw rootwait earlycon root=/dev/mmcblk"__stringify(CONFIG_SYS_MMC_DEV)"p2 ${extrabootargs}\0" \
+    "bootargs_net=setenv bootargs rw rootwait earlycon root=/dev/nfs ip=dhcp nfsroot=${serverip}:${netrootfs},vers=4,tcp ${extrabootargs}\0" \
+    "bootargs_usb=setenv bootargs rw rootwait earlycon root=/dev/ram0 rdinit=${rdinitapp} ${extrabootargs}\0" \
+    "loadbootenv_mmc=fatload mmc ${mmcdev} ${image_addr} ${bootenvfile}\0" \
+    "loadbootenv_usb=fatload usb ${usbdev} ${image_addr} ${bootenvfile}\0" \
+    "loadbootenv_net=tftp ${image_addr} ${serverip}:${tftpdir}/${bootenvfile}\0" \
+    "loadimage_mmc=fatload mmc ${mmcdev}:${mmcpart} ${image_addr} ${image}\0" \
+    "loadimage_usb=fatload usb ${usbdev}:${usbpart} ${image_addr} ${usbbootdir}/${image}\0" \
+    "loadimage_net=tftp ${image_addr} ${serverip}:${tftpdir}/${image}\0" \
+    "loadfdt_mmc=echo loading ${fdtfile}; fatload mmc ${mmcdev}:${mmcpart} ${dtb_addr} ${fdtfile}\0" \
+    "loadfdt_usb=echo loading ${fdtfile}; fatload usb ${usbdev}:${usbpart} ${dtb_addr} ${usbbootdir}/${fdtfile}\0" \
+    "loadfdt_net=echo loading ${fdtfile}; tftp ${dtb_addr} ${serverip}:${tftpdir}/${fdtfile}\0" \
+    "loadcpio_usb=echo loading ${cpiofile}; fatload usb ${usbdev}:${usbpart} ${rd_addr} ${usbbootdir}/${cpiofile}\0" \
+    GET_IMAGE_MMC \
+    GET_IMAGE_USB \
+    GET_IMAGE_NET \
+    "boot_mmc="BOOT_MMC"\0" \
+    "boot_usb="BOOT_USB"\0" \
+    "boot_net="BOOT_NET"\0"
+
+#define CONFIG_BOOTCOMMAND \
+        BOOT_USB    \
+        BOOT_MMC    \
+        BOOT_NET
+
+/* For board */
+/* Ethernet RAVB */
+#define CONFIG_BITBANGMII_MULTI
+
+#endif /* __VKCMG2LC_H */
diff --git a/include/configs/vkcmv2l.h b/include/configs/vkcmv2l.h
new file mode 100644
index 0000000000..eaab43b7f8
--- /dev/null
+++ b/include/configs/vkcmv2l.h
@@ -0,0 +1,246 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (C) 2021 Renesas Electronics Corporation
+ */
+
+#ifndef __VKCMV2L_H__
+#define __VKCMV2L_H__
+
+#include <asm/arch/rmobile.h>
+#include "vk_fdt_overlay.h"
+
+#define __p(x)   x
+
+#define CONFIG_REMAKE_ELF
+
+#ifdef CONFIG_SPL
+#define CONFIG_SPL_TARGET   "spl/u-boot-spl.scif"
+#endif
+
+/* boot option */
+
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+
+/* Generic Interrupt Controller Definitions */
+/* RZ/V2L use GIC-v3 */
+#define CONFIG_GICV3
+#define GICD_BASE   0x11900000
+#define GICR_BASE   0x11960000
+
+/* console */
+#define CONFIG_SYS_CBSIZE       2048
+#define CONFIG_SYS_BARGSIZE     CONFIG_SYS_CBSIZE
+#define CONFIG_SYS_MAXARGS      64
+#define CONFIG_SYS_BAUDRATE_TABLE   { 115200, 38400 }
+
+/* PHY needs a longer autoneg timeout */
+#define PHY_ANEG_TIMEOUT        20000
+
+/* MEMORY */
+#define CONFIG_SYS_INIT_SP_ADDR     CONFIG_SYS_TEXT_BASE
+
+/* SDHI clock freq */
+#define CONFIG_SH_SDHI_FREQ     133000000
+
+#define DRAM_RSV_SIZE           0x08000000
+#define CONFIG_SYS_SDRAM_BASE       (0x40000000 + DRAM_RSV_SIZE)
+//#define CONFIG_SYS_SDRAM_SIZE       (0x40000000u - DRAM_RSV_SIZE) //total 1GB
+#define CONFIG_SYS_SDRAM_SIZE       (0x80000000u - DRAM_RSV_SIZE) //total 2GB
+#define CONFIG_SYS_LOAD_ADDR        0x58000000
+#define CONFIG_LOADADDR         CONFIG_SYS_LOAD_ADDR // Default load address for tfpt,bootp...
+#define CONFIG_VERY_BIG_RAM
+//#define CONFIG_MAX_MEM_MAPPED       (0x40000000u - DRAM_RSV_SIZE)
+#define CONFIG_MAX_MEM_MAPPED       (0x80000000u - DRAM_RSV_SIZE)
+
+#define CONFIG_SYS_MONITOR_BASE     0x00000000
+#define CONFIG_SYS_MONITOR_LEN      (1 * 1024 * 1024)
+#define CONFIG_SYS_MALLOC_LEN       (64 * 1024 * 1024)
+#define CONFIG_SYS_BOOTM_LEN        (64 << 20)
+
+/* The HF/QSPI layout permits up to 1 MiB large bootloader blob */
+#define CONFIG_BOARD_SIZE_LIMIT     1048576
+
+/* I2C configuration */
+#define I2C_VERSACLOCK_ADDR  0x68
+#define I2C_VERSACLOCK_ADDR_LEN 1
+#define I2C_SYS_MODULE    3
+
+#ifndef CONFIG_SYS_I2C_EEPROM_ADDR 
+#define CONFIG_SYS_I2C_EEPROM_ADDR 0x50
+#endif
+#ifndef CONFIG_SYS_I2C_EEPROM_BUS
+#define CONFIG_SYS_I2C_EEPROM_BUS 3
+#endif
+
+#ifndef CONFIG_SYS_I2C_EEPROM_ADDR_LEN
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN 1
+#endif
+
+#define I2C_EEPROM_MAC_ADDR     0x58
+#define ETHER_EEPROM_ADDR       0x9A /* MAC address offset in EEPROM */
+
+#define ETHER_EEPROM_ADDR0    (256-12) /* MAC address offset in EEPROM */
+#define ETHER_EEPROM_ADDR1    (256-6) /* MAC address offset in EEPROM */
+//#define ETHER_DEFAULT_MACADDR   "00:12:F0:32:87:4F"
+
+//#define CONFIG_OPENCVA 1
+
+#ifdef VEKATECH_UENV_FDTO_SUPPORT
+#define LOAD_FDT_OVERLAYS \
+    OVERLAY_SETTINGS \
+    GET_FDT_OVERLAY_mmc \
+    GET_FDT_OVERLAY_usb \
+    GET_FDT_OVERLAY_net
+#else
+#define LOAD_FDT_OVERLAYS \
+    "loadfdto_mmc=echo overlays are not supported!\0" \
+    "loadfdto_usb=echo overlays are not supported!\0" \
+    "loadfdto_net=echo overlays are not supported!\0"
+#endif
+
+/* Load rzv2l_cm33_rpmsg_demo to run */
+#define CM33_BOOT_ARGS \
+    "dcache off; " \
+    "mmc dev 0; " \
+    "fatload mmc 0:1 0x0001FF80 cm33/rzv2l_cm33_rpmsg_demo_secure_vector.bin; " \
+    "fatload mmc 0:1 0x42EFF440 cm33/rzv2l_cm33_rpmsg_demo_secure_code.bin; " \
+    "fatload mmc 0:1 0x00010000 cm33/rzv2l_cm33_rpmsg_demo_non_secure_vector.bin; " \
+    "fatload mmc 0:1 0x40010000 cm33/rzv2l_cm33_rpmsg_demo_non_secure_code.bin; " \
+    "cm33 start_debug 0x1001FF80 0x00010000; " \
+    "dcache on;"
+
+/* ENV setting */
+
+#define DEFAULT_MMC_UENV_ARGS \
+    "boardID="CONFIG_SYS_BOARD"\0" \
+    "image=Image\0" \
+    "fdtfile="CONFIG_DEFAULT_FDT_FILE"\0" \
+    "dtb_addr=0x48000000\0" \
+    "image_addr=0x48080000\0" \
+    "bootm_size=0x10000000\0" \
+    "loadaddr=0x58000000\0" \
+    "rd_addr=0x50000000\0" \
+    "mmcdev="__stringify(CONFIG_SYS_MMC_DEV)"\0" \
+    "mmcpart="__stringify(CONFIG_SYS_MMC_IMG_LOAD_PART)"\0" \
+    "tftpdir="CONFIG_SYS_BOARD"\0" \
+    "netrootfs=/nfs/"CONFIG_SYS_BOARD"\0" \
+    "netmask=255.255.255.0\0" \
+    "serverip=192.168.2.91\0" \
+    "usbdev="__stringify(CONFIG_SYS_USB_DEV)"\0" \
+    "usbpart="__stringify(CONFIG_SYS_USB_IMG_LOAD_PART)"\0" \
+    "usbbootdir=boot\0" \
+    "bootenvfile=uEnv.txt\0" \
+    "importbootenv=echo Importing environment ...; " \
+        "env import -t ${image_addr} ${filesize}\0" \
+    "bootimage=booti ${image_addr} - ${dtb_addr}\0" \
+    "bootimagerd=booti ${image_addr} ${rd_addr} ${dtb_addr}\0" \
+    "rdinitapp=/home/root/emmc_prog\0" \
+    "cpiofile=core-image-bsp-"CONFIG_SYS_BOARD"-mod.cpio.gz.u-boot\0"
+
+#define DEFAULT_MMC_CMV2L_ARGS  DEFAULT_MMC_UENV_ARGS
+
+#define GET_IMAGE_USB \
+    "load_usb=echo trying usb...; "          \
+          "usb start; "                      \
+          "usb reset; "                      \
+          "if usb dev ${usbdev}; then "      \
+             "if run loadbootenv_usb; then " \
+                 "run importbootenv; "       \
+             "fi; "                          \
+             "if run loadfdt_usb; then "     \
+                "run loadfdto_usb; "          \
+                "if run loadimage_usb; then " \
+                    "run loadcpio_usb; "     \
+                "fi; "                       \
+             "fi; "                          \
+          "fi;\0"
+
+#define GET_IMAGE_MMC \
+    "load_mmc=echo trying mmc...; "               \
+            "if mmc dev ${mmcdev}; then "         \
+              "if mmc rescan; then "              \
+                  "if run loadbootenv_mmc; then " \
+                      "run importbootenv; "       \
+                  "fi; "                          \
+                  "if run loadfdt_mmc; then "     \
+                      "run loadfdto_mmc; "        \
+                      "run loadimage_mmc; "       \
+                  "fi; "                          \
+              "fi; "                              \
+            "fi;\0"
+
+#define GET_IMAGE_NET \
+    "load_net=echo trying net...; "         \
+            "setenv autoload no; dhcp; "    \
+            "if run loadbootenv_net; then " \
+                "run importbootenv; "       \
+            "fi; "                          \
+            "if run loadfdt_net; then "     \
+                "run loadfdto_net; "        \
+                "run loadimage_net; "       \
+            "fi;\0"
+
+#define BOOT_MMC                        \
+    "if run load_mmc; then "            \
+        "echo Starting from mmc ...; "  \
+        "run bootargs_mmc; "            \
+        "run bootimage; "               \
+    "else "                             \
+        "echo Cannot start from mmc!; " \
+    "fi; "
+
+#define BOOT_USB \
+    "if run load_usb; then "            \
+        "echo Starting from usb ...; "  \
+        "run bootargs_usb; "            \
+        "run bootimagerd; "             \
+    "else "                             \
+        "echo Cannot start from usb!; " \
+    "fi; "
+
+#define BOOT_NET \
+    "if run load_net; then "            \
+        "echo Starting from net ...; "  \
+        "run bootargs_net; "            \
+        "run bootimage; "               \
+    "else "                             \
+        "echo Cannot start from net!; " \
+    "fi; "
+
+/* ENV setting */
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+    DEFAULT_MMC_CMV2L_ARGS \
+    LOAD_FDT_OVERLAYS \
+    "bootargs_mmc=setenv bootargs rw rootwait earlycon root=/dev/mmcblk"__stringify(CONFIG_SYS_MMC_DEV)"p2 ${extrabootargs}\0" \
+    "bootargs_net=setenv bootargs rw rootwait earlycon root=/dev/nfs ip=dhcp nfsroot=${serverip}:${netrootfs},vers=4,tcp ${extrabootargs}\0" \
+    "bootargs_usb=setenv bootargs rw rootwait earlycon root=/dev/ram0 rdinit=${rdinitapp} ${extrabootargs}\0" \
+    "loadbootenv_mmc=fatload mmc ${mmcdev} ${image_addr} ${bootenvfile}\0" \
+    "loadbootenv_usb=fatload usb ${usbdev} ${image_addr} ${bootenvfile}\0" \
+    "loadbootenv_net=tftp ${image_addr} ${serverip}:${tftpdir}/${bootenvfile}\0" \
+    "loadimage_mmc=fatload mmc ${mmcdev}:${mmcpart} ${image_addr} ${image}\0" \
+    "loadimage_usb=fatload usb ${usbdev}:${usbpart} ${image_addr} ${usbbootdir}/${image}\0" \
+    "loadimage_net=tftp ${image_addr} ${serverip}:${tftpdir}/${image}\0" \
+    "loadfdt_mmc=echo loading ${fdtfile}; fatload mmc ${mmcdev}:${mmcpart} ${dtb_addr} ${fdtfile}\0" \
+    "loadfdt_usb=echo loading ${fdtfile}; fatload usb ${usbdev}:${usbpart} ${dtb_addr} ${usbbootdir}/${fdtfile}\0" \
+    "loadfdt_net=echo loading ${fdtfile}; tftp ${dtb_addr} ${serverip}:${tftpdir}/${fdtfile}\0" \
+    "loadcpio_usb=echo loading ${cpiofile}; fatload usb ${usbdev}:${usbpart} ${rd_addr} ${usbbootdir}/${cpiofile}\0" \
+    GET_IMAGE_MMC \
+    GET_IMAGE_USB \
+    GET_IMAGE_NET \
+    "boot_mmc="BOOT_MMC"\0" \
+    "boot_usb="BOOT_USB"\0" \
+    "boot_net="BOOT_NET"\0"
+
+#define CONFIG_BOOTCOMMAND \
+        BOOT_USB    \
+        BOOT_MMC    \
+        BOOT_NET
+
+/* For board */
+/* Ethernet RAVB */
+#define CONFIG_BITBANGMII_MULTI
+
+#endif /* __VKCMV2L_H__ */
diff --git a/include/configs/vkrzg2l.h b/include/configs/vkrzg2l.h
new file mode 100644
index 0000000000..364f280903
--- /dev/null
+++ b/include/configs/vkrzg2l.h
@@ -0,0 +1,227 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (C) 2021 Renesas Electronics Corporation
+ */
+
+#ifndef __VKRZG2L_H__
+#define __VKRZG2L_H__
+
+#include <asm/arch/rmobile.h>
+#include "vk_fdt_overlay.h"
+
+#define __p(x)   x
+
+#define CONFIG_REMAKE_ELF
+
+#ifdef CONFIG_SPL
+#define CONFIG_SPL_TARGET   "spl/u-boot-spl.scif"
+#endif
+
+/* boot option */
+
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+
+/* Generic Interrupt Controller Definitions */
+/* RZ/G2L use GIC-v3 */
+#define CONFIG_GICV3
+#define GICD_BASE   0x11900000
+#define GICR_BASE   0x11960000
+
+/* console */
+#define CONFIG_SYS_CBSIZE       2048
+#define CONFIG_SYS_BARGSIZE     CONFIG_SYS_CBSIZE
+#define CONFIG_SYS_MAXARGS      64
+#define CONFIG_SYS_BAUDRATE_TABLE   { 115200, 38400 }
+
+/* PHY needs a longer autoneg timeout */
+#define PHY_ANEG_TIMEOUT        20000
+
+/* MEMORY */
+#define CONFIG_SYS_INIT_SP_ADDR     CONFIG_SYS_TEXT_BASE
+
+/* SDHI clock freq */
+#define CONFIG_SH_SDHI_FREQ     133000000
+
+#define DRAM_RSV_SIZE           0x08000000
+#define CONFIG_SYS_SDRAM_BASE       (0x40000000 + DRAM_RSV_SIZE)
+//#define CONFIG_SYS_SDRAM_SIZE       (0x40000000u - DRAM_RSV_SIZE) //total 1GB
+#define CONFIG_SYS_SDRAM_SIZE       (0x80000000u - DRAM_RSV_SIZE) //total 2GB
+#define CONFIG_SYS_LOAD_ADDR        0x58000000
+#define CONFIG_LOADADDR         CONFIG_SYS_LOAD_ADDR // Default load address for tfpt,bootp...
+#define CONFIG_VERY_BIG_RAM
+//#define CONFIG_MAX_MEM_MAPPED       (0x40000000u - DRAM_RSV_SIZE)
+#define CONFIG_MAX_MEM_MAPPED       (0x80000000u - DRAM_RSV_SIZE)
+
+#define CONFIG_SYS_MONITOR_BASE     0x00000000
+#define CONFIG_SYS_MONITOR_LEN      (1 * 1024 * 1024)
+#define CONFIG_SYS_MALLOC_LEN       (64 * 1024 * 1024)
+#define CONFIG_SYS_BOOTM_LEN        (64 << 20)
+
+/* The HF/QSPI layout permits up to 1 MiB large bootloader blob */
+#define CONFIG_BOARD_SIZE_LIMIT     1048576
+
+/* I2C configuration */
+#define I2C_VERSACLOCK_ADDR  0x68
+#define I2C_VERSACLOCK_ADDR_LEN 1
+#define I2C_SYS_MODULE    3
+
+
+#ifdef VEKATECH_UENV_FDTO_SUPPORT
+#define LOAD_FDT_OVERLAYS \
+    OVERLAY_SETTINGS \
+    GET_FDT_OVERLAY_mmc \
+    GET_FDT_OVERLAY_usb \
+    GET_FDT_OVERLAY_net
+#else
+#define LOAD_FDT_OVERLAYS \
+    "loadfdto_mmc=echo overlays are not supported!\0" \
+    "loadfdto_usb=echo overlays are not supported!\0" \
+    "loadfdto_net=echo overlays are not supported!\0"
+#endif
+
+/* Load rzv2l_cm33_rpmsg_demo to run */
+#define CM33_BOOT_ARGS \
+    "dcache off; " \
+    "mmc dev 0; " \
+    "fatload mmc 0:1 0x0001FF80 cm33/rzv2l_cm33_rpmsg_demo_secure_vector.bin; " \
+    "fatload mmc 0:1 0x42EFF440 cm33/rzv2l_cm33_rpmsg_demo_secure_code.bin; " \
+    "fatload mmc 0:1 0x00010000 cm33/rzv2l_cm33_rpmsg_demo_non_secure_vector.bin; " \
+    "fatload mmc 0:1 0x40010000 cm33/rzv2l_cm33_rpmsg_demo_non_secure_code.bin; " \
+    "cm33 start_debug 0x1001FF80 0x00010000; " \
+    "dcache on;"
+
+/* ENV setting */
+
+#define DEFAULT_MMC_UENV_ARGS \
+    "boardID="CONFIG_SYS_BOARD"\0" \
+    "image=Image\0" \
+    "fdtfile="CONFIG_DEFAULT_FDT_FILE"\0" \
+    "dtb_addr=0x48000000\0" \
+    "image_addr=0x48080000\0" \
+    "bootm_size=0x10000000\0" \
+    "loadaddr=0x58000000\0" \
+    "rd_addr=0x50000000\0" \
+    "mmcdev="__stringify(CONFIG_SYS_MMC_DEV)"\0" \
+    "mmcpart="__stringify(CONFIG_SYS_MMC_IMG_LOAD_PART)"\0" \
+    "tftpdir="CONFIG_SYS_BOARD"\0" \
+    "netrootfs=/nfs/"CONFIG_SYS_BOARD"\0" \
+    "netmask=255.255.255.0\0" \
+    "serverip=192.168.2.91\0" \
+    "usbdev="__stringify(CONFIG_SYS_USB_DEV)"\0" \
+    "usbpart="__stringify(CONFIG_SYS_USB_IMG_LOAD_PART)"\0" \
+    "usbbootdir=boot\0" \
+    "bootenvfile=uEnv.txt\0" \
+    "importbootenv=echo Importing environment ...; " \
+        "env import -t ${image_addr} ${filesize}\0" \
+    "bootimage=booti ${image_addr} - ${dtb_addr}\0" \
+    "bootimagerd=booti ${image_addr} ${rd_addr} ${dtb_addr}\0" \
+    "rdinitapp=/home/root/emmc_prog\0" \
+    "cpiofile=core-image-bsp-"CONFIG_SYS_BOARD"-mod.cpio.gz.u-boot\0"
+
+#define DEFAULT_MMC_RZG2LC_ARGS  DEFAULT_MMC_UENV_ARGS
+
+#define GET_IMAGE_USB \
+    "load_usb=echo trying usb...; "          \
+          "usb start; "                      \
+          "usb reset; "                      \
+          "if usb dev ${usbdev}; then "      \
+             "if run loadbootenv_usb; then " \
+                 "run importbootenv; "       \
+             "fi; "                          \
+             "if run loadfdt_usb; then "     \
+                "run loadfdto_usb; "          \
+                "if run loadimage_usb; then " \
+                    "run loadcpio_usb; "     \
+                "fi; "                       \
+             "fi; "                          \
+          "fi;\0"
+
+#define GET_IMAGE_MMC \
+    "load_mmc=echo trying mmc...; "               \
+            "if mmc dev ${mmcdev}; then "         \
+              "if mmc rescan; then "              \
+                  "if run loadbootenv_mmc; then " \
+                      "run importbootenv; "       \
+                  "fi; "                          \
+                  "if run loadfdt_mmc; then "     \
+                      "run loadfdto_mmc; "        \
+                      "run loadimage_mmc; "       \
+                  "fi; "                          \
+              "fi; "                              \
+            "fi;\0"
+
+#define GET_IMAGE_NET \
+    "load_net=echo trying net...; "         \
+            "setenv autoload no; dhcp; "    \
+            "if run loadbootenv_net; then " \
+                "run importbootenv; "       \
+            "fi; "                          \
+            "if run loadfdt_net; then "     \
+                "run loadfdto_net; "        \
+                "run loadimage_net; "       \
+            "fi;\0"
+
+#define BOOT_MMC                        \
+    "if run load_mmc; then "            \
+        "echo Starting from mmc ...; "  \
+        "run bootargs_mmc; "            \
+        "run bootimage; "               \
+    "else "                             \
+        "echo Cannot start from mmc!; " \
+    "fi; "
+
+#define BOOT_USB \
+    "if run load_usb; then "            \
+        "echo Starting from usb ...; "  \
+        "run bootargs_usb; "            \
+        "run bootimagerd; "             \
+    "else "                             \
+        "echo Cannot start from usb!; " \
+    "fi; "
+
+#define BOOT_NET \
+    "if run load_net; then "            \
+        "echo Starting from net ...; "  \
+        "run bootargs_net; "            \
+        "run bootimage; "               \
+    "else "                             \
+        "echo Cannot start from net!; " \
+    "fi; "
+
+/* ENV setting */
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+    DEFAULT_MMC_RZG2LC_ARGS \
+    LOAD_FDT_OVERLAYS \
+    "bootargs_mmc=setenv bootargs rw rootwait earlycon root=/dev/mmcblk"__stringify(CONFIG_SYS_MMC_DEV)"p2 ${extrabootargs}\0" \
+    "bootargs_net=setenv bootargs rw rootwait earlycon root=/dev/nfs ip=dhcp nfsroot=${serverip}:${netrootfs},vers=4,tcp ${extrabootargs}\0" \
+    "bootargs_usb=setenv bootargs rw rootwait earlycon root=/dev/ram0 rdinit=${rdinitapp} ${extrabootargs}\0" \
+    "loadbootenv_mmc=fatload mmc ${mmcdev} ${image_addr} ${bootenvfile}\0" \
+    "loadbootenv_usb=fatload usb ${usbdev} ${image_addr} ${bootenvfile}\0" \
+    "loadbootenv_net=tftp ${image_addr} ${serverip}:${tftpdir}/${bootenvfile}\0" \
+    "loadimage_mmc=fatload mmc ${mmcdev}:${mmcpart} ${image_addr} ${image}\0" \
+    "loadimage_usb=fatload usb ${usbdev}:${usbpart} ${image_addr} ${usbbootdir}/${image}\0" \
+    "loadimage_net=tftp ${image_addr} ${serverip}:${tftpdir}/${image}\0" \
+    "loadfdt_mmc=echo loading ${fdtfile}; fatload mmc ${mmcdev}:${mmcpart} ${dtb_addr} ${fdtfile}\0" \
+    "loadfdt_usb=echo loading ${fdtfile}; fatload usb ${usbdev}:${usbpart} ${dtb_addr} ${usbbootdir}/${fdtfile}\0" \
+    "loadfdt_net=echo loading ${fdtfile}; tftp ${dtb_addr} ${serverip}:${tftpdir}/${fdtfile}\0" \
+    "loadcpio_usb=echo loading ${cpiofile}; fatload usb ${usbdev}:${usbpart} ${rd_addr} ${usbbootdir}/${cpiofile}\0" \
+    GET_IMAGE_MMC \
+    GET_IMAGE_USB \
+    GET_IMAGE_NET \
+    "boot_mmc="BOOT_MMC"\0" \
+    "boot_usb="BOOT_USB"\0" \
+    "boot_net="BOOT_NET"\0"
+
+#define CONFIG_BOOTCOMMAND \
+        BOOT_USB    \
+        BOOT_MMC    \
+        BOOT_NET
+
+/* For board */
+/* Ethernet RAVB */
+#define CONFIG_BITBANGMII_MULTI
+
+#endif /* __VKRZG2L_H__ */
diff --git a/include/configs/vkrzg2lc.h b/include/configs/vkrzg2lc.h
new file mode 100644
index 0000000000..5e08e0dee1
--- /dev/null
+++ b/include/configs/vkrzg2lc.h
@@ -0,0 +1,238 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (C) 2024 Vekatech Ltd.
+ */
+
+#ifndef __VKRZG2LC_H
+#define __VKRZG2LC_H
+
+#include <asm/arch/rmobile.h>
+#include "vk_fdt_overlay.h"
+
+#define __p(x)   x
+
+#define CONFIG_REMAKE_ELF
+
+#ifdef CONFIG_SPL
+#define CONFIG_SPL_TARGET   "spl/u-boot-spl.scif"
+#endif
+
+/* boot option */
+
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+
+/* Generic Interrupt Controller Definitions */
+/* RZ/G2L use GIC-v3 */
+#define CONFIG_GICV3
+#define GICD_BASE   0x11900000
+#define GICR_BASE   0x11960000
+
+/* console */
+#define CONFIG_SYS_CBSIZE       2048
+#define CONFIG_SYS_BARGSIZE     CONFIG_SYS_CBSIZE
+#define CONFIG_SYS_MAXARGS      64
+#define CONFIG_SYS_BAUDRATE_TABLE   { 115200, 38400 }
+
+/* PHY needs a longer autoneg timeout */
+#define PHY_ANEG_TIMEOUT        20000
+
+/* MEMORY */
+#define CONFIG_SYS_INIT_SP_ADDR     CONFIG_SYS_TEXT_BASE
+
+/* SDHI clock freq */
+#define CONFIG_SH_SDHI_FREQ     133000000
+
+#define DRAM_RSV_SIZE           0x08000000
+#define CONFIG_SYS_SDRAM_BASE       (0x40000000 + DRAM_RSV_SIZE)
+//#define CONFIG_SYS_SDRAM_SIZE       (0x40000000u - DRAM_RSV_SIZE) //total 1GB
+#define CONFIG_SYS_SDRAM_SIZE       (0x80000000u - DRAM_RSV_SIZE) //total 2GB
+#define CONFIG_SYS_LOAD_ADDR        0x58000000
+#define CONFIG_LOADADDR         CONFIG_SYS_LOAD_ADDR // Default load address for tfpt,bootp...
+#define CONFIG_VERY_BIG_RAM
+//#define CONFIG_MAX_MEM_MAPPED       (0x40000000u - DRAM_RSV_SIZE)
+#define CONFIG_MAX_MEM_MAPPED       (0x80000000u - DRAM_RSV_SIZE)
+
+#define CONFIG_SYS_MONITOR_BASE     0x00000000
+#define CONFIG_SYS_MONITOR_LEN      (1 * 1024 * 1024)
+#define CONFIG_SYS_MALLOC_LEN       (64 * 1024 * 1024)
+#define CONFIG_SYS_BOOTM_LEN        (64 << 20)
+
+/* The HF/QSPI layout permits up to 1 MiB large bootloader blob */
+#define CONFIG_BOARD_SIZE_LIMIT     1048576
+
+/* I2C configuration */
+#define I2C_VERSACLOCK_ADDR  0x68
+#define I2C_VERSACLOCK_ADDR_LEN 1
+#define I2C_SYS_MODULE    0
+
+#ifndef CONFIG_SYS_I2C_EEPROM_ADDR 
+#define CONFIG_SYS_I2C_EEPROM_ADDR 0x50
+#endif
+#ifndef CONFIG_SYS_I2C_EEPROM_BUS
+#define CONFIG_SYS_I2C_EEPROM_BUS 0
+#endif
+
+#ifndef CONFIG_SYS_I2C_EEPROM_ADDR_LEN
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN 1
+#endif
+
+#define I2C_EEPROM_MAC_ADDR     0x58
+#define ETHER_EEPROM_ADDR       0x9A /* MAC address offset in EEPROM */
+
+#ifdef VEKATECH_UENV_FDTO_SUPPORT
+#define LOAD_FDT_OVERLAYS \
+    OVERLAY_SETTINGS \
+    GET_FDT_OVERLAY_mmc \
+    GET_FDT_OVERLAY_usb \
+    GET_FDT_OVERLAY_net
+#else
+#define LOAD_FDT_OVERLAYS \
+    "loadfdto_mmc=echo overlays are not supported!\0" \
+    "loadfdto_usb=echo overlays are not supported!\0" \
+    "loadfdto_net=echo overlays are not supported!\0"
+#endif
+
+/* Load rzv2l_cm33_rpmsg_demo to run */
+#define CM33_BOOT_ARGS \
+    "dcache off; " \
+    "mmc dev 0; " \
+    "fatload mmc 0:1 0x0001FF80 cm33/rzv2l_cm33_rpmsg_demo_secure_vector.bin; " \
+    "fatload mmc 0:1 0x42EFF440 cm33/rzv2l_cm33_rpmsg_demo_secure_code.bin; " \
+    "fatload mmc 0:1 0x00010000 cm33/rzv2l_cm33_rpmsg_demo_non_secure_vector.bin; " \
+    "fatload mmc 0:1 0x40010000 cm33/rzv2l_cm33_rpmsg_demo_non_secure_code.bin; " \
+    "cm33 start_debug 0x1001FF80 0x00010000; " \
+    "dcache on;"
+
+#define DEFAULT_MMC_UENV_ARGS \
+    "boardID="CONFIG_SYS_BOARD"\0" \
+    "image=Image\0" \
+    "fdtfile="CONFIG_DEFAULT_FDT_FILE"\0" \
+    "dtb_addr=0x48000000\0" \
+    "image_addr=0x48080000\0" \
+    "bootm_size=0x10000000\0" \
+    "loadaddr=0x58000000\0" \
+    "rd_addr=0x50000000\0" \
+    "mmcdev="__stringify(CONFIG_SYS_MMC_DEV)"\0" \
+    "mmcpart="__stringify(CONFIG_SYS_MMC_IMG_LOAD_PART)"\0" \
+    "tftpdir="CONFIG_SYS_BOARD"\0" \
+    "netrootfs=/nfs/"CONFIG_SYS_BOARD"\0" \
+    "netmask=255.255.255.0\0" \
+    "serverip=192.168.2.91\0" \
+    "usbdev="__stringify(CONFIG_SYS_USB_DEV)"\0" \
+    "usbpart="__stringify(CONFIG_SYS_USB_IMG_LOAD_PART)"\0" \
+    "usbbootdir=boot\0" \
+    "bootenvfile=uEnv.txt\0" \
+    "importbootenv=echo Importing environment ...; " \
+        "env import -t ${image_addr} ${filesize}\0" \
+    "bootimage=booti ${image_addr} - ${dtb_addr}\0" \
+    "bootimagerd=booti ${image_addr} ${rd_addr} ${dtb_addr}\0" \
+    "rdinitapp=/home/root/emmc_prog\0" \
+    "cpiofile=core-image-bsp-"CONFIG_SYS_BOARD"-mod.cpio.gz.u-boot\0"
+
+#define DEFAULT_MMC_RZG2LC_ARGS  DEFAULT_MMC_UENV_ARGS
+
+#define GET_IMAGE_USB \
+    "load_usb=echo trying usb...; "          \
+          "usb start; "                      \
+          "usb reset; "                      \
+          "if usb dev ${usbdev}; then "      \
+             "if run loadbootenv_usb; then " \
+                 "run importbootenv; "       \
+             "fi; "                          \
+             "if run loadfdt_usb; then "     \
+                "run loadfdto_usb; "          \
+                "if run loadimage_usb; then " \
+                    "run loadcpio_usb; "     \
+                "fi; "                       \
+             "fi; "                          \
+          "fi;\0"
+
+#define GET_IMAGE_MMC \
+    "load_mmc=echo trying mmc...; "               \
+            "if mmc dev ${mmcdev}; then "         \
+              "if mmc rescan; then "              \
+                  "if run loadbootenv_mmc; then " \
+                      "run importbootenv; "       \
+                  "fi; "                          \
+                  "if run loadfdt_mmc; then "     \
+                      "run loadfdto_mmc; "        \
+                      "run loadimage_mmc; "       \
+                  "fi; "                          \
+              "fi; "                              \
+            "fi;\0"
+
+#define GET_IMAGE_NET \
+    "load_net=echo trying net...; "         \
+            "setenv autoload no; dhcp; "    \
+            "if run loadbootenv_net; then " \
+                "run importbootenv; "       \
+            "fi; "                          \
+            "if run loadfdt_net; then "     \
+                "run loadfdto_net; "        \
+                "run loadimage_net; "       \
+            "fi;\0"
+
+#define BOOT_MMC                        \
+    "if run load_mmc; then "            \
+        "echo Starting from mmc ...; "  \
+        "run bootargs_mmc; "            \
+        "run bootimage; "               \
+    "else "                             \
+        "echo Cannot start from mmc!; " \
+    "fi; "
+
+#define BOOT_USB \
+    "if run load_usb; then "            \
+        "echo Starting from usb ...; "  \
+        "run bootargs_usb; "            \
+        "run bootimagerd; "             \
+    "else "                             \
+        "echo Cannot start from usb!; " \
+    "fi; "
+
+#define BOOT_NET \
+    "if run load_net; then "            \
+        "echo Starting from net ...; "  \
+        "run bootargs_net; "            \
+        "run bootimage; "               \
+    "else "                             \
+        "echo Cannot start from net!; " \
+    "fi; "
+
+/* ENV setting */
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+    DEFAULT_MMC_RZG2LC_ARGS \
+    LOAD_FDT_OVERLAYS \
+    "bootargs_mmc=setenv bootargs rw rootwait earlycon root=/dev/mmcblk"__stringify(CONFIG_SYS_MMC_DEV)"p2 ${extrabootargs}\0" \
+    "bootargs_net=setenv bootargs rw rootwait earlycon root=/dev/nfs ip=dhcp nfsroot=${serverip}:${netrootfs},vers=4,tcp ${extrabootargs}\0" \
+    "bootargs_usb=setenv bootargs rw rootwait earlycon root=/dev/ram0 rdinit=${rdinitapp} ${extrabootargs}\0" \
+    "loadbootenv_mmc=fatload mmc ${mmcdev} ${image_addr} ${bootenvfile}\0" \
+    "loadbootenv_usb=fatload usb ${usbdev} ${image_addr} ${bootenvfile}\0" \
+    "loadbootenv_net=tftp ${image_addr} ${serverip}:${tftpdir}/${bootenvfile}\0" \
+    "loadimage_mmc=fatload mmc ${mmcdev}:${mmcpart} ${image_addr} ${image}\0" \
+    "loadimage_usb=fatload usb ${usbdev}:${usbpart} ${image_addr} ${usbbootdir}/${image}\0" \
+    "loadimage_net=tftp ${image_addr} ${serverip}:${tftpdir}/${image}\0" \
+    "loadfdt_mmc=echo loading ${fdtfile}; fatload mmc ${mmcdev}:${mmcpart} ${dtb_addr} ${fdtfile}\0" \
+    "loadfdt_usb=echo loading ${fdtfile}; fatload usb ${usbdev}:${usbpart} ${dtb_addr} ${usbbootdir}/${fdtfile}\0" \
+    "loadfdt_net=echo loading ${fdtfile}; tftp ${dtb_addr} ${serverip}:${tftpdir}/${fdtfile}\0" \
+    "loadcpio_usb=echo loading ${cpiofile}; fatload usb ${usbdev}:${usbpart} ${rd_addr} ${usbbootdir}/${cpiofile}\0" \
+    GET_IMAGE_MMC \
+    GET_IMAGE_USB \
+    GET_IMAGE_NET \
+    "boot_mmc="BOOT_MMC"\0" \
+    "boot_usb="BOOT_USB"\0" \
+    "boot_net="BOOT_NET"\0"
+
+#define CONFIG_BOOTCOMMAND \
+        BOOT_USB    \
+        BOOT_MMC    \
+        BOOT_NET
+
+/* For board */
+/* Ethernet RAVB */
+#define CONFIG_BITBANGMII_MULTI
+
+#endif /* __VKRZG2LC_H */
diff --git a/include/configs/vkrzg2ul.h b/include/configs/vkrzg2ul.h
new file mode 100644
index 0000000000..3266547e39
--- /dev/null
+++ b/include/configs/vkrzg2ul.h
@@ -0,0 +1,235 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (C) 2024 Vekatech Ltd.
+ */
+
+#ifndef __VKRZG2UL_H
+#define __VKRZG2UL_H
+
+#include <asm/arch/rmobile.h>
+#include "vk_fdt_overlay.h"
+
+#define __p(x)   x
+
+#define CONFIG_REMAKE_ELF
+
+#ifdef CONFIG_SPL
+#define CONFIG_SPL_TARGET   "spl/u-boot-spl.scif"
+#endif
+
+/* boot option */
+
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+
+/* Generic Interrupt Controller Definitions */
+/* RZ/G2L use GIC-v3 */
+#define CONFIG_GICV3
+#define GICD_BASE   0x11900000
+#define GICR_BASE   0x11960000
+
+/* console */
+#define CONFIG_SYS_CBSIZE       2048
+#define CONFIG_SYS_BARGSIZE     CONFIG_SYS_CBSIZE
+#define CONFIG_SYS_MAXARGS      64
+#define CONFIG_SYS_BAUDRATE_TABLE   { 115200, 38400 }
+
+/* PHY needs a longer autoneg timeout */
+#define PHY_ANEG_TIMEOUT        20000
+
+/* MEMORY */
+#define CONFIG_SYS_INIT_SP_ADDR     CONFIG_SYS_TEXT_BASE
+
+/* SDHI clock freq */
+#define CONFIG_SH_SDHI_FREQ     133000000
+
+#define DRAM_RSV_SIZE           0x08000000
+#define CONFIG_SYS_SDRAM_BASE       (0x40000000 + DRAM_RSV_SIZE)
+#define CONFIG_SYS_SDRAM_SIZE       (0x40000000u - DRAM_RSV_SIZE) //total 1GB
+//#define CONFIG_SYS_SDRAM_SIZE       (0x80000000u - DRAM_RSV_SIZE) //total 2GB
+#define CONFIG_SYS_LOAD_ADDR        0x58000000
+#define CONFIG_LOADADDR         CONFIG_SYS_LOAD_ADDR // Default load address for tfpt,bootp...
+#define CONFIG_VERY_BIG_RAM
+#define CONFIG_MAX_MEM_MAPPED       (0x40000000u - DRAM_RSV_SIZE)
+//#define CONFIG_MAX_MEM_MAPPED       (0x80000000u - DRAM_RSV_SIZE)
+
+#define CONFIG_SYS_MONITOR_BASE     0x00000000
+#define CONFIG_SYS_MONITOR_LEN      (1 * 1024 * 1024)
+#define CONFIG_SYS_MALLOC_LEN       (64 * 1024 * 1024)
+#define CONFIG_SYS_BOOTM_LEN        (64 << 20)
+
+/* The HF/QSPI layout permits up to 1 MiB large bootloader blob */
+#define CONFIG_BOARD_SIZE_LIMIT     1048576
+
+/* I2C configuration */
+#define I2C_VERSACLOCK_ADDR  0x68
+#define I2C_VERSACLOCK_ADDR_LEN 1
+#define I2C_SYS_MODULE    0
+
+#ifndef CONFIG_SYS_I2C_EEPROM_ADDR 
+#define CONFIG_SYS_I2C_EEPROM_ADDR 0x50
+#endif
+#ifndef CONFIG_SYS_I2C_EEPROM_BUS
+#define CONFIG_SYS_I2C_EEPROM_BUS 0
+#endif
+
+
+#define I2C_EEPROM_MAC_ADDR     0x58
+#define ETHER_EEPROM_ADDR       0x9A /* MAC address offset in EEPROM */
+
+#ifdef VEKATECH_UENV_FDTO_SUPPORT
+#define LOAD_FDT_OVERLAYS \
+    OVERLAY_SETTINGS \
+    GET_FDT_OVERLAY_mmc \
+    GET_FDT_OVERLAY_usb \
+    GET_FDT_OVERLAY_net
+#else
+#define LOAD_FDT_OVERLAYS \
+    "loadfdto_mmc=echo overlays are not supported!\0" \
+    "loadfdto_usb=echo overlays are not supported!\0" \
+    "loadfdto_net=echo overlays are not supported!\0"
+#endif
+
+/* Load rzv2l_cm33_rpmsg_demo to run */
+#define CM33_BOOT_ARGS \
+    "dcache off; " \
+    "mmc dev 0; " \
+    "fatload mmc 0:1 0x0001FF80 cm33/rzv2l_cm33_rpmsg_demo_secure_vector.bin; " \
+    "fatload mmc 0:1 0x42EFF440 cm33/rzv2l_cm33_rpmsg_demo_secure_code.bin; " \
+    "fatload mmc 0:1 0x00010000 cm33/rzv2l_cm33_rpmsg_demo_non_secure_vector.bin; " \
+    "fatload mmc 0:1 0x40010000 cm33/rzv2l_cm33_rpmsg_demo_non_secure_code.bin; " \
+    "cm33 start_debug 0x1001FF80 0x00010000; " \
+    "dcache on;"
+
+#define DEFAULT_MMC_UENV_ARGS \
+    "boardID="CONFIG_SYS_BOARD"\0" \
+    "image=Image\0" \
+    "fdtfile="CONFIG_DEFAULT_FDT_FILE"\0" \
+    "dtb_addr=0x48000000\0" \
+    "image_addr=0x48080000\0" \
+    "bootm_size=0x10000000\0" \
+    "loadaddr=0x58000000\0" \
+    "rd_addr=0x50000000\0" \
+    "mmcdev="__stringify(CONFIG_SYS_MMC_DEV)"\0" \
+    "mmcpart="__stringify(CONFIG_SYS_MMC_IMG_LOAD_PART)"\0" \
+    "tftpdir="CONFIG_SYS_BOARD"\0" \
+    "netrootfs=/nfs/"CONFIG_SYS_BOARD"\0" \
+    "netmask=255.255.255.0\0" \
+    "serverip=192.168.2.91\0" \
+    "usbdev="__stringify(CONFIG_SYS_USB_DEV)"\0" \
+    "usbpart="__stringify(CONFIG_SYS_USB_IMG_LOAD_PART)"\0" \
+    "usbbootdir=boot\0" \
+    "bootenvfile=uEnv.txt\0" \
+    "importbootenv=echo Importing environment ...; " \
+        "env import -t ${image_addr} ${filesize}\0" \
+    "bootimage=booti ${image_addr} - ${dtb_addr}\0" \
+    "bootimagerd=booti ${image_addr} ${rd_addr} ${dtb_addr}\0" \
+    "rdinitapp=/home/root/emmc_prog\0" \
+    "cpiofile=core-image-bsp-"CONFIG_SYS_BOARD"-mod.cpio.gz.u-boot\0"
+
+#define DEFAULT_MMC_RZG2UL_ARGS  DEFAULT_MMC_UENV_ARGS
+
+#define GET_IMAGE_USB \
+    "load_usb=echo trying usb...; "          \
+          "usb start; "                      \
+          "usb reset; "                      \
+          "if usb dev ${usbdev}; then "      \
+             "if run loadbootenv_usb; then " \
+                 "run importbootenv; "       \
+             "fi; "                          \
+             "if run loadfdt_usb; then "     \
+                "run loadfdto_usb; "          \
+                "if run loadimage_usb; then " \
+                    "run loadcpio_usb; "     \
+                "fi; "                       \
+             "fi; "                          \
+          "fi;\0"
+
+#define GET_IMAGE_MMC \
+    "load_mmc=echo trying mmc...; "               \
+            "if mmc dev ${mmcdev}; then "         \
+              "if mmc rescan; then "              \
+                  "if run loadbootenv_mmc; then " \
+                      "run importbootenv; "       \
+                  "fi; "                          \
+                  "if run loadfdt_mmc; then "     \
+                      "run loadfdto_mmc; "        \
+                      "run loadimage_mmc; "       \
+                  "fi; "                          \
+              "fi; "                              \
+            "fi;\0"
+
+#define GET_IMAGE_NET \
+    "load_net=echo trying net...; "         \
+            "setenv autoload no; dhcp; "    \
+            "if run loadbootenv_net; then " \
+                "run importbootenv; "       \
+            "fi; "                          \
+            "if run loadfdt_net; then "     \
+                "run loadfdto_net; "        \
+                "run loadimage_net; "       \
+            "fi;\0"
+
+#define BOOT_MMC                        \
+    "if run load_mmc; then "            \
+        "echo Starting from mmc ...; "  \
+        "run bootargs_mmc; "            \
+        "run bootimage; "               \
+    "else "                             \
+        "echo Cannot start from mmc!; " \
+    "fi; "
+
+#define BOOT_USB \
+    "if run load_usb; then "            \
+        "echo Starting from usb ...; "  \
+        "run bootargs_usb; "            \
+        "run bootimagerd; "             \
+    "else "                             \
+        "echo Cannot start from usb!; " \
+    "fi; "
+
+#define BOOT_NET \
+    "if run load_net; then "            \
+        "echo Starting from net ...; "  \
+        "run bootargs_net; "            \
+        "run bootimage; "               \
+    "else "                             \
+        "echo Cannot start from net!; " \
+    "fi; "
+
+/* ENV setting */
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+    DEFAULT_MMC_RZG2UL_ARGS \
+    LOAD_FDT_OVERLAYS \
+    "bootargs_mmc=setenv bootargs rw rootwait earlycon root=/dev/mmcblk"__stringify(CONFIG_SYS_MMC_DEV)"p2 ${extrabootargs}\0" \
+    "bootargs_net=setenv bootargs rw rootwait earlycon root=/dev/nfs ip=dhcp nfsroot=${serverip}:${netrootfs},vers=4,tcp ${extrabootargs}\0" \
+    "bootargs_usb=setenv bootargs rw rootwait earlycon root=/dev/ram0 rdinit=${rdinitapp} ${extrabootargs}\0" \
+    "loadbootenv_mmc=fatload mmc ${mmcdev} ${image_addr} ${bootenvfile}\0" \
+    "loadbootenv_usb=fatload usb ${usbdev} ${image_addr} ${bootenvfile}\0" \
+    "loadbootenv_net=tftp ${image_addr} ${serverip}:${tftpdir}/${bootenvfile}\0" \
+    "loadimage_mmc=fatload mmc ${mmcdev}:${mmcpart} ${image_addr} ${image}\0" \
+    "loadimage_usb=fatload usb ${usbdev}:${usbpart} ${image_addr} ${usbbootdir}/${image}\0" \
+    "loadimage_net=tftp ${image_addr} ${serverip}:${tftpdir}/${image}\0" \
+    "loadfdt_mmc=echo loading ${fdtfile}; fatload mmc ${mmcdev}:${mmcpart} ${dtb_addr} ${fdtfile}\0" \
+    "loadfdt_usb=echo loading ${fdtfile}; fatload usb ${usbdev}:${usbpart} ${dtb_addr} ${usbbootdir}/${fdtfile}\0" \
+    "loadfdt_net=echo loading ${fdtfile}; tftp ${dtb_addr} ${serverip}:${tftpdir}/${fdtfile}\0" \
+    "loadcpio_usb=echo loading ${cpiofile}; fatload usb ${usbdev}:${usbpart} ${rd_addr} ${usbbootdir}/${cpiofile}\0" \
+    GET_IMAGE_MMC \
+    GET_IMAGE_USB \
+    GET_IMAGE_NET \
+    "boot_mmc="BOOT_MMC"\0" \
+    "boot_usb="BOOT_USB"\0" \
+    "boot_net="BOOT_NET"\0"
+
+#define CONFIG_BOOTCOMMAND \
+        BOOT_USB    \
+        BOOT_MMC    \
+        BOOT_NET
+
+/* For board */
+/* Ethernet RAVB */
+#define CONFIG_BITBANGMII_MULTI
+
+#endif /* __VKRZG2UL_H */
diff --git a/include/configs/vkrzv2l.h b/include/configs/vkrzv2l.h
new file mode 100644
index 0000000000..4ae36da15f
--- /dev/null
+++ b/include/configs/vkrzv2l.h
@@ -0,0 +1,228 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (C) 2021 Renesas Electronics Corporation
+ */
+
+#ifndef __VKRZV2L_H__
+#define __VKRZV2L_H__
+
+#include <asm/arch/rmobile.h>
+#include "vk_fdt_overlay.h"
+
+#define __p(x)   x
+
+#define CONFIG_REMAKE_ELF
+
+#ifdef CONFIG_SPL
+#define CONFIG_SPL_TARGET   "spl/u-boot-spl.scif"
+#endif
+
+/* boot option */
+
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+
+/* Generic Interrupt Controller Definitions */
+/* RZ/V2L use GIC-v3 */
+#define CONFIG_GICV3
+#define GICD_BASE   0x11900000
+#define GICR_BASE   0x11960000
+
+/* console */
+#define CONFIG_SYS_CBSIZE       2048
+#define CONFIG_SYS_BARGSIZE     CONFIG_SYS_CBSIZE
+#define CONFIG_SYS_MAXARGS      64
+#define CONFIG_SYS_BAUDRATE_TABLE   { 115200, 38400 }
+
+/* PHY needs a longer autoneg timeout */
+#define PHY_ANEG_TIMEOUT        20000
+
+/* MEMORY */
+#define CONFIG_SYS_INIT_SP_ADDR     CONFIG_SYS_TEXT_BASE
+
+/* SDHI clock freq */
+#define CONFIG_SH_SDHI_FREQ     133000000
+
+#define DRAM_RSV_SIZE           0x08000000
+#define CONFIG_SYS_SDRAM_BASE       (0x40000000 + DRAM_RSV_SIZE)
+//#define CONFIG_SYS_SDRAM_SIZE       (0x40000000u - DRAM_RSV_SIZE) //total 1GB
+#define CONFIG_SYS_SDRAM_SIZE       (0x80000000u - DRAM_RSV_SIZE) //total 2GB
+#define CONFIG_SYS_LOAD_ADDR        0x58000000
+#define CONFIG_LOADADDR         CONFIG_SYS_LOAD_ADDR // Default load address for tfpt,bootp...
+#define CONFIG_VERY_BIG_RAM
+//#define CONFIG_MAX_MEM_MAPPED       (0x40000000u - DRAM_RSV_SIZE)
+#define CONFIG_MAX_MEM_MAPPED       (0x80000000u - DRAM_RSV_SIZE)
+
+#define CONFIG_SYS_MONITOR_BASE     0x00000000
+#define CONFIG_SYS_MONITOR_LEN      (1 * 1024 * 1024)
+#define CONFIG_SYS_MALLOC_LEN       (64 * 1024 * 1024)
+#define CONFIG_SYS_BOOTM_LEN        (64 << 20)
+
+/* The HF/QSPI layout permits up to 1 MiB large bootloader blob */
+#define CONFIG_BOARD_SIZE_LIMIT     1048576
+
+/* I2C configuration */
+#define I2C_VERSACLOCK_ADDR  0x68
+#define I2C_VERSACLOCK_ADDR_LEN 1
+#define I2C_SYS_MODULE    3
+
+//#define CONFIG_OPENCVA 1
+
+#ifdef VEKATECH_UENV_FDTO_SUPPORT
+#define LOAD_FDT_OVERLAYS \
+    OVERLAY_SETTINGS \
+    GET_FDT_OVERLAY_mmc \
+    GET_FDT_OVERLAY_usb \
+    GET_FDT_OVERLAY_net
+#else
+#define LOAD_FDT_OVERLAYS \
+    "loadfdto_mmc=echo overlays are not supported!\0" \
+    "loadfdto_usb=echo overlays are not supported!\0" \
+    "loadfdto_net=echo overlays are not supported!\0"
+#endif
+
+/* Load rzv2l_cm33_rpmsg_demo to run */
+#define CM33_BOOT_ARGS \
+    "dcache off; " \
+    "mmc dev 0; " \
+    "fatload mmc 0:1 0x0001FF80 cm33/rzv2l_cm33_rpmsg_demo_secure_vector.bin; " \
+    "fatload mmc 0:1 0x42EFF440 cm33/rzv2l_cm33_rpmsg_demo_secure_code.bin; " \
+    "fatload mmc 0:1 0x00010000 cm33/rzv2l_cm33_rpmsg_demo_non_secure_vector.bin; " \
+    "fatload mmc 0:1 0x40010000 cm33/rzv2l_cm33_rpmsg_demo_non_secure_code.bin; " \
+    "cm33 start_debug 0x1001FF80 0x00010000; " \
+    "dcache on;"
+
+/* ENV setting */
+
+#define DEFAULT_MMC_UENV_ARGS \
+    "boardID="CONFIG_SYS_BOARD"\0" \
+    "image=Image\0" \
+    "fdtfile="CONFIG_DEFAULT_FDT_FILE"\0" \
+    "dtb_addr=0x48000000\0" \
+    "image_addr=0x48080000\0" \
+    "bootm_size=0x10000000\0" \
+    "loadaddr=0x58000000\0" \
+    "rd_addr=0x50000000\0" \
+    "mmcdev="__stringify(CONFIG_SYS_MMC_DEV)"\0" \
+    "mmcpart="__stringify(CONFIG_SYS_MMC_IMG_LOAD_PART)"\0" \
+    "tftpdir="CONFIG_SYS_BOARD"\0" \
+    "netrootfs=/nfs/"CONFIG_SYS_BOARD"\0" \
+    "netmask=255.255.255.0\0" \
+    "serverip=192.168.2.91\0" \
+    "usbdev="__stringify(CONFIG_SYS_USB_DEV)"\0" \
+    "usbpart="__stringify(CONFIG_SYS_USB_IMG_LOAD_PART)"\0" \
+    "usbbootdir=boot\0" \
+    "bootenvfile=uEnv.txt\0" \
+    "importbootenv=echo Importing environment ...; " \
+        "env import -t ${image_addr} ${filesize}\0" \
+    "bootimage=booti ${image_addr} - ${dtb_addr}\0" \
+    "bootimagerd=booti ${image_addr} ${rd_addr} ${dtb_addr}\0" \
+    "rdinitapp=/home/root/emmc_prog\0" \
+    "cpiofile=core-image-bsp-"CONFIG_SYS_BOARD"-mod.cpio.gz.u-boot\0"
+
+#define DEFAULT_MMC_RZV2L_ARGS  DEFAULT_MMC_UENV_ARGS
+
+#define GET_IMAGE_USB \
+    "load_usb=echo trying usb...; "          \
+          "usb start; "                      \
+          "usb reset; "                      \
+          "if usb dev ${usbdev}; then "      \
+             "if run loadbootenv_usb; then " \
+                 "run importbootenv; "       \
+             "fi; "                          \
+             "if run loadfdt_usb; then "     \
+                "run loadfdto_usb; "          \
+                "if run loadimage_usb; then " \
+                    "run loadcpio_usb; "     \
+                "fi; "                       \
+             "fi; "                          \
+          "fi;\0"
+
+#define GET_IMAGE_MMC \
+    "load_mmc=echo trying mmc...; "               \
+            "if mmc dev ${mmcdev}; then "         \
+              "if mmc rescan; then "              \
+                  "if run loadbootenv_mmc; then " \
+                      "run importbootenv; "       \
+                  "fi; "                          \
+                  "if run loadfdt_mmc; then "     \
+                      "run loadfdto_mmc; "        \
+                      "run loadimage_mmc; "       \
+                  "fi; "                          \
+              "fi; "                              \
+            "fi;\0"
+
+#define GET_IMAGE_NET \
+    "load_net=echo trying net...; "         \
+            "setenv autoload no; dhcp; "    \
+            "if run loadbootenv_net; then " \
+                "run importbootenv; "       \
+            "fi; "                          \
+            "if run loadfdt_net; then "     \
+                "run loadfdto_net; "        \
+                "run loadimage_net; "       \
+            "fi;\0"
+
+#define BOOT_MMC                        \
+    "if run load_mmc; then "            \
+        "echo Starting from mmc ...; "  \
+        "run bootargs_mmc; "            \
+        "run bootimage; "               \
+    "else "                             \
+        "echo Cannot start from mmc!; " \
+    "fi; "
+
+#define BOOT_USB \
+    "if run load_usb; then "            \
+        "echo Starting from usb ...; "  \
+        "run bootargs_usb; "            \
+        "run bootimagerd; "             \
+    "else "                             \
+        "echo Cannot start from usb!; " \
+    "fi; "
+
+#define BOOT_NET \
+    "if run load_net; then "            \
+        "echo Starting from net ...; "  \
+        "run bootargs_net; "            \
+        "run bootimage; "               \
+    "else "                             \
+        "echo Cannot start from net!; " \
+    "fi; "
+
+/* ENV setting */
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+    DEFAULT_MMC_RZV2L_ARGS \
+    LOAD_FDT_OVERLAYS \
+    "bootargs_mmc=setenv bootargs rw rootwait earlycon root=/dev/mmcblk"__stringify(CONFIG_SYS_MMC_DEV)"p2 ${extrabootargs}\0" \
+    "bootargs_net=setenv bootargs rw rootwait earlycon root=/dev/nfs ip=dhcp nfsroot=${serverip}:${netrootfs},vers=4,tcp ${extrabootargs}\0" \
+    "bootargs_usb=setenv bootargs rw rootwait earlycon root=/dev/ram0 rdinit=${rdinitapp} ${extrabootargs}\0" \
+    "loadbootenv_mmc=fatload mmc ${mmcdev} ${image_addr} ${bootenvfile}\0" \
+    "loadbootenv_usb=fatload usb ${usbdev} ${image_addr} ${bootenvfile}\0" \
+    "loadbootenv_net=tftp ${image_addr} ${serverip}:${tftpdir}/${bootenvfile}\0" \
+    "loadimage_mmc=fatload mmc ${mmcdev}:${mmcpart} ${image_addr} ${image}\0" \
+    "loadimage_usb=fatload usb ${usbdev}:${usbpart} ${image_addr} ${usbbootdir}/${image}\0" \
+    "loadimage_net=tftp ${image_addr} ${serverip}:${tftpdir}/${image}\0" \
+    "loadfdt_mmc=echo loading ${fdtfile}; fatload mmc ${mmcdev}:${mmcpart} ${dtb_addr} ${fdtfile}\0" \
+    "loadfdt_usb=echo loading ${fdtfile}; fatload usb ${usbdev}:${usbpart} ${dtb_addr} ${usbbootdir}/${fdtfile}\0" \
+    "loadfdt_net=echo loading ${fdtfile}; tftp ${dtb_addr} ${serverip}:${tftpdir}/${fdtfile}\0" \
+    "loadcpio_usb=echo loading ${cpiofile}; fatload usb ${usbdev}:${usbpart} ${rd_addr} ${usbbootdir}/${cpiofile}\0" \
+    GET_IMAGE_MMC \
+    GET_IMAGE_USB \
+    GET_IMAGE_NET \
+    "boot_mmc="BOOT_MMC"\0" \
+    "boot_usb="BOOT_USB"\0" \
+    "boot_net="BOOT_NET"\0"
+
+#define CONFIG_BOOTCOMMAND \
+        BOOT_USB    \
+        BOOT_MMC    \
+        BOOT_NET
+
+/* For board */
+/* Ethernet RAVB */
+#define CONFIG_BITBANGMII_MULTI
+
+#endif /* __VKRZV2L_H__ */
-- 
2.43.0

