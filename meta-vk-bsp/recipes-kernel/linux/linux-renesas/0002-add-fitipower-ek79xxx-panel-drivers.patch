From 010b7748d72631cee6e2afaec2de24610074ddfb Mon Sep 17 00:00:00 2001
From: dtodoroff <d.todorov@vekatech.com>
Date: Mon, 28 Jul 2025 09:30:35 +0300
Subject: [PATCH 2/2] add fitipower ek79xxx panel drivers


diff --git a/Documentation/devicetree/bindings/display/panel/fitipower,ek79007ad.yaml b/Documentation/devicetree/bindings/display/panel/fitipower,ek79007ad.yaml
new file mode 100644
index 000000000000..6859a89a64f0
--- /dev/null
+++ b/Documentation/devicetree/bindings/display/panel/fitipower,ek79007ad.yaml
@@ -0,0 +1,54 @@
+# SPDX-License-Identifier: GPL-2.0
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/display/panel/fitipower,ek79007ad.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Fitipower EK79007AD based MIPI-DSI panels
+
+maintainers:
+  - Maxime Ripard <mripard@kernel.org>
+
+properties:
+  compatible:
+    items:
+      - enum:
+          - vekatech,vklcd07
+          - vekatech,vklcd-kd070hdfia030
+      - const: fitipower,ek79007ad
+
+  backlight: true
+  power-supply: true
+  reg: true
+  lcd-model: true
+  dsi-lanes: true
+  reset-gpios: true
+  enable-gpios: true
+  power-gpios: true
+
+required:
+  - compatible
+  - power-supply
+  - reg
+
+additionalProperties: false
+
+examples:
+  - |
+
+    dsi {
+        #address-cells = <1>;
+        #size-cells = <0>;
+
+        panel@0 {
+            compatible = "vekatech,vklcd07", "fitipower,ek79007ad";
+            reg = <0>;
+            power-supply = <&reg_5p0v>;
+            backlight = <&backlight>;
+            reset-gpios = <&pinctrl RZG2L_GPIO(43, 1) GPIO_ACTIVE_LOW>;
+            dsi-lanes = <4>;
+            lcd-model = "vklcd07";
+        };
+    };
+
+...
diff --git a/Documentation/devicetree/bindings/display/panel/fitipower,ek79202d.yaml b/Documentation/devicetree/bindings/display/panel/fitipower,ek79202d.yaml
new file mode 100644
index 000000000000..7ea749c62553
--- /dev/null
+++ b/Documentation/devicetree/bindings/display/panel/fitipower,ek79202d.yaml
@@ -0,0 +1,54 @@
+# SPDX-License-Identifier: GPL-2.0
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/display/panel/fitipower,ek79202d.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Fitipower EK79202D based MIPI-DSI panels
+
+maintainers:
+  - Maxime Ripard <mripard@kernel.org>
+
+properties:
+  compatible:
+    items:
+      - enum:
+          - usmp_leadership,ek79202d 
+          - vekatech,vklcd-kd101wxfid045
+      - const: fitipower,ek79202d
+
+  backlight: true
+  power-supply: true
+  reg: true
+  lcd-model: true
+  dsi-lanes: true
+  reset-gpios: true
+  enable-gpios: true
+  power-gpios: true
+
+required:
+  - compatible
+  - power-supply
+  - reg
+
+additionalProperties: false
+
+examples:
+  - |
+
+    dsi {
+        #address-cells = <1>;
+        #size-cells = <0>;
+
+        panel@0 {
+            compatible = "vekatech,vklcd-kd101wxfid045", "fitipower,ek79202d";
+            reg = <0>;
+            power-supply = <&reg_5p0v>;
+            backlight = <&backlight>;
+            reset-gpios = <&pinctrl RZG2L_GPIO(43, 1) GPIO_ACTIVE_LOW>;
+            dsi-lanes = <4>;
+            lcd-model = "kd101wxfid045";
+        };
+    };
+
+...
diff --git a/drivers/gpu/drm/panel/Kconfig b/drivers/gpu/drm/panel/Kconfig
index a582ddd583c2..4f6d8ff9046b 100644
--- a/drivers/gpu/drm/panel/Kconfig
+++ b/drivers/gpu/drm/panel/Kconfig
@@ -154,6 +154,24 @@ config DRM_PANEL_FEIYANG_FY07024DI26A30D
 	  Say Y if you want to enable support for panels based on the
 	  Feiyang FY07024DI26A30-D MIPI-DSI interface.
 
+config DRM_PANEL_FITIPOWER_EK79007AD
+	tristate "Fitipower EK79007AD-based panels"
+	depends on OF
+	depends on DRM_MIPI_DSI
+	depends on BACKLIGHT_CLASS_DEVICE
+	help
+	  Say Y if you want to enable support for panels based on the
+	  Fitipower EK79007AD controller.
+
+config DRM_PANEL_FITIPOWER_EK79202D
+	tristate "Fitipower EK79202D-based panels"
+	depends on OF
+	depends on DRM_MIPI_DSI
+	depends on BACKLIGHT_CLASS_DEVICE
+	help
+	  Say Y if you want to enable support for panels based on the
+	  Fitipower EK79202D controller.
+
 config DRM_PANEL_ILITEK_IL9322
 	tristate "Ilitek ILI9322 320x240 QVGA panels"
 	depends on OF && SPI
diff --git a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
index 34e717382dbb..807cef1048e2 100644
--- a/drivers/gpu/drm/panel/Makefile
+++ b/drivers/gpu/drm/panel/Makefile
@@ -73,3 +73,5 @@ obj-$(CONFIG_DRM_PANEL_TRULY_NT35597_WQXGA) += panel-truly-nt35597.o
 obj-$(CONFIG_DRM_PANEL_VISIONOX_RM69299) += panel-visionox-rm69299.o
 obj-$(CONFIG_DRM_PANEL_WIDECHIPS_WS2401) += panel-widechips-ws2401.o
 obj-$(CONFIG_DRM_PANEL_XINPENG_XPP055C272) += panel-xinpeng-xpp055c272.o
+obj-$(CONFIG_DRM_PANEL_FITIPOWER_EK79007AD) += panel-fitipower-ek79007ad.o
+obj-$(CONFIG_DRM_PANEL_FITIPOWER_EK79202D) += panel-fitipower-ek79202d.o
diff --git a/drivers/gpu/drm/panel/panel-fitipower-ek79007ad.c b/drivers/gpu/drm/panel/panel-fitipower-ek79007ad.c
new file mode 100644
index 000000000000..be70ff601c26
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-fitipower-ek79007ad.c
@@ -0,0 +1,411 @@
+// SPDX-License-Identifier: GPL-2.0
+
+// #define DEBUG
+
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/fb.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+
+#include <linux/gpio/consumer.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+#include <video/mipi_display.h>
+
+struct ek79007ad_instr {
+	u8	cmd;
+	u8	data;
+};
+
+struct ek79007ad_desc {
+	const struct ek79007ad_instr* init;
+	const size_t init_length;
+	const struct drm_display_mode* mode;
+};
+
+struct ek79007ad {
+	struct drm_panel panel;
+	struct mipi_dsi_device* dsi;
+	const struct ek79007ad_desc* desc;
+
+	struct regulator* power;
+    struct {
+        struct gpio_desc* reset;
+        struct gpio_desc* enable;
+        struct gpio_desc* power;
+    } gpio;
+
+};
+
+#define EK79007AD_COMMAND_INSTR(_cmd, _data)		\
+	{						\
+		.cmd = (_cmd),		\
+		.data = (_data),	\
+}
+
+/* support new panel vklcd07 (kwh070kq40-c08) */
+static const struct ek79007ad_instr ek79007ad_init_vklcd07[] = {
+	EK79007AD_COMMAND_INSTR(0xB0, 0x00),
+	EK79007AD_COMMAND_INSTR(0xB1, 0x00),
+	EK79007AD_COMMAND_INSTR(0xB2, 0x00),
+	EK79007AD_COMMAND_INSTR(0xB3, 0x00),
+};
+
+/* support new panel vklcd-kd070hdfia030 (kd070hdfia030) */
+static const struct ek79007ad_instr ek79007ad_init_vklcd_kd070hdfia030[] = {
+	EK79007AD_COMMAND_INSTR(0xB2, 0x40),	// 0x40:4LANE, 0x50: 2LANE
+	EK79007AD_COMMAND_INSTR(0x80, 0x8B),
+	EK79007AD_COMMAND_INSTR(0x81, 0x78),
+	EK79007AD_COMMAND_INSTR(0xB2, 0x40),
+	EK79007AD_COMMAND_INSTR(0xB2, 0x40),
+	EK79007AD_COMMAND_INSTR(0x82, 0x84),
+	EK79007AD_COMMAND_INSTR(0x83, 0x88),
+	EK79007AD_COMMAND_INSTR(0x84, 0xA8),
+	EK79007AD_COMMAND_INSTR(0x85, 0xE3),
+	EK79007AD_COMMAND_INSTR(0x86, 0x88),
+};
+
+
+static inline struct ek79007ad* panel_to_ek79007ad(struct drm_panel* panel) {
+	return container_of(panel, struct ek79007ad, panel);
+}
+
+static int ek79007ad_send_cmd_data(struct ek79007ad* ctx, u8 cmd, u8 data) {
+	u8 buf[2] = { cmd, data };
+	int ret;
+
+	ret = mipi_dsi_dcs_write_buffer(ctx->dsi, buf, sizeof(buf));
+	if (ret < 0) {
+		dev_err(&ctx->dsi->dev, "Write fault %d\n", ret);
+		return ret;
+	}
+	return 0;
+}
+
+static int ek79007ad_read_cmd_data(struct ek79007ad* tftcp, u8 cmd) {
+	u8 buf = 0;
+	int ret;
+
+	ret = mipi_dsi_dcs_read(tftcp->dsi, cmd, &buf, sizeof(buf));
+	if (ret < 0) {
+		dev_err(&tftcp->dsi->dev, "mipi_dsi_dcs_read  fault(%d)\n", ret);
+	}
+
+	return buf;
+}
+#ifdef DEBUG
+static void ek79007ad_dump_reg(struct ek79007ad* ctx) {
+	unsigned int i;
+	typedef struct _DumpData_t{
+		u8 Addr;
+		const char* Name;
+	} DumpData_t;
+
+	const DumpData_t reg_dump_addr[] = {
+		{0x0A, "SLEEP                   "},
+		{0x0D, "INVERSION               "},
+		{0x0E, "Error on DSI            "},
+		{0x0F, "Self-Diagnostic(TBD)    "},
+		{0x36, "Address mode            "},
+		{0x80, "Gamma Ctrl 1            "},
+		{0x81, "Gamma Ctrl 2            "},
+		{0x82, "Gamma Ctrl 3            "},
+		{0x83, "Gamma Ctrl 4            "},
+		{0x84, "Gamma Ctrl 5            "},
+		{0x85, "Gamma Ctrl 6            "},
+		{0xB0, "POWER enable            "},
+		{0xB1, "Res, BIST, DITHER, HFRC "},
+		{0xB2, "Lanes, NBW              "},
+		{0xB3, "SEL, FRAME              "},
+	};
+	dev_dbg(&ctx->dsi->dev, "DSI ek79007ad_dump_reg\n");
+
+	for (i = 0; i < ARRAY_SIZE(reg_dump_addr); i++) {
+		u8 addr = reg_dump_addr[i].Addr;
+		const char* name = reg_dump_addr[i].Name;
+		dev_dbg(&ctx->dsi->dev, "Read reg %s[%02X] = %02X\n", name, addr,
+			ek79007ad_read_cmd_data(ctx, addr));
+	}
+}
+#endif
+static int ek79007ad_prepare(struct drm_panel* panel) {
+	struct ek79007ad* ctx = panel_to_ek79007ad(panel);
+	unsigned int i;
+	u8 reg_b2;
+	int ret;
+
+	dev_dbg(&ctx->dsi->dev, "DSI ek79007ad_prepare()\n");
+
+	/* Power the panel */
+	ret = regulator_enable(ctx->power);
+	if (ret)
+		return ret;
+	msleep(20);
+
+	/* And reset it */
+	gpiod_set_value(ctx->gpio.reset, 1);
+	msleep(30);
+
+	gpiod_set_value(ctx->gpio.reset, 0);
+	msleep(60);
+
+#ifdef DEBUG
+	ek79007ad_dump_reg(ctx);
+#endif
+	for (i = 0; i < ctx->desc->init_length; i++) {
+		const struct ek79007ad_instr* instr = &ctx->desc->init[i];
+		ret = ek79007ad_send_cmd_data(ctx, instr->cmd, instr->data);
+		if (ret)
+			return ret;
+	}
+
+	reg_b2 = 0;
+	switch (ctx->dsi->lanes) {
+	case 2:
+		break;
+	case 3:
+		reg_b2 |= 0x10;
+		break;
+	case 4:
+		reg_b2 |= 0x30;
+		break;
+	default:
+		return -EINVAL;
+	}
+		ret = ek79007ad_send_cmd_data(ctx, 0xB2, reg_b2);
+	if (ret)
+		return ret;
+
+#ifdef DEBUG
+	ek79007ad_dump_reg(ctx);
+#endif
+	ret = mipi_dsi_dcs_set_tear_on(ctx->dsi, MIPI_DSI_DCS_TEAR_MODE_VBLANK);
+	if (ret)
+		return ret;
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(ctx->dsi);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int ek79007ad_enable(struct drm_panel* panel) {
+	struct ek79007ad* ctx = panel_to_ek79007ad(panel);
+
+	int rc = mipi_dsi_dcs_exit_sleep_mode(ctx->dsi);
+	msleep(5);
+	return rc;
+}
+
+static int ek79007ad_disable(struct drm_panel* panel) {
+	struct ek79007ad* ctx = panel_to_ek79007ad(panel);
+
+	return mipi_dsi_dcs_enter_sleep_mode(ctx->dsi);
+}
+
+static int ek79007ad_unprepare(struct drm_panel* panel) {
+	struct ek79007ad* ctx = panel_to_ek79007ad(panel);
+	int ret;
+
+	ret = ek79007ad_send_cmd_data(ctx, 0xB0, 0);
+	if (ret < 0) {
+		dev_err(&ctx->dsi->dev, "Write fault %d\n", ret);
+	}
+
+	mipi_dsi_dcs_enter_sleep_mode(ctx->dsi);
+	regulator_disable(ctx->power);
+	return 0;
+}
+
+static const struct drm_display_mode vklcd07_default_mode = {
+	.clock = 51200,
+
+	.hdisplay = 1024,
+	.hsync_start = 1024 + 160,
+	.hsync_end = 1024 + 160 + 70,
+	.htotal = 1024 + 160 + 70 + 90,
+
+	.vdisplay = 600,
+	.vsync_start = 600 + 23,
+	.vsync_end = 600 + 23 + 5,
+	.vtotal = 600 + 23 + 5 + 7,
+
+	.width_mm = 154,
+	.height_mm = 86,
+};
+
+static const struct drm_display_mode vklcd_kd070hdfia030_default_mode = {
+	.clock = 51200,
+
+	.hdisplay = 1024,
+	.hsync_start = 1024 + 160,
+	.hsync_end = 1024 + 160 + 70,
+	.htotal = 1024 + 160 + 70 + 90,
+
+	.vdisplay = 600,
+	.vsync_start = 600 + 23,
+	.vsync_end = 600 + 23 + 5,
+	.vtotal = 600 + 23 + 5 + 7,
+
+	.width_mm = 154,
+	.height_mm = 86,
+};
+
+static int ek79007ad_get_modes(struct drm_panel* panel,
+	struct drm_connector* connector) {
+	struct ek79007ad* ctx = panel_to_ek79007ad(panel);
+	struct drm_display_mode* mode;
+
+	mode = drm_mode_duplicate(connector->dev, ctx->desc->mode);
+	if (!mode) {
+		dev_err(&ctx->dsi->dev, "failed to add mode %ux%ux@%u\n",
+			ctx->desc->mode->hdisplay,
+			ctx->desc->mode->vdisplay,
+			drm_mode_vrefresh(ctx->desc->mode));
+		return -ENOMEM;
+	}
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	drm_mode_probed_add(connector, mode);
+
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+
+	return 1;
+}
+
+static const struct drm_panel_funcs ek79007ad_funcs = {
+	.prepare = ek79007ad_prepare,
+	.unprepare = ek79007ad_unprepare,
+	.enable = ek79007ad_enable,
+	.disable = ek79007ad_disable,
+	.get_modes = ek79007ad_get_modes,
+};
+
+static int ek79007ad_dsi_probe(struct mipi_dsi_device* dsi) {
+	struct ek79007ad* ctx;
+	int ret;
+
+	ctx = devm_kzalloc(&dsi->dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+	mipi_dsi_set_drvdata(dsi, ctx);
+	ctx->dsi = dsi;
+	ctx->desc = of_device_get_match_data(&dsi->dev);
+
+	if (ek79007ad_init_vklcd07 == ctx->desc->init) {
+		dev_notice(&dsi->dev, "Initialize Vekatech VKLCD07 display\n");
+	}
+
+    if (vklcd_kd070hdfia030_desc == ctx->desc->init ) {
+        dev_notice(&dsi->dev, "Initialize Vekatech KD070HDFIA030 display\n");
+    }
+
+	drm_panel_init(&ctx->panel, &dsi->dev, &ek79007ad_funcs,
+		DRM_MODE_CONNECTOR_DSI);
+
+	ctx->power = devm_regulator_get(&dsi->dev, "power");
+	if (IS_ERR(ctx->power)) {
+		dev_err(&dsi->dev, "Couldn't get our power regulator\n");
+		return PTR_ERR(ctx->power);
+	}
+
+	/* The power GPIO is optional */
+	ctx->gpio.power = devm_gpiod_get_optional(&dsi->dev, "power", GPIOD_OUT_HIGH);
+	if (IS_ERR_OR_NULL(ctx->gpio.power)) {
+		dev_dbg(&dsi->dev, "Couldn't get our power GPIO\n");
+		ctx->gpio.power = NULL;
+	}
+	gpiod_set_value(ctx->gpio.power, 1);
+
+    /* The enable GPIO is optional */
+	ctx->gpio.enable = devm_gpiod_get_optional(&dsi->dev, "enable", GPIOD_OUT_HIGH);
+	if (IS_ERR_OR_NULL(ctx->gpio.enable)) {
+		dev_dbg(&dsi->dev, "Couldn't get our enable GPIO\n");
+		ctx->gpio.enable = NULL;
+	}
+	gpiod_set_value(ctx->gpio.enable, 1);
+
+	ctx->gpio.reset = devm_gpiod_get(&dsi->dev, "reset", GPIOD_OUT_LOW);
+	if (IS_ERR_OR_NULL(ctx->gpio.reset)) {
+		dev_dbg(&dsi->dev, "Couldn't get our reset GPIO\n");
+		ctx->gpio.reset = NULL;
+	}
+
+	ret = of_property_read_u32(dsi->dev.of_node, "dsi-lanes", &dsi->lanes);
+	if (ret < 0) {
+		dev_dbg(&dsi->dev, "Failed to get dsi-lanes property, use default setting - 4 lanes\n");
+		dsi->lanes = 4;
+	} else {
+		dev_dbg(&dsi->dev, "dsi-lanes = %d\n", dsi->lanes);
+	}
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret) {
+		dev_err(&dsi->dev, "Couldn't get our backlight(%d)\n", ret);
+		return ret;
+	}
+
+	drm_panel_add(&ctx->panel);
+
+	/* non-burst mode with sync pulse */
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO_SYNC_PULSE | MIPI_DSI_MODE_LPM;
+
+	dsi->format = MIPI_DSI_FMT_RGB888;
+
+	ret = mipi_dsi_attach(dsi);
+	return ret;
+}
+
+static int ek79007ad_dsi_remove(struct mipi_dsi_device* dsi) {
+	struct ek79007ad* ctx = mipi_dsi_get_drvdata(dsi);
+
+	mipi_dsi_detach(dsi);
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct ek79007ad_desc vklcd07_desc = {
+	.init = ek79007ad_init_vklcd07,
+	.init_length = ARRAY_SIZE(ek79007ad_init_vklcd07),
+	.mode = &vklcd07_default_mode,
+};
+
+static const struct ek79007ad_desc vklcd_kd070hdfia030_desc = {
+	.init = ek79007ad_init_vklcd_kd070hdfia030,
+	.init_length = ARRAY_SIZE(ek79007ad_init_vklcd_kd070hdfia030),
+	.mode = &vklcd_kd070hdfia030_default_mode,
+};
+
+static const struct of_device_id ek79007ad_of_match[] = {
+	{.compatible = "vekatech,vklcd07", .data = &vklcd07_desc },
+	{.compatible = "vekatech,vklcd-kd070hdfia030", .data = &vklcd_kd070hdfia030_desc },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ek79007ad_of_match);
+
+static struct mipi_dsi_driver ek79007ad_dsi_driver = {
+	.probe = ek79007ad_dsi_probe,
+	.remove = ek79007ad_dsi_remove,
+	.driver = {
+		.name = "ek79007ad-dsi",
+		.of_match_table = ek79007ad_of_match,
+	},
+};
+module_mipi_dsi_driver(ek79007ad_dsi_driver);
+
+MODULE_AUTHOR("Stanimir Bonev <bonev.stanimir@gmail.com>");
+MODULE_DESCRIPTION("Fitipower ek79007ad Controller Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/panel-fitipower-ek79202d.c b/drivers/gpu/drm/panel/panel-fitipower-ek79202d.c
new file mode 100644
index 000000000000..a3198624db1c
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-fitipower-ek79202d.c
@@ -0,0 +1,465 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2021-2022, US Micro Products
+ * Modified: Daniel Wu
+ */
+
+//#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/fb.h>
+#include <linux/kernel.h>
+#include <linux/media-bus-format.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+
+#include <linux/gpio/consumer.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+#include <video/mipi_display.h>
+
+#include <linux/errname.h>
+
+//#define DEBUG
+
+// Add for switch panel function
+struct ek79202d_desc {
+	const struct ek79202d_init_cmd* init;
+	const size_t init_length;
+	const struct drm_display_mode* mode;
+};
+
+struct ek79202d {
+	struct drm_panel panel;
+	struct mipi_dsi_device* dsi;
+	// Add for switch panel function
+	const struct ek79202d_desc* desc;
+	//struct backlight_device* backlight;
+	struct regulator* vdd;
+
+    struct {
+        struct gpio_desc* reset;
+        struct gpio_desc* power;
+        struct gpio_desc* enable;
+    } gpio;
+
+};
+
+static const u32 fitipower_bus_formats[] = {
+	MEDIA_BUS_FMT_RGB888_1X24,
+	MEDIA_BUS_FMT_RGB666_1X18,
+	MEDIA_BUS_FMT_RGB565_1X16,
+};
+
+static const u32 fitipower_bus_flags = DRM_BUS_FLAG_DE_LOW | DRM_BUS_FLAG_PIXDATA_SAMPLE_NEGEDGE;
+
+static inline struct ek79202d* panel_to_ek79202d(struct drm_panel* panel) {
+	return container_of(panel, struct ek79202d, panel);
+}
+
+struct ek79202d_init_cmd {
+	size_t len;
+	const char* data;
+};
+
+#define EK79202D_INIT_CMD(...)									\
+{																\
+	.len = sizeof((char[]){__VA_ARGS__}), .data = (char[]) {	\
+		__VA_ARGS__												\
+	}															\
+}
+
+static const struct ek79202d_init_cmd ek97202d_leadership_init_cmds[] = {
+	EK79202D_INIT_CMD(0xCD, 0xAA),
+	EK79202D_INIT_CMD(0x52, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x12, 0x13, 0x10, 0x11, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x03, 0x0C, 0x13, 0x13),
+	EK79202D_INIT_CMD(0x59, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x12, 0x13, 0x10, 0x11, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x03, 0x0C, 0x13, 0x13),
+	EK79202D_INIT_CMD(0x32, 0x02),  // BIST mode select: BIST_PIN=High with
+									// 0x32=0x02 normal display.
+	EK79202D_INIT_CMD(0x34, 0x7E),
+	EK79202D_INIT_CMD(0x5F, 0x38),
+	EK79202D_INIT_CMD(0x2B, 0x20),
+	EK79202D_INIT_CMD(0x35, 0x25),  // 25
+	EK79202D_INIT_CMD(0x33, 0x08),  // ZIGZAG=1
+	EK79202D_INIT_CMD(0x51, 0x80),
+	EK79202D_INIT_CMD(0x73, 0xF0),
+	EK79202D_INIT_CMD(0x74, 0x91),
+	EK79202D_INIT_CMD(0x75, 0x03),
+	EK79202D_INIT_CMD(0x71, 0xC3),
+	EK79202D_INIT_CMD(0x7A, 0x17),
+	EK79202D_INIT_CMD(0x3C, 0x40),
+	EK79202D_INIT_CMD(0x4A, 0x02),
+	EK79202D_INIT_CMD(0x18, 0xFF),
+	EK79202D_INIT_CMD(0x19, 0x1F),
+	EK79202D_INIT_CMD(0x1A, 0xDC),
+	EK79202D_INIT_CMD(0x4E, 0x4A),
+	EK79202D_INIT_CMD(0x4F, 0x4C),
+	EK79202D_INIT_CMD(0x53, 0x37, 0x2A, 0x29, 0x2A, 0x2E, 0x2F, 0x22, 0x0D, 0x0E, 0x0C, 0x0E, 0x0F, 0x10),
+	EK79202D_INIT_CMD(0x54, 0x37, 0x2A, 0x29, 0x2A, 0x2E, 0x2F, 0x22, 0x0D, 0x0E, 0x0C, 0x0E, 0x0F, 0x10),
+	EK79202D_INIT_CMD(0x55, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11),
+	EK79202D_INIT_CMD(0x56, 0x08),
+	EK79202D_INIT_CMD(0x67, 0x22),
+	EK79202D_INIT_CMD(0x6F, 0x01, 0x01, 0x01, 0x0A, 0x01, 0x01),
+	EK79202D_INIT_CMD(0x6D, 0xA5),
+	EK79202D_INIT_CMD(0x6C, 0x08),
+	EK79202D_INIT_CMD(0x0E, 0x0A),
+	EK79202D_INIT_CMD(0x5E, 0x02),
+	EK79202D_INIT_CMD(0x4A, 0x04),
+	EK79202D_INIT_CMD(0x7A, 0x37),
+};
+
+/* support new panel vklcd-kd101wxfid045 (kd101wxfid045) */
+static const struct ek79202d_init_cmd ek79202d_init_vklcd_kd101wxfid045[] = {
+	EK79202D_INIT_CMD(0xCD, 0xAA),
+	EK79202D_INIT_CMD(0x52, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x12, 0x13, 0x10, 0x11, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x03, 0x0C, 0x13, 0x13),
+	EK79202D_INIT_CMD(0x59, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x12, 0x13, 0x10, 0x11, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x03, 0x0C, 0x13, 0x13),
+	EK79202D_INIT_CMD(0x32, 0x02),  // BIST mode select: BIST_PIN=High with
+									// 0x32=0x02 normal display.
+	EK79202D_INIT_CMD(0x34, 0x7E),
+	EK79202D_INIT_CMD(0x5F, 0x38),
+	EK79202D_INIT_CMD(0x2B, 0x20),
+	EK79202D_INIT_CMD(0x35, 0x05),
+	EK79202D_INIT_CMD(0x33, 0x08),
+	EK79202D_INIT_CMD(0x51, 0x80),
+	EK79202D_INIT_CMD(0x73, 0xF0),
+	EK79202D_INIT_CMD(0x74, 0x91),
+	EK79202D_INIT_CMD(0x75, 0x03),
+	EK79202D_INIT_CMD(0x71, 0xE3),
+	EK79202D_INIT_CMD(0x7A, 0x17),
+	EK79202D_INIT_CMD(0x3C, 0x40),
+	EK79202D_INIT_CMD(0x4A, 0x02),
+	EK79202D_INIT_CMD(0x18, 0xFF),
+	EK79202D_INIT_CMD(0x19, 0x1F),
+	EK79202D_INIT_CMD(0x1A, 0xDC),
+	EK79202D_INIT_CMD(0x4E, 0x4A),
+	EK79202D_INIT_CMD(0x4F, 0x4C),
+	EK79202D_INIT_CMD(0x53, 0x37, 0x2A, 0x29, 0x2A, 0x2E, 0x2F, 0x22, 0x0D, 0x0E, 0x0C, 0x0E, 0x0F, 0x10),
+	EK79202D_INIT_CMD(0x54, 0x37, 0x2A, 0x29, 0x2A, 0x2E, 0x2F, 0x22, 0x0D, 0x0E, 0x0C, 0x0E, 0x0F, 0x10),
+	EK79202D_INIT_CMD(0x55, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11),
+	EK79202D_INIT_CMD(0x56, 0x08),
+	EK79202D_INIT_CMD(0x67, 0x22),
+	EK79202D_INIT_CMD(0x57, 0x81),
+	EK79202D_INIT_CMD(0x65, 0x30),
+	EK79202D_INIT_CMD(0x67, 0x22),
+	EK79202D_INIT_CMD(0x6F, 0x19, 0x11, 0x11, 0x0A, 0x01, 0x01),
+	EK79202D_INIT_CMD(0x6D, 0xA5),
+	EK79202D_INIT_CMD(0x6C, 0x08),
+	EK79202D_INIT_CMD(0x0E, 0x0A),
+};
+
+static int ek79202d_prepare(struct drm_panel* panel) {
+	struct ek79202d* ctx = panel_to_ek79202d(panel);
+	struct mipi_dsi_device* dsi = ctx->dsi;
+	unsigned int i;
+	int ret;
+
+	dev_dbg(&ctx->dsi->dev,"%s\n",__func__);
+
+	ret = regulator_enable(ctx->vdd);
+	if (ret) {
+		dev_err(&dsi->dev, "ek79202d_prepare failed %d(%s)\n", ret, errname(ret));
+		return ret;
+	}
+    gpiod_set_value_cansleep(ctx->gpio.power, 1);
+    msleep(20);
+    gpiod_set_value_cansleep(ctx->gpio.enable, 1);
+    gpiod_set_value_cansleep(ctx->gpio.reset, 0);    
+    msleep(20);
+
+	/* And reset it */
+    gpiod_set_value_cansleep(ctx->gpio.reset, 1);
+    msleep(10);
+
+    gpiod_set_value_cansleep(ctx->gpio.reset, 0);
+    msleep(120);
+
+	// Must change to Low Power Mode to send initialization code
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	// Must move following codes from prepare function to solve no crtc problem.
+	for (i = 0; i < ctx->desc->init_length; i++) {
+		const struct ek79202d_init_cmd* cmd = &ctx->desc->init[i];
+
+		ret = mipi_dsi_dcs_write_buffer(dsi, cmd->data, cmd->len);
+
+		if (ret < 0) {
+			dev_err(&dsi->dev, "ek79202d_prepare->mipi_dsi_dcs_write_buffer failed %d(%s), index %d\n", ret, errname(ret), i);
+			return ret;
+		}
+	}
+
+	ret = mipi_dsi_dcs_set_tear_on(ctx->dsi, MIPI_DSI_DCS_TEAR_MODE_VBLANK);
+	if (ret) {
+		dev_err(&dsi->dev, "ek79202d_prepare->mipi_dsi_dcs_set_tear_on failed %d(%s)\n", ret, errname(ret));
+		return ret;
+	}
+	msleep(240);
+	ret = mipi_dsi_dcs_exit_sleep_mode(ctx->dsi);
+	if (ret) {
+		dev_err(&dsi->dev, "ek79202d_prepare->mipi_dsi_dcs_exit_sleep_mode failed %d(%s)\n", ret, errname(ret));
+		return ret;
+	}
+
+	dev_dbg(&dsi->dev, "ek79202d_prepare done\n");
+	return 0;
+}
+
+static int ek79202d_enable(struct drm_panel* panel) {
+	struct ek79202d* ctx = panel_to_ek79202d(panel);
+	struct mipi_dsi_device* dsi = ctx->dsi;
+	int ret;
+
+	msleep(240);
+	ret = mipi_dsi_dcs_exit_sleep_mode(ctx->dsi);
+	if (ret) {
+		dev_err(&dsi->dev, "ek79202d_enable->mipi_dsi_dcs_exit_sleep_mode failed %d(%s)\n", ret, errname(ret));
+		return ret;
+	}
+
+	dev_dbg(&ctx->dsi->dev, "ek79202d_enable done\n");
+	return 0;
+}
+
+static int ek79202d_disable(struct drm_panel* panel) {
+	struct ek79202d* ctx = panel_to_ek79202d(panel);
+
+	dev_dbg(&ctx->dsi->dev, "ek79202d_disable()\n");
+	return mipi_dsi_dcs_enter_sleep_mode(ctx->dsi);
+}
+
+static int ek79202d_unprepare(struct drm_panel* panel) {
+	struct ek79202d* ctx = panel_to_ek79202d(panel);
+	int ret;
+	dev_dbg(&ctx->dsi->dev, "ek79202d_unprepare()\n");
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(ctx->dsi);
+	if (ret < 0)
+		dev_err(panel->dev, "failed to enter sleep mode: %d\n", ret);
+
+	msleep(120);
+
+    gpiod_set_value_cansleep(ctx->gpio.enable, 0);
+	regulator_disable(ctx->vdd);
+	return 0;
+}
+
+static const struct drm_display_mode ek79202d_leadership_mode = {
+	.clock = 70000,
+	//.clock 	= 72400,
+
+	.hdisplay = 1280,
+	.hsync_start = 1280 + 10,
+	.hsync_end = 1280 + 10 + 12,
+	.htotal = 1280 + 10 + 12 + 88,
+
+	.vdisplay = 800,
+	.vsync_start = 800 + 2,
+	.vsync_end = 800 + 2 + 1,
+	.vtotal = 800 + 2 + 1 + 23,
+
+	.width_mm = 143,
+	.height_mm = 229,
+
+};
+static const struct drm_display_mode vklcd_kd101wxfid045_default_mode = {
+	.clock 	= 60333,
+    //.clock = 51200,
+
+    .hdisplay = 1280,
+    .hsync_start = 1280 + 84,
+    .hsync_end = 1280 + 84 + 4,
+    .htotal = 1280 + 84 + 4 + 72,
+
+    .vdisplay = 800,
+    .vsync_start = 800 + 21,
+    .vsync_end = 800 + 21 + 4,
+    .vtotal = 800 + 21 + 4 + 15,
+
+    .width_mm = 217,
+    .height_mm = 136,
+};
+
+static int ek79202d_get_modes(struct drm_panel* panel,
+                              struct drm_connector* connector) {
+	//	struct drm_connector *connector = panel->connector;
+	struct ek79202d* ctx = panel_to_ek79202d(panel);
+	struct drm_display_mode* mode;
+
+	dev_dbg(&ctx->dsi->dev, "ek79202d_get_modes()\n");
+
+	// Add for switch panel function
+	mode = drm_mode_duplicate(connector->dev, ctx->desc->mode);
+	if (!mode) {
+		dev_err(&ctx->dsi->dev, "failed to add mode %ux%ux@%u\n",
+				ctx->desc->mode->hdisplay, ctx->desc->mode->vdisplay,
+				drm_mode_vrefresh(ctx->desc->mode));
+		return -ENOMEM;
+	}
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	drm_mode_probed_add(connector, mode);
+
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	/* Add Bus Formats support */
+	connector->display_info.bus_flags = fitipower_bus_flags;
+	drm_display_info_set_bus_formats(&connector->display_info,
+									fitipower_bus_formats,
+									ARRAY_SIZE(fitipower_bus_formats));
+	return 1;
+}
+
+static const struct drm_panel_funcs ek79202d_funcs = {
+	.disable = ek79202d_disable,
+	.unprepare = ek79202d_unprepare,
+	.prepare = ek79202d_prepare,
+	.enable = ek79202d_enable,
+	.get_modes = ek79202d_get_modes,
+};
+
+static int ek79202d_dsi_probe(struct mipi_dsi_device* dsi) {
+	struct device* dev = &dsi->dev;
+	struct ek79202d* ctx;
+	int ret;
+	u32 video_mode, dsi_lanes;
+
+	dev_dbg(&dsi->dev,"%s\n",__func__);
+
+	ctx = devm_kzalloc(&dsi->dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx) {
+		return -ENOMEM;
+	}
+	mipi_dsi_set_drvdata(dsi, ctx);
+	ctx->dsi = dsi;
+	// Add for switch panel function
+	ctx->desc = of_device_get_match_data(&dsi->dev);
+
+	drm_panel_init(&ctx->panel, dev, &ek79202d_funcs,
+		DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.dev = &dsi->dev;
+	ctx->panel.funcs = &ek79202d_funcs;
+
+	ctx->vdd = devm_regulator_get(&dsi->dev, "power");
+	if (IS_ERR(ctx->vdd)) {
+		ret = PTR_ERR(ctx->vdd);
+		if (ret != -EPROBE_DEFER)
+			dev_err(&dsi->dev, "Couldn't get vdd regulator: %d\n", ret);
+		return ret;
+	}
+
+    /* The power GPIO is optional */
+    ctx->gpio.power = devm_gpiod_get_optional(&dsi->dev, "power", GPIOD_OUT_HIGH);
+    if (IS_ERR_OR_NULL(ctx->gpio.power)) {
+        dev_dbg(&dsi->dev, "Couldn't get our power GPIO\n");
+        ctx->gpio.power = NULL;
+    }
+    gpiod_set_value(ctx->gpio.power, 1);
+
+    /* The enable GPIO is optional */
+    ctx->gpio.enable = devm_gpiod_get_optional(&dsi->dev, "enable", GPIOD_OUT_HIGH);
+    if (IS_ERR_OR_NULL(ctx->gpio.enable)) {
+        dev_dbg(&dsi->dev, "Couldn't get our enable GPIO\n");
+        ctx->gpio.enable = NULL;
+    }
+    gpiod_set_value(ctx->gpio.enable, 1);
+
+    ctx->gpio.reset = devm_gpiod_get_optional(&dsi->dev, "reset", GPIOD_OUT_LOW);
+    if (IS_ERR_OR_NULL(ctx->gpio.reset)) {
+        dev_dbg(&dsi->dev, "Couldn't get our reset GPIO\n");
+        ctx->gpio.reset = NULL;
+    }
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret) {
+		dev_err(&dsi->dev, "Couldn't get our backlight(%d)\n", ret);
+		return ret;
+	}
+
+	drm_panel_add(&ctx->panel);
+
+	/* get DSI Mode and Data Lanes from device tree */
+	ret = of_property_read_u32(dsi->dev.of_node, "dsi-lanes", &dsi_lanes);
+	dev_dbg(&ctx->dsi->dev, "ek79202d_dsi_probe - dsi_lanes %d\n", dsi_lanes);
+	dsi->lanes = dsi_lanes;
+
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO_HSE | MIPI_DSI_MODE_VIDEO;
+	ret = of_property_read_u32(dsi->dev.of_node, "video-mode", &video_mode);
+	if (!ret) {
+		dev_dbg(&ctx->dsi->dev, "ek79202d_dsi_probe - video_mode %d\n", video_mode);
+		switch (video_mode) {
+		case 0:
+			/* burst mode */
+			dsi->mode_flags |= MIPI_DSI_MODE_VIDEO_BURST;
+			break;
+		case 1:
+			/* non-burst mode with sync event */
+			break;
+		case 2:
+			/* non-burst mode with sync pulse */
+			dsi->mode_flags |= MIPI_DSI_MODE_VIDEO_SYNC_PULSE;
+			break;
+		default:
+			dev_warn(&dsi->dev, "invalid video mode %d\n", video_mode);
+			dsi->mode_flags |= MIPI_DSI_MODE_VIDEO_SYNC_PULSE;
+			break;
+		}
+	} else {
+		dev_warn(&ctx->dsi->dev, "ek79202d_dsi_probe - video_mode invalid\n");
+	}
+
+	dsi->format = MIPI_DSI_FMT_RGB888;
+
+	ret = mipi_dsi_attach(dsi);
+	return ret;
+}
+
+static int ek79202d_dsi_remove(struct mipi_dsi_device* dsi) {
+	struct ek79202d* ctx = mipi_dsi_get_drvdata(dsi);
+
+	mipi_dsi_detach(dsi);
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+// Add for switch panel function
+static const struct ek79202d_desc ek79202d_leadership_desc = {
+	.init = ek97202d_leadership_init_cmds,
+	.init_length = ARRAY_SIZE(ek97202d_leadership_init_cmds),
+	.mode = &ek79202d_leadership_mode,
+};
+
+static const struct ek79202d_desc vklcd_kd101wxfid045_desc = {
+	.init = ek79202d_init_vklcd_kd101wxfid045,
+	.init_length = ARRAY_SIZE(ek79202d_init_vklcd_kd101wxfid045),
+	.mode = &vklcd_kd101wxfid045_default_mode,
+};
+
+static const struct of_device_id ek79202d_of_match[] = {
+	{.compatible = "usmp_leadership,ek79202d", .data = &ek79202d_leadership_desc},
+	{.compatible = "vekatech,vklcd-kd101wxfid045", .data = &vklcd_kd101wxfid045_desc},
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ek79202d_of_match);
+
+static struct mipi_dsi_driver ek79202d_driver = {
+	.probe = ek79202d_dsi_probe,
+	.remove = ek79202d_dsi_remove,
+	.driver ={
+		.name = "ek79202d-dsi",
+		.of_match_table = ek79202d_of_match,
+	},
+};
+
+module_mipi_dsi_driver(ek79202d_driver);
+
+MODULE_AUTHOR("Daniel Wu <dwu@xxxxxxxxxxxxxxxxxxxx>");
+MODULE_DESCRIPTION("Fitipower EK79202D Controller Driver");
+MODULE_LICENSE("GPL v2");
-- 
2.43.0

